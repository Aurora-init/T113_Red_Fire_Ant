###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               26/Mar/2023  16:31:31
# Copyright 2004-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Components\stack\zcl\zcl_general.c
#    Command line       =  
#        -f C:\Users\11148\AppData\Local\Temp\EWDDD3.tmp
#        ("D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Components\stack\zcl\zcl_general.c"
#        -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xZTOOL_P1
#        -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D LCD_SUPPORTED=DEBUG -D
#        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_DISCOVER -D ZCL_WRITE -D
#        ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF -D ZCL_GROUPS -D
#        ZCL_LEVEL_CTRL -D HAL_KEY=FALSE -D xISR_KEYINTERRUPT -D HAL_UART=TRUE
#        -D INT_HEAP_LEN=2048 -D HAL_LCD=TRUE -D HAL_LCD_OLED12864=TRUE -D
#        HAL_ADC=TRUE -D HAL_DHT11=TRUE -lC
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Router\List"
#        -lA
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Router\List"
#        --diag_suppress Pe001,Pa010 -o
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Router\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Tools\f8wRouter.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Tools\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0402
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x5a, 0x69, 0x67, 0x42,
#        0x65,0x65, 0x41, 0x6c, 0x6c, 0x69, 0x61, 0x6e, 0x63, 0x65, 0x30,
#        0x39}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
#        -DENABLE_LED4_DISABLE_S1) -f
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Tools\f8wZCL.cfg"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        & 光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\" -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\hal\include\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\hal\target\CC2530EB\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\hal\userspace\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mac\include\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mac\high_level\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mac\low_level\srf04\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mt\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\osal\include\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\services\saddr\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\services\sdata\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\af\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\bdb\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\gp\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\nwk\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\sapi\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\sec\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\sys\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\zcl\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\zdo\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\zmac\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\zmac\f8w\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Applications\"
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_China.936
#    List file          =  
#        D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Router\List\zcl_general.lst
#    Object file        =  
#        D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Router\Obj\zcl_general.r51
#
###############################################################################

D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度 & 光照度采集系统\ZigBee设备端固件与源码\源码\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2015-09-10 09:36:48 -0700 (Thu, 10 Sep 2015) $
      4            Revision:       $Revision: 44493 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License"). You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product. Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "zcl.h"
     46          #include "zcl_general.h"
     47          //#include "ZDApp.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          #include "bdb.h"
     53          
     54          /*********************************************************************
     55           * MACROS
     56           */
     57          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     58          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     59          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     60          
     61          #ifdef ZCL_SCENES
     62          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     63          #endif // ZCL_SCENES
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          
     69          /*********************************************************************
     70           * TYPEDEFS
     71           */
     72          typedef struct zclGenCBRec
     73          {
     74            struct zclGenCBRec        *next;
     75            uint8                     endpoint; // Used to link it into the endpoint descriptor
     76            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     77          } zclGenCBRec_t;
     78          
     79          typedef struct zclGenSceneItem
     80          {
     81            struct zclGenSceneItem    *next;
     82            uint8                     endpoint; // Used to link it into the endpoint descriptor
     83            zclGeneral_Scene_t        scene;    // Scene info
     84          } zclGenSceneItem_t;
     85          
     86          typedef struct zclGenAlarmItem
     87          {
     88            struct zclGenAlarmItem    *next;
     89            uint8                     endpoint; // Used to link it into the endpoint descriptor
     90            zclGeneral_Alarm_t        alarm;    // Alarm info
     91          } zclGenAlarmItem_t;
     92          
     93          // Scene NV types
     94          typedef struct
     95          {
     96            uint16                    numRecs;
     97          } nvGenScenesHdr_t;
     98          
     99          typedef struct zclGenSceneNVItem
    100          {
    101            uint8                     endpoint;
    102            zclGeneral_Scene_t        scene;
    103          } zclGenSceneNVItem_t;
    104          
    105          /*********************************************************************
    106           * GLOBAL VARIABLES
    107           */
    108          
    109          /*********************************************************************
    110           * GLOBAL FUNCTIONS
    111           */
    112          
    113          /*********************************************************************
    114           * LOCAL VARIABLES
    115           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    116          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    117          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    118          
    119          #if defined( ZCL_SCENES )
    120            #if !defined ( ZCL_STANDALONE )
    121              static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    122            #endif
    123          #endif // ZCL_SCENES
    124          
    125          #ifdef ZCL_ALARMS
    126          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    127          #endif // ZCL_ALARMS
    128          
    129          /*********************************************************************
    130           * LOCAL FUNCTIONS
    131           */
    132          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    133          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    134          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    135          
    136          // Device Configuration and Installation clusters
    137          #ifdef ZCL_BASIC
    138          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    139          #endif // ZCL_BASIC
    140          
    141          #ifdef ZCL_IDENTIFY
    142          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    143          #endif // ZCL_IDENTIFY
    144          
    145          // Groups and Scenes clusters
    146          #ifdef ZCL_GROUPS
    147          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    148          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    149          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    150          #endif // ZCL_GROUPS
    151          
    152          #ifdef ZCL_SCENES
    153          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    154          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    155          #endif // ZCL_SCENES
    156          
    157          // On/Off and Level Control Configuration clusters
    158          #ifdef ZCL_ON_OFF
    159          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    160          #endif // ZCL_ONOFF
    161          
    162          #ifdef ZCL_LEVEL_CTRL
    163          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    164          #endif // ZCL_LEVEL_CTRL
    165          
    166          // Alarms cluster
    167          #ifdef ZCL_ALARMS
    168          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    169          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    170          #endif // ZCL_ALARMS
    171          
    172          // Location cluster
    173          #ifdef ZCL_LOCATION
    174          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    175          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    176          #endif // ZCL_LOCATION
    177          
    178          #ifdef ZCL_SCENES
    179            #if !defined ( ZCL_STANDALONE )
    180              static uint8 zclGeneral_ScenesInitNV( void );
    181              static void zclGeneral_ScenesSetDefaultNV( void );
    182              static void zclGeneral_ScenesWriteNV( void );
    183              static uint16 zclGeneral_ScenesRestoreFromNV( void );
    184            #endif
    185          #endif // ZCL_SCENES
    186          
    187          /*********************************************************************
    188           * @fn      zclGeneral_RegisterCmdCallbacks
    189           *
    190           * @brief   Register an applications command callbacks
    191           *
    192           * @param   endpoint - application's endpoint
    193           * @param   callbacks - pointer to the callback record.
    194           *
    195           * @return  ZMemError if not able to allocate
    196           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    197          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    198          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
    199            zclGenCBRec_t *pNewItem;
    200            zclGenCBRec_t *pLoop;
    201          
    202            // Register as a ZCL Plugin
    203            if ( zclGenPluginRegisted == FALSE )
   \   00000B   90....       MOV       DPTR,#zclGenPluginRegisted
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   7021         JNZ       ??zclGeneral_RegisterCmdCallbacks_0
    204            {
    205              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    206                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    207                                  zclGeneral_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV       ?V2,#`??zclGeneral_HdlIncoming::?relay` & 0xff
   \   000014   75....       MOV       ?V3,#(`??zclGeneral_HdlIncoming::?relay` >> 8) & 0xff
   \   000017   78..         MOV       R0,#?V2
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   7C14         MOV       R4,#0x14
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7A00         MOV       R2,#0x0
   \   000022   7B00         MOV       R3,#0x0
   \   000024   12....       LCALL     `??zcl_registerPlugin::?relay`; Banked call to: zcl_registerPlugin
   \   000027   7402         MOV       A,#0x2
   \   000029   12....       LCALL     ?DEALLOC_XSTACK8
    208          
    209          #ifdef ZCL_SCENES
    210              // Initialize the Scenes Table
    211              zclGeneral_ScenesInit();
    212          #endif // ZCL_SCENES
    213          
    214              zclGenPluginRegisted = TRUE;
   \   00002C   90....       MOV       DPTR,#zclGenPluginRegisted
   \   00002F   7401         MOV       A,#0x1
   \   000031   F0           MOVX      @DPTR,A
    215            }
    216          
    217            // Fill in the new profile list
    218            pNewItem = zcl_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A05         MOV       R2,#0x5
   \   000034   7B00         MOV       R3,#0x0
   \   000036   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000039   8A..         MOV       ?V2,R2
   \   00003B   8B..         MOV       ?V3,R3
   \   00003D   A8..         MOV       R0,?V2
   \   00003F   A9..         MOV       R1,?V3
    219            if ( pNewItem == NULL )
   \   000041   E8           MOV       A,R0
   \   000042   49           ORL       A,R1
   \   000043   7004         JNZ       ??zclGeneral_RegisterCmdCallbacks_1
    220              return (ZMemError);
   \   000045   7910         MOV       R1,#0x10
   \   000047   803E         SJMP      ??zclGeneral_RegisterCmdCallbacks_2
    221          
    222            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_1:
   \   000049   8882         MOV       DPL,R0
   \   00004B   8983         MOV       DPH,R1
   \   00004D   E4           CLR       A
   \   00004E   F0           MOVX      @DPTR,A
   \   00004F   A3           INC       DPTR
   \   000050   F0           MOVX      @DPTR,A
    223            pNewItem->endpoint = endpoint;
   \   000051   8882         MOV       DPL,R0
   \   000053   8983         MOV       DPH,R1
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   E5..         MOV       A,?V0
   \   000059   F0           MOVX      @DPTR,A
    224            pNewItem->CBs = callbacks;
   \   00005A   8882         MOV       DPL,R0
   \   00005C   8983         MOV       DPH,R1
   \   00005E   A3           INC       DPTR
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   EE           MOV       A,R6
   \   000062   F0           MOVX      @DPTR,A
   \   000063   A3           INC       DPTR
   \   000064   EF           MOV       A,R7
   \   000065   F0           MOVX      @DPTR,A
    225          
    226            // Find spot in list
    227            if (  zclGenCBs == NULL )
   \   000066   90....       MOV       DPTR,#zclGenCBs
   \   000069   12....       LCALL     ??Subroutine51_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   00006C   90....       MOV       DPTR,#zclGenCBs
   \   00006F   6011         JZ        ??zclGeneral_RegisterCmdCallbacks_3
    228            {
    229              zclGenCBs = pNewItem;
    230            }
    231            else
    232            {
    233              // Look for end of list
    234              pLoop = zclGenCBs;
   \   000071   12....       LCALL     ??Subroutine47_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000074   8003         SJMP      ??zclGeneral_RegisterCmdCallbacks_4
    235              while ( pLoop->next != NULL )
    236                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   000076   EA           MOV       A,R2
   \   000077   FC           MOV       R4,A
   \   000078   EB           MOV       A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   000079   12....       LCALL     ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   00007C   70F8         JNZ       ??zclGeneral_RegisterCmdCallbacks_5
    237          
    238              // Put new item at end of list
    239              pLoop->next = pNewItem;
   \   00007E   8C82         MOV       DPL,R4
   \   000080   8D83         MOV       DPH,R5
    240            }
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000082   12....       LCALL     ?Subroutine27 & 0xFFFF
    241          
    242            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_73:
   \   000085   7900         MOV       R1,#0x0
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   000087   02....       LJMP      ??Subroutine42_0 & 0xFFFF
    243          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   E8           MOV       A,R0
   \   000001                REQUIRE ??Subroutine43_0
   \   000001                ; // Fall through to label ??Subroutine43_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   E9           MOV       A,R1
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine47_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine50_0:
   \   000000   FD           MOV       R5,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005                REQUIRE ??Subroutine51_0
   \   000005                ; // Fall through to label ??Subroutine51_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine51_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   22           RET
    244          
    245          #ifdef ZCL_IDENTIFY
    246          /*********************************************************************
    247           * @fn      zclGeneral_SendIdentify
    248           *
    249           * @brief   Call to send out an Identify Command
    250           *
    251           * @param   srcEP - Sending application's endpoint
    252           * @param   dstAddr - where you want the message to go
    253           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    254           * @param   seqNum - identification number for the transaction
    255           *
    256           * @return  ZStatus_t
    257           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    258          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    259                                             uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    260          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    261            uint8 buf[2];
    262          
    263            buf[0] = LO_UINT16( identifyTime );
   \   00000C   EC           MOV       A,R4
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    264            buf[1] = HI_UINT16( identifyTime );
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ?Subroutine26 & 0xFFFF
    265          
    266            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    267                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    268                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_50:
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   75..02       MOV       ?V0,#0x2
   \   000022   75..00       MOV       ?V1,#0x0
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   7411         MOV       A,#0x11
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000035   E4           CLR       A
   \   000036   F5..         MOV       ?V0,A
   \   000038   78..         MOV       R0,#?V0
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7413         MOV       A,#0x13
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000048   75..00       MOV       ?V0,#0x0
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000050   75..01       MOV       ?V0,#0x1
   \   000053   02....       LJMP      ?Subroutine1 & 0xFFFF
    269          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   ED           MOV       A,R5
   \   000001   F0           MOVX      @DPTR,A
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002   A8..         MOV       R0,?XSP + 0
   \   000004   A9..         MOV       R1,?XSP + 1
   \   000006   88..         MOV       ?V0,R0
   \   000008   89..         MOV       ?V1,R1
   \   00000A   78..         MOV       R0,#?V0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   78..         MOV       R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   78..         MOV       R0,#?V0
   \   000002   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000005   75..00       MOV       ?V0,#0x0
   \   000008   78..         MOV       R0,#?V0
   \   00000A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00000D   7C03         MOV       R4,#0x3
   \   00000F   7D00         MOV       R5,#0x0
   \   000011   EE           MOV       A,R6
   \   000012   F9           MOV       R1,A
   \   000013   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000016   740B         MOV       A,#0xb
   \   000018   12....       LCALL     ?DEALLOC_XSTACK8
   \   00001B   7402         MOV       A,#0x2
   \   00001D                REQUIRE ??Subroutine52_0
   \   00001D                ; // Fall through to label ??Subroutine52_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine52_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine53_0
   \   000003                ; // Fall through to label ??Subroutine53_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine53_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    270          
    271          /*********************************************************************
    272           * @fn      zclGeneral_SendIdentifyEZModeInvoke
    273           *
    274           * @brief   Call to send out an Identify EZ-Mode Invoke Command
    275           *
    276           * @param   srcEP - Sending application's endpoint
    277           * @param   dstAddr - where you want the message to go
    278           * @param   action - describes the EZ-Mode action to be performed
    279           * @param   seqNum - identification number for the transaction
    280           *
    281           * @return  ZStatus_t
    282           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    283          ZStatus_t zclGeneral_SendIdentifyEZModeInvoke( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyEZModeInvoke:
    284                                                         uint8 action, uint8 disableDefaultRsp, uint8 seqNum )
    285          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
    286            uint8 buf[1];
    287          
    288            buf[0] = action;
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   12....       LCALL     ??Subroutine38_0 & 0xFFFF
    289          
    290            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    291                                    COMMAND_IDENTIFY_EZMODE_INVOKE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    292                                    disableDefaultRsp, 0, seqNum, 1, buf );
   \                     ??CrossCallReturnLabel_69:
   \   000016   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000019   75..01       MOV       ?V2,#0x1
   \   00001C   75..00       MOV       ?V3,#0x0
   \   00001F   78..         MOV       R0,#?V2
   \   000021   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000024   7411         MOV       A,#0x11
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00002C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00002F   E4           CLR       A
   \   000030   F5..         MOV       ?V2,A
   \   000032   78..         MOV       R0,#?V2
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000037   ED           MOV       A,R5
   \   000038   F5..         MOV       ?V1,A
   \   00003A   78..         MOV       R0,#?V1
   \   00003C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00003F   75..00       MOV       ?V1,#0x0
   \   000042   78..         MOV       R0,#?V1
   \   000044   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000047   75..01       MOV       ?V1,#0x1
   \   00004A   78..         MOV       R0,#?V1
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004F   75..02       MOV       ?V1,#0x2
   \   000052   78..         MOV       R0,#?V1
   \   000054   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000057   7C03         MOV       R4,#0x3
   \   000059   7D00         MOV       R5,#0x0
   \   00005B   EE           MOV       A,R6
   \   00005C   F9           MOV       R1,A
   \   00005D   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000060   740B         MOV       A,#0xb
   \   000062   12....       LCALL     ?DEALLOC_XSTACK8
   \   000065   7401         MOV       A,#0x1
   \   000067   02....       LJMP      ??Subroutine41_0 & 0xFFFF
    293          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001   A8..         MOV       R0,?XSP + 0
   \   000003   A9..         MOV       R1,?XSP + 1
   \   000005   88..         MOV       ?V2,R0
   \   000007   89..         MOV       ?V3,R1
   \   000009   78..         MOV       R0,#?V2
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V1,A
   \   000003   78..         MOV       R0,#?V1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine41_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine42_0
   \   000003                ; // Fall through to label ??Subroutine42_0
    294          
    295          /*********************************************************************
    296           * @fn      zclGeneral_SendIdentifyUpdateCommState
    297           *
    298           * @brief   Call to send out an Identify Update Commission State Command
    299           *
    300           * @param   srcEP - Sending application's endpoint
    301           * @param   dstAddr - where you want the message to go
    302           * @param   action - describes the EZ-Mode action to be performed
    303           * @param   commissionStateMask - updates the device's commission state
    304           * @param   seqNum - identification number for the transaction
    305           *
    306           * @return  ZStatus_t
    307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    308          ZStatus_t zclGeneral_SendIdentifyUpdateCommState( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyUpdateCommState:
    309                                                            uint8 action, uint8 commissionStateMask,
    310                                                            uint8 disableDefaultRsp, uint8 seqNum )
    311          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
    312            uint8 buf[2];
    313          
    314            buf[0] = action;
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    315            buf[1] = commissionStateMask;
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   ED           MOV       A,R5
   \   00001A   12....       LCALL     ??Subroutine38_0 & 0xFFFF
    316          
    317            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    318                                    COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    319                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_70:
   \   00001D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000020   75..02       MOV       ?V2,#0x2
   \   000023   75..00       MOV       ?V3,#0x0
   \   000026   78..         MOV       R0,#?V2
   \   000028   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002B   7413         MOV       A,#0x13
   \   00002D   12....       LCALL     ?XSTACK_DISP0_8
   \   000030   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000036   E4           CLR       A
   \   000037   F5..         MOV       ?V2,A
   \   000039   78..         MOV       R0,#?V2
   \   00003B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003E   7415         MOV       A,#0x15
   \   000040   12....       LCALL     ?XSTACK_DISP0_8
   \   000043   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000046   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000049   75..00       MOV       ?V1,#0x0
   \   00004C   78..         MOV       R0,#?V1
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000051   75..01       MOV       ?V1,#0x1
   \   000054   78..         MOV       R0,#?V1
   \   000056   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000059   75..03       MOV       ?V1,#0x3
   \   00005C   78..         MOV       R0,#?V1
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000061   7C03         MOV       R4,#0x3
   \   000063   02....       LJMP      ?Subroutine0 & 0xFFFF
    320          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7D00         MOV       R5,#0x0
   \   000002   EE           MOV       A,R6
   \   000003   F9           MOV       R1,A
   \   000004                REQUIRE ??Subroutine40_0
   \   000004                ; // Fall through to label ??Subroutine40_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000003   740B         MOV       A,#0xb
   \   000005   12....       LCALL     ?DEALLOC_XSTACK8
   \   000008   7402         MOV       A,#0x2
   \   00000A                REQUIRE ??Subroutine41_0
   \   00000A                ; // Fall through to label ??Subroutine41_0
    321          
    322          #ifdef ZCL_LIGHT_LINK_ENHANCE
    323          /*********************************************************************
    324           * @fn      zclGeneral_SendIdentifyTriggerEffect
    325           *
    326           * @brief   Call to send out a Trigger Effect Command
    327           *
    328           * @param   srcEP - Sending application's endpoint
    329           * @param   dstAddr - where you want the message to go
    330           * @param   effectId - identify effect to use
    331           * @param   effectVariant - which variant of effect to be triggered
    332           * @param   disableDefaultRsp - whether to disable the Default Response command
    333           * @param   seqNum - identification number for the transaction
    334           *
    335           * @return  ZStatus_t
    336           */
    337          ZStatus_t zclGeneral_SendIdentifyTriggerEffect( uint8 srcEP, afAddrType_t *dstAddr,
    338                                                          uint8 effectId, uint8 effectVariant,
    339                                                          uint8 disableDefaultRsp, uint8 seqNum )
    340          {
    341            uint8 buf[2];
    342          
    343            buf[0] = effectId;
    344            buf[1] = effectVariant;
    345          
    346            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    347                                    COMMAND_IDENTIFY_TRIGGER_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    348                                    disableDefaultRsp, 0, seqNum, 2, buf );
    349          }
    350          #endif // ZCL_LIGHT_LINK_ENHANCE
    351          
    352          /*********************************************************************
    353           * @fn      zclGeneral_SendIdentifyQueryResponse
    354           *
    355           * @brief   Call to send out an Identify Query Response Command
    356           *
    357           * @param   srcEP - Sending application's endpoint
    358           * @param   dstAddr - where you want the message to go
    359           * @param   timeout - how long the device will continue to identify itself (in seconds)
    360           * @param   seqNum - identification number for the transaction
    361           *
    362           * @return  ZStatus_t
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    365                                                          uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    366          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    367            uint8 buf[2];
    368          
    369            buf[0] = LO_UINT16( timeout );
   \   00000C   EC           MOV       A,R4
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    370            buf[1] = HI_UINT16( timeout );
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ?Subroutine26 & 0xFFFF
    371          
    372            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    373                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    374                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_51:
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   75..02       MOV       ?V0,#0x2
   \   000022   75..00       MOV       ?V1,#0x0
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   7411         MOV       A,#0x11
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000035   E4           CLR       A
   \   000036   F5..         MOV       ?V0,A
   \   000038   78..         MOV       R0,#?V0
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7413         MOV       A,#0x13
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000048   75..01       MOV       ?V0,#0x1
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000050   02....       LJMP      ?Subroutine1 & 0xFFFF
    375          }
    376          #endif // ZCL_IDENTIFY
    377          
    378          #ifdef ZCL_GROUPS
    379          /*********************************************************************
    380           * @fn      zclGeneral_SendGroupRequest
    381           *
    382           * @brief   Send a Group Request to a device.  You can also use the
    383           *          appropriate macro.
    384           *
    385           * @param   srcEP - Sending Apps endpoint
    386           * @param   dstAddr - where to send the request
    387           * @param   cmd - one of the following:
    388           *              COMMAND_GROUP_VIEW
    389           *              COMMAND_GROUP_REMOVE
    390           * @param   groupID -
    391           *
    392           * @return  ZStatus_t
    393           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    394          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupRequest:
    395                                                 uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    396          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
   \   00000C   EC           MOV       A,R4
   \   00000D   FE           MOV       R6,A
   \   00000E   ED           MOV       A,R5
   \   00000F   FF           MOV       R7,A
   \   000010   740E         MOV       A,#0xe
   \   000012   12....       LCALL     ?XSTACK_DISP0_8
   \   000015   12....       LCALL     ?Subroutine21 & 0xFFFF
    397            uint8 buf[2];
    398          
    399            buf[0] = LO_UINT16( groupID );
   \                     ??CrossCallReturnLabel_40:
   \   000018   85..82       MOV       DPL,?XSP + 0
   \   00001B   85..83       MOV       DPH,?XSP + 1
   \   00001E   F0           MOVX      @DPTR,A
    400            buf[1] = HI_UINT16( groupID );
   \   00001F   7401         MOV       A,#0x1
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ?Subroutine25 & 0xFFFF
    401          
    402            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    403                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    404                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
   \                     ??CrossCallReturnLabel_65:
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   75..02       MOV       ?V2,#0x2
   \   00002D   75..00       MOV       ?V3,#0x0
   \   000030   78..         MOV       R0,#?V2
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000035   7414         MOV       A,#0x14
   \   000037   12....       LCALL     ?XSTACK_DISP0_8
   \   00003A   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000040   E4           CLR       A
   \   000041   F5..         MOV       ?V2,A
   \   000043   78..         MOV       R0,#?V2
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000048   EF           MOV       A,R7
   \   000049   F5..         MOV       ?V1,A
   \   00004B   78..         MOV       R0,#?V1
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000050   75..00       MOV       ?V1,#0x0
   \   000053   78..         MOV       R0,#?V1
   \   000055   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000058   75..01       MOV       ?V1,#0x1
   \   00005B   78..         MOV       R0,#?V1
   \   00005D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000060   EE           MOV       A,R6
   \   000061   F5..         MOV       ?V1,A
   \   000063   78..         MOV       R0,#?V1
   \   000065   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000068   7C04         MOV       R4,#0x4
   \   00006A   7D00         MOV       R5,#0x0
   \   00006C   A9..         MOV       R1,?V0
   \   00006E   02....       LJMP      ??Subroutine40_0 & 0xFFFF
    405          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   E9           MOV       A,R1
   \   000001                REQUIRE ??Subroutine38_0
   \   000001                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   E8           MOV       A,R0
   \   000006   22           RET
    406          
    407          /*********************************************************************
    408           * @fn      zclGeneral_SendAddGroupRequest
    409           *
    410           * @brief   Send the Add Group Request to a device
    411           *
    412           * @param   srcEP - Sending Apps endpoint
    413           * @param   dstAddr - where to send the request
    414           * @param   cmd - one of the following:
    415           *                COMMAND_GROUP_ADD
    416           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    417           * @param   groupID - pointer to the group structure
    418           * @param   groupName - pointer to Group Name.  This is a Zigbee
    419           *          string data type, so the first byte is the length of the
    420           *          name (in bytes), then the name.
    421           *
    422           * @return  ZStatus_t
    423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    424          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendAddGroupRequest:
    425                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    426                                                    uint8 disableDefaultRsp, uint8 seqNum )
    427          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V7,R1
   \   00000C   8A..         MOV       ?V10,R2
   \   00000E   8B..         MOV       ?V11,R3
   \   000010   8C..         MOV       ?V9,R4
   \   000012   8D..         MOV       ?V8,R5
   \   000014   7417         MOV       A,#0x17
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ?Subroutine15 & 0xFFFF
    428            uint8 *buf;
    429            uint8 *pBuf;
    430            uint8 len;
    431            ZStatus_t status;
    432          
    433            len = 2;    // Group ID
    434            len += groupName[0] + 1;  // String + 1 for length
   \                     ??CrossCallReturnLabel_27:
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   2403         ADD       A,#0x3
   \   00001F   85..82       MOV       DPL,?XSP + 0
   \   000022   85..83       MOV       DPH,?XSP + 1
   \   000025   F0           MOVX      @DPTR,A
    435          
    436            buf = zcl_mem_alloc( len );
   \   000026   FE           MOV       R6,A
   \   000027                ; Setup parameters for call to function osal_mem_alloc
   \   000027   FA           MOV       R2,A
   \   000028   7B00         MOV       R3,#0x0
   \   00002A   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002D   8A..         MOV       ?V0,R2
   \   00002F   8B..         MOV       ?V1,R3
    437            if ( buf )
   \   000031   EA           MOV       A,R2
   \   000032   45..         ORL       A,?V1
   \   000034   7003         JNZ       $+5
   \   000036   02....       LJMP      ??zclGeneral_SendAddGroupRequest_0 & 0xFFFF
   \   000039   7415         MOV       A,#0x15
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   12....       LCALL     ?Subroutine21 & 0xFFFF
    438            {
    439              pBuf = buf;
    440              *pBuf++ = LO_UINT16( groupID );
   \                     ??CrossCallReturnLabel_41:
   \   000041   8A82         MOV       DPL,R2
   \   000043   8B83         MOV       DPH,R3
   \   000045   F0           MOVX      @DPTR,A
    441              *pBuf++ = HI_UINT16( groupID );
   \   000046   E9           MOV       A,R1
   \   000047   A3           INC       DPTR
   \   000048   12....       LCALL     ?Subroutine35 & 0xFFFF
    442              *pBuf++ = groupName[0]; // string length
   \                     ??CrossCallReturnLabel_62:
   \   00004B   12....       LCALL     ?Subroutine24 & 0xFFFF
    443              zcl_memcpy( pBuf, &(groupName[1]), groupName[0] );
   \                     ??CrossCallReturnLabel_48:
   \   00004E                ; Setup parameters for call to function osal_memcpy
   \   00004E   85..82       MOV       DPL,?V2
   \   000051   85..83       MOV       DPH,?V3
   \   000054   A3           INC       DPTR
   \   000055   A982         MOV       R1,DPL
   \   000057   AA83         MOV       R2,DPH
   \   000059   89..         MOV       ?V4,R1
   \   00005B   8A..         MOV       ?V5,R2
   \   00005D   75..00       MOV       ?V6,#0x0
   \   000060   78..         MOV       R0,#?V4
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000065   85..82       MOV       DPL,?V2
   \   000068   85..83       MOV       DPH,?V3
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   FC           MOV       R4,A
   \   00006D   7D00         MOV       R5,#0x0
   \   00006F   E5..         MOV       A,?V0
   \   000071   2403         ADD       A,#0x3
   \   000073   FA           MOV       R2,A
   \   000074   E4           CLR       A
   \   000075   35..         ADDC      A,?V1
   \   000077   FB           MOV       R3,A
   \   000078   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00007B   7403         MOV       A,#0x3
   \   00007D   12....       LCALL     ?DEALLOC_XSTACK8
    444          
    445              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    446                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    447                                        disableDefaultRsp, 0, seqNum, len, buf );
   \   000080                ; Setup parameters for call to function zcl_SendCommand
   \   000080   78..         MOV       R0,#?V0
   \   000082   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000085   8E..         MOV       ?V2,R6
   \   000087   75..00       MOV       ?V3,#0x0
   \   00008A   78..         MOV       R0,#?V2
   \   00008C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008F   741D         MOV       A,#0x1d
   \   000091   12....       LCALL     ?XSTACK_DISP0_8
   \   000094   E0           MOVX      A,@DPTR
   \   000095   F5..         MOV       ?V2,A
   \   000097   78..         MOV       R0,#?V2
   \   000099   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00009C   E4           CLR       A
   \   00009D   F5..         MOV       ?V2,A
   \   00009F   78..         MOV       R0,#?V2
   \   0000A1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A4   E5..         MOV       A,?V8
   \   0000A6   F5..         MOV       ?V2,A
   \   0000A8   78..         MOV       R0,#?V2
   \   0000AA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000AD   75..00       MOV       ?V2,#0x0
   \   0000B0   78..         MOV       R0,#?V2
   \   0000B2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B5   75..01       MOV       ?V2,#0x1
   \   0000B8   78..         MOV       R0,#?V2
   \   0000BA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000BD   E5..         MOV       A,?V9
   \   0000BF   F5..         MOV       ?V2,A
   \   0000C1   78..         MOV       R0,#?V2
   \   0000C3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C6   7C04         MOV       R4,#0x4
   \   0000C8   7D00         MOV       R5,#0x0
   \   0000CA   AA..         MOV       R2,?V10
   \   0000CC   AB..         MOV       R3,?V11
   \   0000CE   A9..         MOV       R1,?V7
   \   0000D0   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000D3   740B         MOV       A,#0xb
   \   0000D5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000D8   E9           MOV       A,R1
   \   0000D9   FE           MOV       R6,A
    448              zcl_mem_free( buf );
   \   0000DA                ; Setup parameters for call to function osal_mem_free
   \   0000DA   AA..         MOV       R2,?V0
   \   0000DC   AB..         MOV       R3,?V1
   \   0000DE   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000E1   8002         SJMP      ??zclGeneral_SendAddGroupRequest_1
    449            }
    450            else
    451              status = ZMemError;
   \                     ??zclGeneral_SendAddGroupRequest_0:
   \   0000E3   7E10         MOV       R6,#0x10
    452          
    453            return ( status );
   \                     ??zclGeneral_SendAddGroupRequest_1:
   \   0000E5   EE           MOV       A,R6
   \   0000E6   F9           MOV       R1,A
   \   0000E7   7401         MOV       A,#0x1
   \   0000E9                REQUIRE ?Subroutine2
   \   0000E9                ; // Fall through to label ?Subroutine2
    454          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine39_0
   \   000003                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   7F0C         MOV       R7,#0xc
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function osal_memcpy
   \   000001   85..82       MOV       DPL,?V2
   \   000004   85..83       MOV       DPH,?V3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V3,A
   \   000007   85..82       MOV       DPL,?V2
   \   00000A   F583         MOV       DPH,A
   \   00000C   22           RET
    455          
    456          /*********************************************************************
    457           * @fn      zclGeneral_SendGroupGetMembershipRequest
    458           *
    459           * @brief   Send a Get Group Membership (Resposne) Command to a device
    460           *
    461           * @param   srcEP - Sending Apps endpoint
    462           * @param   dstAddr - where to send the request
    463           * @param   cmd - one of the following:
    464           *                COMMAND_GROUP_GET_MEMBERSHIP
    465           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    466           * @param   groupID - pointer to the group structure
    467           * @param   groupName - pointer to Group Name.  This is a Zigbee
    468           *          string data type, so the first byte is the length of the
    469           *          name (in bytes), then the name.
    470           *
    471           * @return  ZStatus_t
    472           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    473          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupGetMembershipRequest:
    474                                                              uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    475                                                              uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    476          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V6,R2
   \   000009   8B..         MOV       ?V7,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
    477            uint8 *buf;
    478            uint8 *pBuf;
    479            uint8 len = 0;
   \   00000F   7800         MOV       R0,#0x0
    480            uint8 i;
    481            ZStatus_t status;
    482          
    483            if ( rspCmd )
   \   000011   6002         JZ        ??zclGeneral_SendGroupGetMembershipRequest_0
    484              len++;  // Capacity
   \   000013   7801         MOV       R0,#0x1
   \                     ??zclGeneral_SendGroupGetMembershipRequest_0:
   \   000015   7416         MOV       A,#0x16
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F5..         MOV       ?V3,A
    485          
    486            len++;  // Group Count
    487            len += sizeof ( uint16 ) * grpCnt;  // Group List
   \   00001D   C3           CLR       C
   \   00001E   33           RLC       A
   \   00001F   04           INC       A
   \   000020   28           ADD       A,R0
    488          
    489            buf = zcl_mem_alloc( len );
   \   000021   F5..         MOV       ?V4,A
   \   000023   75..00       MOV       ?V5,#0x0
   \   000026                ; Setup parameters for call to function osal_mem_alloc
   \   000026   FA           MOV       R2,A
   \   000027   AB..         MOV       R3,?V5
   \   000029   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002C   8A..         MOV       ?V0,R2
   \   00002E   8B..         MOV       ?V1,R3
    490            if ( buf )
   \   000030   EA           MOV       A,R2
   \   000031   45..         ORL       A,?V1
   \   000033   7003         JNZ       $+5
   \   000035   02....       LJMP      ??zclGeneral_SendGroupGetMembershipRequest_1 & 0xFFFF
    491            {
    492              pBuf = buf;
   \   000038   A8..         MOV       R0,?V0
   \   00003A   A9..         MOV       R1,?V1
    493              if ( rspCmd )
   \   00003C   EF           MOV       A,R7
   \   00003D   600D         JZ        ??zclGeneral_SendGroupGetMembershipRequest_2
    494                *pBuf++ = capacity;
   \   00003F   7415         MOV       A,#0x15
   \   000041   12....       LCALL     ?XSTACK_DISP0_8
   \   000044   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000047   A3           INC       DPTR
   \   000048   A882         MOV       R0,DPL
   \   00004A   A983         MOV       R1,DPH
    495          
    496              *pBuf++ = grpCnt;
   \                     ??zclGeneral_SendGroupGetMembershipRequest_2:
   \   00004C   8882         MOV       DPL,R0
   \   00004E   8983         MOV       DPH,R1
   \   000050   E5..         MOV       A,?V3
   \   000052   F0           MOVX      @DPTR,A
   \   000053   A3           INC       DPTR
   \   000054   A882         MOV       R0,DPL
   \   000056   A983         MOV       R1,DPH
    497              for ( i = 0; i < grpCnt; i++ )
   \   000058   7C00         MOV       R4,#0x0
   \   00005A   7417         MOV       A,#0x17
   \   00005C   12....       LCALL     ?XSTACK_DISP0_8
   \   00005F   12....       LCALL     ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000062   8031         SJMP      ??zclGeneral_SendGroupGetMembershipRequest_3
    498              {
    499                *pBuf++ = LO_UINT16( grpList[i] );
   \                     ??zclGeneral_SendGroupGetMembershipRequest_4:
   \   000064   EC           MOV       A,R4
   \   000065   25E0         ADD       A,0xE0 /* A   */
   \   000067   F5..         MOV       ?V8,A
   \   000069   E4           CLR       A
   \   00006A   33           RLC       A
   \   00006B   F5..         MOV       ?V9,A
   \   00006D   EA           MOV       A,R2
   \   00006E   25..         ADD       A,?V8
   \   000070   F5..         MOV       ?V8,A
   \   000072   EB           MOV       A,R3
   \   000073   35..         ADDC      A,?V9
   \   000075   F5..         MOV       ?V9,A
   \   000077   85..82       MOV       DPL,?V8
   \   00007A   F583         MOV       DPH,A
   \   00007C   12....       LCALL     ?Subroutine22 & 0xFFFF
    500                *pBuf++ = HI_UINT16( grpList[i] );
   \                     ??CrossCallReturnLabel_44:
   \   00007F   85..82       MOV       DPL,?V8
   \   000082   85..83       MOV       DPH,?V9
   \   000085   A3           INC       DPTR
   \   000086   E0           MOVX      A,@DPTR
   \   000087   8882         MOV       DPL,R0
   \   000089   8983         MOV       DPH,R1
   \   00008B   A3           INC       DPTR
   \   00008C   F0           MOVX      @DPTR,A
   \   00008D   E8           MOV       A,R0
   \   00008E   2402         ADD       A,#0x2
   \   000090   F8           MOV       R0,A
   \   000091   5001         JNC       ??zclGeneral_SendGroupGetMembershipRequest_5
   \   000093   09           INC       R1
    501              }
   \                     ??zclGeneral_SendGroupGetMembershipRequest_5:
   \   000094   0C           INC       R4
   \                     ??zclGeneral_SendGroupGetMembershipRequest_3:
   \   000095   EC           MOV       A,R4
   \   000096   C3           CLR       C
   \   000097   95..         SUBB      A,?V3
   \   000099   40C9         JC        ??zclGeneral_SendGroupGetMembershipRequest_4
    502          
    503              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    504                                        cmd, TRUE, direction,
    505                                        disableDefaultRsp, 0, seqNum, len, buf );
   \   00009B                ; Setup parameters for call to function zcl_SendCommand
   \   00009B   78..         MOV       R0,#?V0
   \   00009D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A0   78..         MOV       R0,#?V4
   \   0000A2   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A5   741E         MOV       A,#0x1e
   \   0000A7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AA   E0           MOVX      A,@DPTR
   \   0000AB   F5..         MOV       ?V3,A
   \   0000AD   78..         MOV       R0,#?V3
   \   0000AF   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B2   E4           CLR       A
   \   0000B3   F5..         MOV       ?V4,A
   \   0000B5   78..         MOV       R0,#?V4
   \   0000B7   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BA   7420         MOV       A,#0x20
   \   0000BC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BF   E0           MOVX      A,@DPTR
   \   0000C0   F5..         MOV       ?V3,A
   \   0000C2   78..         MOV       R0,#?V3
   \   0000C4   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C7   741C         MOV       A,#0x1c
   \   0000C9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CC   E0           MOVX      A,@DPTR
   \   0000CD   F5..         MOV       ?V3,A
   \   0000CF   78..         MOV       R0,#?V3
   \   0000D1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D4   75..01       MOV       ?V3,#0x1
   \   0000D7   78..         MOV       R0,#?V3
   \   0000D9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000DC   EE           MOV       A,R6
   \   0000DD   F5..         MOV       ?V3,A
   \   0000DF   78..         MOV       R0,#?V3
   \   0000E1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E4   7C04         MOV       R4,#0x4
   \   0000E6   7D00         MOV       R5,#0x0
   \   0000E8   AA..         MOV       R2,?V6
   \   0000EA   AB..         MOV       R3,?V7
   \   0000EC   A9..         MOV       R1,?V2
   \   0000EE   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000F1   740B         MOV       A,#0xb
   \   0000F3   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000F6   E9           MOV       A,R1
   \   0000F7   F5..         MOV       ?V3,A
    506              zcl_mem_free( buf );
   \   0000F9                ; Setup parameters for call to function osal_mem_free
   \   0000F9   AA..         MOV       R2,?V0
   \   0000FB   AB..         MOV       R3,?V1
   \   0000FD   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000100   8003         SJMP      ??zclGeneral_SendGroupGetMembershipRequest_6
    507            }
    508            else
    509              status = ZMemError;
   \                     ??zclGeneral_SendGroupGetMembershipRequest_1:
   \   000102   75..10       MOV       ?V3,#0x10
    510          
    511            return ( status );
   \                     ??zclGeneral_SendGroupGetMembershipRequest_6:
   \   000105   A9..         MOV       R1,?V3
   \   000107   02....       LJMP      ??Subroutine39_0 & 0xFFFF
    512          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   F0           MOVX      @DPTR,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine45_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET
    513          
    514          /*********************************************************************
    515           * @fn      zclGeneral_SendGroupResponse
    516           *
    517           * @brief   Send Group Response (not Group View Response)
    518           *
    519           * @param   srcEP - Sending application's endpoint
    520           * @param   dstAddr - where you want the message to go
    521           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    522           * @param   status - group command status
    523           * @param   groupID - what group
    524           *
    525           * @return  ZStatus_t
    526           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    527          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupResponse:
    528                                                  uint8 cmd, uint8 status, uint16 groupID,
    529                                                  uint8 disableDefaultRsp, uint8 seqNum )
    530          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
   \   00000D   FF           MOV       R7,A
    531            uint8 buf[3];
    532          
    533            buf[0] = status;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   ED           MOV       A,R5
   \   000015   F0           MOVX      @DPTR,A
   \   000016   740F         MOV       A,#0xf
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ?Subroutine31 & 0xFFFF
    534            buf[1] = LO_UINT16( groupID );
   \                     ??CrossCallReturnLabel_54:
   \   00001E   7401         MOV       A,#0x1
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   E8           MOV       A,R0
   \   000024   F0           MOVX      @DPTR,A
    535            buf[2] = HI_UINT16( groupID );
   \   000025   7402         MOV       A,#0x2
   \   000027   12....       LCALL     ?XSTACK_DISP0_8
   \   00002A   12....       LCALL     ?Subroutine25 & 0xFFFF
    536          
    537            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    538                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    539                                    disableDefaultRsp, 0, seqNum, 3, buf );
   \                     ??CrossCallReturnLabel_66:
   \   00002D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000030   75..03       MOV       ?V2,#0x3
   \   000033   75..00       MOV       ?V3,#0x0
   \   000036   78..         MOV       R0,#?V2
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   7416         MOV       A,#0x16
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000046   E4           CLR       A
   \   000047   F5..         MOV       ?V2,A
   \   000049   78..         MOV       R0,#?V2
   \   00004B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004E   7418         MOV       A,#0x18
   \   000050   12....       LCALL     ?XSTACK_DISP0_8
   \   000053   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000056   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000059   75..01       MOV       ?V1,#0x1
   \   00005C   78..         MOV       R0,#?V1
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000061   78..         MOV       R0,#?V1
   \   000063   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000066   EF           MOV       A,R7
   \   000067   F5..         MOV       ?V1,A
   \   000069   78..         MOV       R0,#?V1
   \   00006B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006E   7C04         MOV       R4,#0x4
   \   000070                REQUIRE ?Subroutine4
   \   000070                ; // Fall through to label ?Subroutine4
    540          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7D00         MOV       R5,#0x0
   \   000002   EE           MOV       A,R6
   \   000003   F9           MOV       R1,A
   \   000004   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000007   740B         MOV       A,#0xb
   \   000009   12....       LCALL     ?DEALLOC_XSTACK8
   \   00000C   7403         MOV       A,#0x3
   \   00000E   02....       LJMP      ??Subroutine41_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   22           RET
    541          
    542          /*********************************************************************
    543           * @fn      zclGeneral_SendGroupViewResponse
    544           *
    545           * @brief   Call to send Group Response Command
    546           *
    547           * @param   srcEP - Sending application's endpoint
    548           * @param   dstAddr - where you want the message to go
    549           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    550           * @param   status - group command status
    551           * @param   grp - group info
    552           *
    553           * @return  ZStatus_t
    554           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    555          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendGroupViewResponse:
    556                                                      uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    557          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V8,R1
   \   000007   8A..         MOV       ?V12,R2
   \   000009   8B..         MOV       ?V13,R3
   \   00000B   8C..         MOV       ?V7,R4
   \   00000D   8D..         MOV       ?V9,R5
    558            uint8 *buf;
    559            uint8 len;
    560            ZStatus_t stat;
    561          
    562            len = 1 + 2 + 1; // Status + Group ID + name length
   \   00000F   7804         MOV       R0,#0x4
   \   000011   7416         MOV       A,#0x16
   \   000013   12....       LCALL     ?XSTACK_DISP0_8
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F5..         MOV       ?V4,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F5..         MOV       ?V5,A
    563          
    564            if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   E5..         MOV       A,?V4
   \   00001F   2402         ADD       A,#0x2
   \   000021   F5..         MOV       ?V2,A
   \   000023   E4           CLR       A
   \   000024   35..         ADDC      A,?V5
   \   000026   F5..         MOV       ?V3,A
   \   000028   EC           MOV       A,R4
   \   000029   7009         JNZ       ??zclGeneral_SendGroupViewResponse_0
    565            {
    566              len += grp->name[0];  // String length
   \   00002B   85..82       MOV       DPL,?V2
   \   00002E   85..83       MOV       DPH,?V3
   \   000031   E0           MOVX      A,@DPTR
   \   000032   28           ADD       A,R0
   \   000033   F8           MOV       R0,A
    567            }
    568          
    569            buf = zcl_mem_alloc( len );
   \                     ??zclGeneral_SendGroupViewResponse_0:
   \   000034   E8           MOV       A,R0
   \   000035   FE           MOV       R6,A
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   FA           MOV       R2,A
   \   000037   7B00         MOV       R3,#0x0
   \   000039   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003C   8A..         MOV       ?V0,R2
   \   00003E   8B..         MOV       ?V1,R3
    570            if ( buf )
   \   000040   EA           MOV       A,R2
   \   000041   45..         ORL       A,?V1
   \   000043   7003         JNZ       $+5
   \   000045   02....       LJMP      ??zclGeneral_SendGroupViewResponse_1 & 0xFFFF
    571            {
    572              buf[0] = status;
   \   000048   8A82         MOV       DPL,R2
   \   00004A   8B83         MOV       DPH,R3
   \   00004C   E5..         MOV       A,?V7
   \   00004E   F0           MOVX      @DPTR,A
    573              buf[1] = LO_UINT16( grp->ID );
   \   00004F   85..82       MOV       DPL,?V4
   \   000052   85..83       MOV       DPH,?V5
   \   000055   E0           MOVX      A,@DPTR
   \   000056   8A82         MOV       DPL,R2
   \   000058   8B83         MOV       DPH,R3
   \   00005A   A3           INC       DPTR
   \   00005B   F0           MOVX      @DPTR,A
    574              buf[2] = HI_UINT16( grp->ID );
   \   00005C   85..82       MOV       DPL,?V4
   \   00005F   85..83       MOV       DPH,?V5
   \   000062   A3           INC       DPTR
   \   000063   12....       LCALL     ?Subroutine24 & 0xFFFF
    575          
    576              if ( status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_49:
   \   000066   EA           MOV       A,R2
   \   000067   2403         ADD       A,#0x3
   \   000069   F8           MOV       R0,A
   \   00006A   E4           CLR       A
   \   00006B   35..         ADDC      A,?V1
   \   00006D   F9           MOV       R1,A
   \   00006E   E5..         MOV       A,?V7
   \   000070   703F         JNZ       ??zclGeneral_SendGroupViewResponse_2
    577              {
    578                buf[3] = grp->name[0]; // string length
   \   000072   85..82       MOV       DPL,?V2
   \   000075   85..83       MOV       DPH,?V3
   \   000078   12....       LCALL     ?Subroutine22 & 0xFFFF
    579                zcl_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
   \                     ??CrossCallReturnLabel_45:
   \   00007B                ; Setup parameters for call to function osal_memcpy
   \   00007B   85..82       MOV       DPL,?V4
   \   00007E   85..83       MOV       DPH,?V5
   \   000081   A3           INC       DPTR
   \   000082   A3           INC       DPTR
   \   000083   A3           INC       DPTR
   \   000084   A982         MOV       R1,DPL
   \   000086   AA83         MOV       R2,DPH
   \   000088   89..         MOV       ?V4,R1
   \   00008A   8A..         MOV       ?V5,R2
   \   00008C   75..00       MOV       ?V6,#0x0
   \   00008F   78..         MOV       R0,#?V4
   \   000091   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000094   85..82       MOV       DPL,?V2
   \   000097   85..83       MOV       DPH,?V3
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   FC           MOV       R4,A
   \   00009C   7D00         MOV       R5,#0x0
   \   00009E   E5..         MOV       A,?V0
   \   0000A0   2404         ADD       A,#0x4
   \   0000A2   FA           MOV       R2,A
   \   0000A3   E4           CLR       A
   \   0000A4   35..         ADDC      A,?V1
   \   0000A6   FB           MOV       R3,A
   \   0000A7   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000AA   7403         MOV       A,#0x3
   \   0000AC   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000AF   8006         SJMP      ??zclGeneral_SendGroupViewResponse_3
    580              }
    581              else //ZCL_STATUS_NOT_FOUND
    582              {
    583                buf[3] = 0;
   \                     ??zclGeneral_SendGroupViewResponse_2:
   \   0000B1   8882         MOV       DPL,R0
   \   0000B3   8983         MOV       DPH,R1
   \   0000B5   E4           CLR       A
   \   0000B6   F0           MOVX      @DPTR,A
    584              }
    585          
    586              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    587                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    588                                      disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zclGeneral_SendGroupViewResponse_3:
   \   0000B7                ; Setup parameters for call to function zcl_SendCommand
   \   0000B7   78..         MOV       R0,#?V0
   \   0000B9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BC   8E..         MOV       ?V2,R6
   \   0000BE   75..00       MOV       ?V3,#0x0
   \   0000C1   78..         MOV       R0,#?V2
   \   0000C3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C6   741C         MOV       A,#0x1c
   \   0000C8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CB   E0           MOVX      A,@DPTR
   \   0000CC   F5..         MOV       ?V2,A
   \   0000CE   78..         MOV       R0,#?V2
   \   0000D0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D3   E4           CLR       A
   \   0000D4   F5..         MOV       ?V2,A
   \   0000D6   78..         MOV       R0,#?V2
   \   0000D8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000DB   E5..         MOV       A,?V9
   \   0000DD   F5..         MOV       ?V2,A
   \   0000DF   78..         MOV       R0,#?V2
   \   0000E1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E4   75..01       MOV       ?V2,#0x1
   \   0000E7   78..         MOV       R0,#?V2
   \   0000E9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000EC   78..         MOV       R0,#?V2
   \   0000EE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000F1   78..         MOV       R0,#?V2
   \   0000F3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000F6   7C04         MOV       R4,#0x4
   \   0000F8   7D00         MOV       R5,#0x0
   \   0000FA   AA..         MOV       R2,?V12
   \   0000FC   AB..         MOV       R3,?V13
   \   0000FE   A9..         MOV       R1,?V8
   \   000100   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000103   740B         MOV       A,#0xb
   \   000105   12....       LCALL     ?DEALLOC_XSTACK8
   \   000108   E9           MOV       A,R1
   \   000109   FE           MOV       R6,A
    589              zcl_mem_free( buf );
   \   00010A                ; Setup parameters for call to function osal_mem_free
   \   00010A   AA..         MOV       R2,?V0
   \   00010C   AB..         MOV       R3,?V1
   \   00010E   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000111   8002         SJMP      ??zclGeneral_SendGroupViewResponse_4
    590            }
    591            else
    592            {
    593              stat = ZMemError;
   \                     ??zclGeneral_SendGroupViewResponse_1:
   \   000113   7E10         MOV       R6,#0x10
    594            }
    595          
    596            return ( stat );
   \                     ??zclGeneral_SendGroupViewResponse_4:
   \   000115   EE           MOV       A,R6
   \   000116   F9           MOV       R1,A
   \   000117                REQUIRE ?Subroutine3
   \   000117                ; // Fall through to label ?Subroutine3
    597          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F0E         MOV       R7,#0xe
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    598          #endif // ZCL_GROUPS
    599          
    600          #ifdef ZCL_SCENES
    601          /*********************************************************************
    602           * @fn      zclGeneral_SendAddSceneRequest
    603           *
    604           * @brief   Send the (Enhanced) Add Scene Request to a device. You can
    605           *           also use the appropriate macro.
    606           *
    607           * @param   srcEP - Sending Apps endpoint
    608           * @param   dstAddr - where to send the request
    609           * @param   scene - pointer to the scene structure
    610           * @param  cmd - COMMAND_SCENE_ADD or COMMAND_SCENE_ENHANCED_ADD
    611           * @param   disableDefaultRsp - whether to disable the Default Response command
    612           * @param   seqNum - sequence number
    613           *
    614           * @return  ZStatus_t
    615           */
    616          ZStatus_t zclGeneral_SendAddSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    617                                                    uint8 cmd, zclGeneral_Scene_t *scene,
    618                                                    uint8 disableDefaultRsp, uint8 seqNum )
    619          {
    620            uint8 *buf;
    621            uint8 *pBuf;
    622            uint8 len;
    623            ZStatus_t status;
    624          
    625            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    626            len += scene->name[0] + 1; // String + 1 for length
    627          
    628            // Add something for the extension field length
    629            len += scene->extLen;
    630          
    631            buf = zcl_mem_alloc( len );
    632            if ( buf )
    633            {
    634              pBuf = buf;
    635              *pBuf++ = LO_UINT16( scene->groupID );
    636              *pBuf++ = HI_UINT16( scene->groupID );
    637              *pBuf++ = scene->ID;
    638              *pBuf++ = LO_UINT16( scene->transTime );
    639              *pBuf++ = HI_UINT16( scene->transTime );
    640              *pBuf++ = scene->name[0]; // string length
    641              zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    642              pBuf += scene->name[0]; // move pass name
    643          
    644              // Add the extension fields
    645              if ( scene->extLen > 0 )
    646                zcl_memcpy( pBuf, scene->extField, scene->extLen );
    647          
    648              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    649                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    650                                        disableDefaultRsp, 0, seqNum, len, buf );
    651              zcl_mem_free( buf );
    652            }
    653            else
    654              status = ZMemError;
    655          
    656            return ( status );
    657          }
    658          
    659          /*********************************************************************
    660           * @fn      zclGeneral_SendSceneRequest
    661           *
    662           * @brief   Send a Scene Request to a device.  You can also use the
    663           *          appropriate macro.
    664           *
    665           * @param   srcEP - Sending Apps endpoint
    666           * @param   dstAddr - where to send the request
    667           * @param   cmd - one of the following:
    668           *              COMMAND_SCENE_VIEW
    669           *              COMMAND_SCENE_REMOVE
    670           *              COMMAND_SCENE_REMOVE_ALL
    671           *              COMMAND_SCENE_STORE
    672           *              COMMAND_SCENE_RECALL
    673           *              COMMAND_SCENE_GET_MEMBERSHIP
    674           *              COMMAND_SCENE_ENHANCED_VIEW
    675           * @param   groupID - group ID
    676           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    677           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    678           * @param   disableDefaultRsp - whether to disable the Default Response command
    679           * @param   seqNum - sequence number
    680           * @return  ZStatus_t
    681           */
    682          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    683                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    684                                                 uint8 disableDefaultRsp, uint8 seqNum )
    685          {
    686            uint8 buf[3];
    687            uint8 len = 2;
    688          
    689            buf[0] = LO_UINT16( groupID );
    690            buf[1] = HI_UINT16( groupID );
    691          
    692            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    693            {
    694              buf[2] = sceneID;
    695              len++;
    696            }
    697          
    698            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    699                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    700                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    701          }
    702          
    703          /*********************************************************************
    704           * @fn      zclGeneral_SendSceneResponse
    705           *
    706           * @brief   Send Group Response (not Group View Response)
    707           *
    708           * @param   srcEP - Sending application's endpoint
    709           * @param   dstAddr - where you want the message to go
    710           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    711           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    712           * @param   status - scene command status
    713           * @param   groupID - what group
    714           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    715           *
    716           * @return  ZStatus_t
    717           */
    718          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    719                                                  uint8 cmd, uint8 status, uint16 groupID,
    720                                                  uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    721          {
    722            uint8 buf[4];
    723            uint8 len = 1 + 2; // Status + Group ID
    724          
    725            buf[0] = status;
    726            buf[1] = LO_UINT16( groupID );
    727            buf[2] = HI_UINT16( groupID );
    728          
    729            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    730            {
    731              buf[3] = sceneID;
    732              len++;
    733            }
    734          
    735            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    736                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    737                                    disableDefaultRsp, 0, seqNum, len, buf );
    738          }
    739          
    740          /*********************************************************************
    741           * @fn      zclGeneral_SendSceneViewResponse
    742           *
    743           * @brief   Call to send Scene (Enahced) View Response Command. You can
    744           *           also use the appropriate macro.
    745           *
    746           * @param   srcEP - Sending application's endpoint
    747           * @param   dstAddr - where you want the message to go
    748           * @param   cmd - either COMMAND_SCENE_VIEW_RSP or COMMAND_SCENE_ENHANCED_VIEW_RSP
    749           * @param   status - scene command status
    750           * @param   scene - scene info
    751           *
    752           * @return  ZStatus_t
    753           */
    754          ZStatus_t zclGeneral_SendSceneViewRsp( uint8 srcEP, afAddrType_t *dstAddr,
    755                                                 uint8 cmd, uint8 status, zclGeneral_Scene_t *scene,
    756                                                 uint8 disableDefaultRsp, uint8 seqNum )
    757          {
    758            uint8 *buf;
    759            uint8 *pBuf;
    760            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    761            ZStatus_t stat;
    762          
    763            if ( status == ZCL_STATUS_SUCCESS )
    764            {
    765              len += 2; // Transition Time
    766              len += scene->name[0] + 1; // string + 1 for length
    767          
    768              // Add something for the extension field length
    769              len += scene->extLen;
    770            }
    771          
    772            buf = zcl_mem_alloc( len );
    773            if ( buf )
    774            {
    775              pBuf = buf;
    776              *pBuf++ = status;
    777              *pBuf++ = LO_UINT16( scene->groupID );
    778              *pBuf++ = HI_UINT16( scene->groupID );
    779              *pBuf++ = scene->ID;
    780              if ( status == ZCL_STATUS_SUCCESS )
    781              {
    782                uint16 transTime = scene->transTime;
    783                if ( cmd == COMMAND_SCENE_ENHANCED_VIEW_RSP )
    784                {
    785                  // Transition time is in 1/10s
    786                  transTime *= 10;
    787                  transTime += scene->transTime100ms;
    788                }
    789          
    790                *pBuf++ = LO_UINT16( transTime );
    791                *pBuf++ = HI_UINT16( transTime );
    792                *pBuf++ = scene->name[0]; // string length
    793                if ( scene->name[0] != 0 )
    794                {
    795                  zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    796                  pBuf += scene->name[0]; // move pass name
    797                }
    798          
    799                // Add the extension fields
    800                if ( scene->extLen > 0 )
    801                  zcl_memcpy( pBuf, scene->extField, scene->extLen );
    802              }
    803          
    804              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    805                                      cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    806                                      disableDefaultRsp, 0, seqNum, len, buf );
    807              zcl_mem_free( buf );
    808            }
    809            else
    810              stat = ZMemError;
    811          
    812            return ( stat );
    813          }
    814          
    815          /*********************************************************************
    816           * @fn      zclGeneral_SendSceneGetMembershipResponse
    817           *
    818           * @brief   Call to send Scene Get Membership Response Command
    819           *
    820           * @param   srcEP - Sending application's endpoint
    821           * @param   dstAddr - where you want the message to go
    822           * @param   status - scene command status
    823           * @param   capacity - remaining capacity of the scene table
    824           * @param   sceneCnt - number of scenes in the scene list
    825           * @param   sceneList - list of scene IDs
    826           * @param   groupID - group ID that scene belongs to
    827           * @param   seqNum - sequence number
    828           *
    829           * @return  ZStatus_t
    830           */
    831          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    832                                                               uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    833                                                               uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    834          {
    835            uint8 *buf;
    836            uint8 *pBuf;
    837            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    838            uint8 i;
    839            ZStatus_t stat;
    840          
    841            if ( status == ZCL_STATUS_SUCCESS )
    842            {
    843              len++; // Scene Count
    844              len += sceneCnt; // Scene List (Scene ID is a single octet)
    845            }
    846          
    847            buf = zcl_mem_alloc( len );
    848            if ( buf )
    849            {
    850              pBuf = buf;
    851              *pBuf++ = status;
    852              *pBuf++ = capacity;
    853              *pBuf++ = LO_UINT16( groupID );
    854              *pBuf++ = HI_UINT16( groupID );
    855              if ( status == ZCL_STATUS_SUCCESS )
    856              {
    857                *pBuf++ = sceneCnt;
    858                for ( i = 0; i < sceneCnt; i++ )
    859                  *pBuf++ = sceneList[i];
    860              }
    861          
    862              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    863                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    864                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    865              zcl_mem_free( buf );
    866            }
    867            else
    868              stat = ZMemError;
    869          
    870            return ( stat );
    871          }
    872          
    873          #ifdef ZCL_LIGHT_LINK_ENHANCE
    874          /*********************************************************************
    875           * @fn      zclGeneral_SendSceneCopy
    876           *
    877           * @brief   Send Scene Copy Request to a device
    878           *
    879           * @param   srcEP - sending application's endpoint
    880           * @param   dstAddr - where to send the request
    881           * @param   mode - how scene copy is to proceed
    882           * @param   groupIDFrom - group from which scene to be copied
    883           * @param   sceneIDFrom - scene from which scene to be copied
    884           * @param   groupIDTo - group to which scene to be copied
    885           * @param   sceneIDTo - scene to which scene to be copied
    886           * @param   disableDefaultRsp - disable Default Response command
    887           * @param   seqNum - the identification number for the transaction
    888           *
    889           * @return  ZStatus_t
    890           */
    891          ZStatus_t zclGeneral_SendSceneCopy( uint8 srcEP, afAddrType_t *dstAddr,
    892                                              uint8 mode, uint16 groupIDFrom, uint8 sceneIDFrom,
    893                                              uint16 groupIDTo, uint8 sceneIDTo,
    894                                              uint8 disableDefaultRsp, uint8 seqNum )
    895          {
    896            uint8 buf[7];
    897          
    898            buf[0] = mode;
    899            buf[1] = LO_UINT16( groupIDFrom );
    900            buf[2] = HI_UINT16( groupIDFrom );
    901            buf[3] = sceneIDFrom;
    902            buf[4] = LO_UINT16( groupIDTo );
    903            buf[5] = HI_UINT16( groupIDTo );
    904            buf[6] = sceneIDTo;
    905          
    906            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    907                                      COMMAND_SCENE_COPY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    908                                      disableDefaultRsp, 0, seqNum, 7, buf ) );
    909          }
    910          
    911          /*********************************************************************
    912           * @fn      zclGeneral_SendSceneCopyResponse
    913           *
    914           * @brief   Send Scene Copy Response to a device
    915           *
    916           * @param   srcEP - sending application's endpoint
    917           * @param   dstAddr - where to send the request
    918           * @param   status - status of copy scene attemp
    919           * @param   groupIDFrom - group from which scene was copied
    920           * @param   sceneIDFrom - scene from which scene was copied
    921           * @param   disableDefaultRsp - disable Default Response command
    922           * @param   seqNum - the identification number for the transaction
    923           *
    924           * @return  ZStatus_t
    925           */
    926          ZStatus_t zclGeneral_SendSceneCopyResponse( uint8 srcEP, afAddrType_t *dstAddr,
    927                                                      uint8 status, uint16 groupIDFrom, uint8 sceneIDFrom,
    928                                                      uint8 disableDefaultRsp, uint8 seqNum )
    929          {
    930            uint8 buf[4];
    931          
    932            buf[0] = status;
    933            buf[1] = LO_UINT16( groupIDFrom );
    934            buf[2] = HI_UINT16( groupIDFrom );
    935            buf[3] = sceneIDFrom;
    936          
    937            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    938                                      COMMAND_SCENE_COPY_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    939                                      disableDefaultRsp, 0, seqNum, 4, buf ) );
    940          }
    941          #endif // ZCL_LIGHT_LINK_ENHANCE
    942          #endif // ZCL_SCENES
    943          
    944          #ifdef ZCL_ON_OFF
    945          #ifdef ZCL_LIGHT_LINK_ENHANCE
    946          /*********************************************************************
    947           * @fn      zclGeneral_SendOnOff_CmdOffWithEffect
    948           *
    949           * @brief   Call to send out an Off with Effect Command.
    950           *
    951           * @param   srcEP - Sending application's endpoint
    952           * @param   dstAddr - where you want the message to go
    953           * @param   effectId - fading effect to use when switching light off
    954           * @param   effectVariant - which variant of effect to be triggered
    955           * @param   disableDefaultRsp - whether to disable the Default Response command
    956           * @param   seqNum - sequence number
    957           *
    958           * @return  ZStatus_t
    959           */
    960          ZStatus_t zclGeneral_SendOnOff_CmdOffWithEffect( uint8 srcEP, afAddrType_t *dstAddr,
    961                                                           uint8 effectId, uint8 effectVariant,
    962                                                           uint8 disableDefaultRsp, uint8 seqNum )
    963          {
    964            uint8 buf[2];
    965          
    966            buf[0] = effectId;
    967            buf[1] = effectVariant;
    968          
    969            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
    970                                    COMMAND_OFF_WITH_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    971                                    disableDefaultRsp, 0, seqNum, 2, buf );
    972          }
    973          
    974          /*********************************************************************
    975           * @fn      zclGeneral_SendOnOff_CmdOnWithTimedOff
    976           *
    977           * @brief   Call to send out an On with Timed Off Command.
    978           *
    979           * @param   srcEP - Sending application's endpoint
    980           * @param   dstAddr - where you want the message to go
    981           * @param   onOffCtrl - how the lamp is to be operated
    982           * @param   onTime - the length of time (in 1/10ths second) that the lamp is to remain on, before automatically turning off
    983           * @param   offWaitTime - the length of time (in 1/10ths second) that the lamp shall remain off, and guarded to prevent an on command turning the light back on.
    984           * @param   disableDefaultRsp - whether to disable the Default Response command
    985           * @param   seqNum - sequence number
    986           *
    987           * @return  ZStatus_t
    988           */
    989          ZStatus_t zclGeneral_SendOnOff_CmdOnWithTimedOff ( uint8 srcEP, afAddrType_t *dstAddr,
    990                                                             zclOnOffCtrl_t onOffCtrl, uint16 onTime, uint16 offWaitTime,
    991                                                             uint8 disableDefaultRsp, uint8 seqNum )
    992          {
    993            uint8 buf[5];
    994          
    995            buf[0] = onOffCtrl.byte;
    996            buf[1] = LO_UINT16( onTime );
    997            buf[2] = HI_UINT16( onTime );
    998            buf[3] = LO_UINT16( offWaitTime );
    999            buf[4] = HI_UINT16( offWaitTime );
   1000          
   1001            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
   1002                                    COMMAND_ON_WITH_TIMED_OFF, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1003                                    disableDefaultRsp, 0, seqNum, 5, buf );
   1004          }
   1005          #endif // ZCL_LIGHT_LINK_ENHANCE
   1006          #endif // ZCL_ON_OFF
   1007          
   1008          #ifdef ZCL_LEVEL_CTRL
   1009          /*********************************************************************
   1010           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
   1011           *
   1012           * @brief   Call to send out a Level Control Request. You can also use
   1013           *          the appropriate macro.
   1014           *
   1015           * @param   srcEP - Sending application's endpoint
   1016           * @param   dstAddr - where you want the message to go
   1017           * @param   cmd - one of the following:
   1018           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
   1019           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
   1020           * @param   level - what level to move to
   1021           * @param   transitionTime - how long to take to get to the level (in seconds)
   1022           *
   1023           * @return  ZStatus_t
   1024           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1025          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendLevelControlMoveToLevelRequest:
   1026                                                                   uint8 cmd, uint8 level, uint16 transTime,
   1027                                                                   uint8 disableDefaultRsp, uint8 seqNum )
   1028          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
   \   00000D   FF           MOV       R7,A
   1029            uint8 buf[3];
   1030          
   1031            buf[0] = level;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   ED           MOV       A,R5
   \   000015   F0           MOVX      @DPTR,A
   \   000016   740F         MOV       A,#0xf
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ?Subroutine31 & 0xFFFF
   1032            buf[1] = LO_UINT16( transTime );
   \                     ??CrossCallReturnLabel_55:
   \   00001E   7401         MOV       A,#0x1
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   E8           MOV       A,R0
   \   000024   F0           MOVX      @DPTR,A
   1033            buf[2] = HI_UINT16( transTime );
   \   000025   7402         MOV       A,#0x2
   \   000027   12....       LCALL     ?XSTACK_DISP0_8
   \   00002A   12....       LCALL     ?Subroutine25 & 0xFFFF
   1034          
   1035            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1036                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1037                                    disableDefaultRsp, 0, seqNum, 3, buf );
   \                     ??CrossCallReturnLabel_67:
   \   00002D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000030   75..03       MOV       ?V2,#0x3
   \   000033   75..00       MOV       ?V3,#0x0
   \   000036   78..         MOV       R0,#?V2
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   7416         MOV       A,#0x16
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000046   E4           CLR       A
   \   000047   F5..         MOV       ?V2,A
   \   000049   78..         MOV       R0,#?V2
   \   00004B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004E   7418         MOV       A,#0x18
   \   000050   12....       LCALL     ?XSTACK_DISP0_8
   \   000053   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000056   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000059   75..00       MOV       ?V1,#0x0
   \   00005C   78..         MOV       R0,#?V1
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000061   75..01       MOV       ?V1,#0x1
   \   000064   78..         MOV       R0,#?V1
   \   000066   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000069   EF           MOV       A,R7
   \   00006A   F5..         MOV       ?V1,A
   \   00006C   78..         MOV       R0,#?V1
   \   00006E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000071   7C08         MOV       R4,#0x8
   \   000073   02....       LJMP      ?Subroutine4 & 0xFFFF
   1038          }
   1039          
   1040          /*********************************************************************
   1041           * @fn      zclGeneral_SendLevelControlMoveRequest
   1042           *
   1043           * @brief   Call to send out a Level Control Request. You can also use
   1044           *          the appropriate macro.
   1045           *
   1046           * @param   srcEP - Sending application's endpoint
   1047           * @param   dstAddr - where you want the message to go
   1048           * @param   cmd - one of the following:
   1049           *              COMMAND_LEVEL_MOVE or
   1050           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
   1051           * @param   moveMode - LEVEL_MOVE_UP or
   1052           *                     LEVEL_MOVE_DOWN
   1053           * @param   rate - number of steps to take per second
   1054           *
   1055           * @return  ZStatus_t
   1056           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1057          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendLevelControlMoveRequest:
   1058                                                            uint8 cmd, uint8 moveMode, uint8 rate,
   1059                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1060          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
   \   00000D   FF           MOV       R7,A
   1061            uint8 buf[2];
   1062          
   1063            buf[0] = moveMode;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   ED           MOV       A,R5
   \   000015   F0           MOVX      @DPTR,A
   1064            buf[1] = rate;
   \   000016   740E         MOV       A,#0xe
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   C0E0         PUSH      A
   \   00001E   7401         MOV       A,#0x1
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   D0E0         POP       A
   \   000025   12....       LCALL     ??Subroutine38_0 & 0xFFFF
   1065          
   1066            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1067                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1068                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_71:
   \   000028   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002B   75..02       MOV       ?V2,#0x2
   \   00002E   75..00       MOV       ?V3,#0x0
   \   000031   78..         MOV       R0,#?V2
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000036   7414         MOV       A,#0x14
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000041   E4           CLR       A
   \   000042   F5..         MOV       ?V2,A
   \   000044   78..         MOV       R0,#?V2
   \   000046   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000049   7416         MOV       A,#0x16
   \   00004B   12....       LCALL     ?XSTACK_DISP0_8
   \   00004E   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000051   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000054   75..00       MOV       ?V1,#0x0
   \   000057   78..         MOV       R0,#?V1
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005C   75..01       MOV       ?V1,#0x1
   \   00005F   78..         MOV       R0,#?V1
   \   000061   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000064   EF           MOV       A,R7
   \   000065   F5..         MOV       ?V1,A
   \   000067   78..         MOV       R0,#?V1
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006C   7C08         MOV       R4,#0x8
   \   00006E   02....       LJMP      ?Subroutine0 & 0xFFFF
   1069          }
   1070          
   1071          /*********************************************************************
   1072           * @fn      zclGeneral_SendLevelControlStepRequest
   1073           *
   1074           * @brief   Call to send out a Level Control Request. You can also use
   1075           *          the appropriate macro.
   1076           *
   1077           * @param   srcEP - Sending application's endpoint
   1078           * @param   dstAddr - where you want the message to go
   1079           * @param   cmd - one of the following:
   1080           *              COMMAND_LEVEL_STEP
   1081           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
   1082           * @param   stepMode - LEVEL_STEP_UP or
   1083           *                     LEVEL_STEP_DOWN
   1084           * @param   amount - number of levels to step
   1085           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
   1086           *
   1087           * @return  ZStatus_t
   1088           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1089          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendLevelControlStepRequest:
   1090                                                            uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
   1091                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1092          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
   \   00000D   FF           MOV       R7,A
   1093            uint8 buf[4];
   1094          
   1095            buf[0] = stepMode;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   ED           MOV       A,R5
   \   000015   F0           MOVX      @DPTR,A
   1096            buf[1] = stepSize;
   \   000016   7410         MOV       A,#0x10
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   C0E0         PUSH      A
   \   00001E   7401         MOV       A,#0x1
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   D0E0         POP       A
   \   000025   F0           MOVX      @DPTR,A
   \   000026   7411         MOV       A,#0x11
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   12....       LCALL     ?Subroutine31 & 0xFFFF
   1097            buf[2] = LO_UINT16( transTime );
   \                     ??CrossCallReturnLabel_56:
   \   00002E   7402         MOV       A,#0x2
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   E8           MOV       A,R0
   \   000034   F0           MOVX      @DPTR,A
   1098            buf[3] = HI_UINT16( transTime );
   \   000035   7403         MOV       A,#0x3
   \   000037   12....       LCALL     ?XSTACK_DISP0_8
   \   00003A   12....       LCALL     ?Subroutine25 & 0xFFFF
   1099          
   1100            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1101                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1102                                    disableDefaultRsp, 0, seqNum, 4, buf );
   \                     ??CrossCallReturnLabel_68:
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000040   75..04       MOV       ?V2,#0x4
   \   000043   75..00       MOV       ?V3,#0x0
   \   000046   78..         MOV       R0,#?V2
   \   000048   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004B   7418         MOV       A,#0x18
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000053   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000056   E4           CLR       A
   \   000057   F5..         MOV       ?V2,A
   \   000059   78..         MOV       R0,#?V2
   \   00005B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005E   741A         MOV       A,#0x1a
   \   000060   12....       LCALL     ?XSTACK_DISP0_8
   \   000063   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000066   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000069   75..00       MOV       ?V1,#0x0
   \   00006C   78..         MOV       R0,#?V1
   \   00006E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000071   75..01       MOV       ?V1,#0x1
   \   000074   78..         MOV       R0,#?V1
   \   000076   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000079   EF           MOV       A,R7
   \   00007A   F5..         MOV       ?V1,A
   \   00007C   78..         MOV       R0,#?V1
   \   00007E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000081   7C08         MOV       R4,#0x8
   \   000083   7D00         MOV       R5,#0x0
   \   000085   EE           MOV       A,R6
   \   000086   F9           MOV       R1,A
   \   000087   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00008A   740B         MOV       A,#0xb
   \   00008C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00008F   7404         MOV       A,#0x4
   \   000091   02....       LJMP      ??Subroutine41_0 & 0xFFFF
   1103          }
   1104          
   1105          /*********************************************************************
   1106           * @fn      zclGeneral_SendLevelControlStepRequest
   1107           *
   1108           * @brief   Call to send out a Level Control Request. You can also use
   1109           *          the appropriate macro.
   1110           *
   1111           * @param   srcEP - Sending application's endpoint
   1112           * @param   dstAddr - where you want the message to go
   1113           * @param   cmd - one of the following:
   1114           *              COMMAND_LEVEL_STOP
   1115           *              COMMAND_LEVEL_STOP_WITH_ON_OFF
   1116           *
   1117           * @return  ZStatus_t
   1118           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1119          ZStatus_t zclGeneral_SendLevelControlStopRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   \                     zclGeneral_SendLevelControlStopRequest:
   1120                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1121          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EC           MOV       A,R4
   \   000006   FF           MOV       R7,A
   1122            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1123                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1124                                    disableDefaultRsp, 0, seqNum, 0, NULL );
   \   000007                ; Setup parameters for call to function zcl_SendCommand
   \   000007   E4           CLR       A
   \   000008   F5..         MOV       ?V2,A
   \   00000A   F5..         MOV       ?V3,A
   \   00000C   78..         MOV       R0,#?V2
   \   00000E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000011   78..         MOV       R0,#?V2
   \   000013   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000016   7410         MOV       A,#0x10
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00001E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000021   78..         MOV       R0,#?V2
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000026   ED           MOV       A,R5
   \   000027   F5..         MOV       ?V1,A
   \   000029   78..         MOV       R0,#?V1
   \   00002B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00002E   75..00       MOV       ?V1,#0x0
   \   000031   78..         MOV       R0,#?V1
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000036   75..01       MOV       ?V1,#0x1
   \   000039   78..         MOV       R0,#?V1
   \   00003B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00003E   EF           MOV       A,R7
   \   00003F   F5..         MOV       ?V1,A
   \   000041   78..         MOV       R0,#?V1
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000046   7C08         MOV       R4,#0x8
   \   000048   7D00         MOV       R5,#0x0
   \   00004A   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00004D   740B         MOV       A,#0xb
   \   00004F   02....       LJMP      ??Subroutine41_0 & 0xFFFF
   1125          }
   1126          #endif // ZCL_LEVEL_CTRL
   1127          
   1128          #ifdef ZCL_ALARMS
   1129          /*********************************************************************
   1130           * @fn      zclGeneral_SendAlarm
   1131           *
   1132           * @brief   Call to send out an Alarm Request Command
   1133           *
   1134           * @param   srcEP - Sending application's endpoint
   1135           * @param   dstAddr - where you want the message to go
   1136           * @param   cmd - COMMAND_ALARMS_ALARM
   1137           * @param   alarmCode - code for the cause of the alarm
   1138           * @param   clusterID - cluster whose attribute generate the alarm
   1139           *
   1140           * @return  ZStatus_t
   1141           */
   1142          ZStatus_t zclGeneral_SendAlarm( uint8 srcEP, afAddrType_t *dstAddr,
   1143                                          uint8 alarmCode, uint16 clusterID,
   1144                                          uint8 disableDefaultRsp, uint8 seqNum )
   1145          {
   1146            uint8 buf[3];
   1147          
   1148            buf[0] = alarmCode;
   1149            buf[1] = LO_UINT16( clusterID );
   1150            buf[2] = HI_UINT16( clusterID );
   1151          
   1152            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1153                                    COMMAND_ALARMS_ALARM, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1154                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1155          }
   1156          
   1157          /*********************************************************************
   1158           * @fn      zclGeneral_SendAlarmReset
   1159           *
   1160           * @brief   Call to send out an Alarm Reset Command
   1161           *
   1162           * @param   srcEP - Sending application's endpoint
   1163           * @param   dstAddr - where you want the message to go
   1164           * @param   alarmCode - code for the cause of the alarm
   1165           * @param   clusterID - cluster whose attribute generate the alarm
   1166           *
   1167           * @return  ZStatus_t
   1168          */
   1169          ZStatus_t zclGeneral_SendAlarmReset( uint8 srcEP, afAddrType_t *dstAddr,
   1170                                               uint8 alarmCode, uint16 clusterID,
   1171                                               uint8 disableDefaultRsp, uint8 seqNum )
   1172          {
   1173            uint8 buf[3];
   1174          
   1175            buf[0] = alarmCode;
   1176            buf[1] = LO_UINT16( clusterID );
   1177            buf[2] = HI_UINT16( clusterID );
   1178          
   1179            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1180                                    COMMAND_ALARMS_RESET, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1181                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1182          }
   1183          
   1184          /*********************************************************************
   1185           * @fn      zclGeneral_SendAlarmGetResponse
   1186           *
   1187           * @brief   Call to send out an Alarm Get Response Command
   1188           *
   1189           * @param   srcEP - Sending application's endpoint
   1190           * @param   dstAddr - where you want the message to go
   1191           * @param   status - SUCCESS or NOT_FOUND
   1192           * @param   alarmCode - code for the cause of the alarm
   1193           * @param   clusterID - cluster whose attribute generate the alarm
   1194           * @param   timeStamp - time at which the alarm occured
   1195           *
   1196           * @return  ZStatus_t
   1197           */
   1198          ZStatus_t zclGeneral_SendAlarmGetResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1199                                                     uint8 status, uint8 alarmCode, uint16 clusterID,
   1200                                                     uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
   1201          {
   1202            uint8 buf[8];
   1203            uint8 len = 1; // Status
   1204          
   1205            buf[0] = status;
   1206            if ( status == ZCL_STATUS_SUCCESS )
   1207            {
   1208              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
   1209              buf[1] = alarmCode;
   1210              buf[2] = LO_UINT16( clusterID );
   1211              buf[3] = HI_UINT16( clusterID );
   1212              zcl_buffer_uint32( &buf[4], timeStamp );
   1213            }
   1214          
   1215            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1216                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1217                                    disableDefaultRsp, 0, seqNum, len, buf );
   1218          }
   1219          
   1220          #ifdef SE_UK_EXT
   1221          /*********************************************************************
   1222           * @fn      zclGeneral_SendAlarmGetEventLog
   1223           *
   1224           * @brief   Call to send out an Alarm Get Event Log Command
   1225           *
   1226           * @param   srcEP - Sending application's endpoint
   1227           * @param   dstAddr - where you want the message to go
   1228           * @param   pEventLog - pointer to Get Event Log Command
   1229           * @param   disableDefaultRsp - disable default response
   1230           * @param   seqNum - ZCL sequence number
   1231           *
   1232           * @return  ZStatus_t
   1233           */
   1234          ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1235                                                     zclGetEventLog_t *pEventLog,
   1236                                                     uint8 disableDefaultRsp, uint8 seqNum )
   1237          {
   1238            uint8 buf[10];
   1239          
   1240            buf[0] = pEventLog->logID;
   1241            zcl_buffer_uint32( &buf[1], pEventLog->startTime );
   1242            zcl_buffer_uint32( &buf[5], pEventLog->endTime );
   1243            buf[9] = pEventLog->numEvents;
   1244          
   1245            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1246                                    COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1247                                    disableDefaultRsp, 0, seqNum, 10, buf );
   1248          }
   1249          
   1250          /*********************************************************************
   1251           * @fn      zclGeneral_SendAlarmPublishEventLog
   1252           *
   1253           * @brief   Call to send out an Alarm Publish Event Log Command
   1254           *
   1255           * @param   srcEP - Sending application's endpoint
   1256           * @param   dstAddr - where you want the message to go
   1257           * @param   pEventLog - pointer to Publish Event Log Command
   1258           * @param   disableDefaultRsp - disable default response
   1259           * @param   seqNum - ZCL sequence number
   1260           *
   1261           * @return  ZStatus_t
   1262           */
   1263          ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1264                                                         zclPublishEventLog_t *pEventLog,
   1265                                                         uint8 disableDefaultRsp, uint8 seqNum )
   1266          {
   1267            uint8 *buf;
   1268            uint8 *pBuf;
   1269            uint8 bufLen;
   1270          
   1271            // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
   1272            bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
   1273          
   1274            buf = zcl_mem_alloc( bufLen );
   1275            if ( buf == NULL )
   1276            {
   1277              return (ZMemError);
   1278            }
   1279          
   1280            pBuf = buf;
   1281            *pBuf++ = pEventLog->logID;
   1282            *pBuf++ = pEventLog->cmdIndex;
   1283            *pBuf++ = pEventLog->totalCmds;
   1284          
   1285            for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
   1286            {
   1287              zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
   1288          
   1289              *pBuf++ = pLogs->eventId;
   1290              pBuf = zcl_buffer_uint32( pBuf, pLogs->eventTime );
   1291            }
   1292          
   1293            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1294                                    COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1295                                    disableDefaultRsp, 0, seqNum, bufLen, buf );
   1296          }
   1297          #endif // SE_UK_EXT
   1298          #endif // ZCL_ALARMS
   1299          
   1300          #ifdef ZCL_LOCATION
   1301          /*********************************************************************
   1302           * @fn      zclGeneral_SendLocationSetAbsolute
   1303           *
   1304           * @brief   Call to send out a Set Absolute Location Command
   1305           *
   1306           * @param   srcEP - Sending application's endpoint
   1307           * @param   dstAddr - where you want the message to go
   1308           * @param   absLoc - absolute location info
   1309           *
   1310           * @return  ZStatus_t
   1311           */
   1312          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
   1313                                                        zclLocationAbsolute_t *absLoc,
   1314                                                        uint8 disableDefaultRsp, uint8 seqNum )
   1315          {
   1316             uint8 buf[10]; // 5 fields (2 octects each)
   1317          
   1318             buf[0] = LO_UINT16( absLoc->coordinate1 );
   1319             buf[1] = HI_UINT16( absLoc->coordinate1 );
   1320             buf[2] = LO_UINT16( absLoc->coordinate2 );
   1321             buf[3] = HI_UINT16( absLoc->coordinate2 );
   1322             buf[4] = LO_UINT16( absLoc->coordinate3 );
   1323             buf[5] = HI_UINT16( absLoc->coordinate3 );
   1324             buf[6] = LO_UINT16( absLoc->power );
   1325             buf[7] = HI_UINT16( absLoc->power );
   1326             buf[8] = LO_UINT16( absLoc->pathLossExponent );
   1327             buf[9] = HI_UINT16( absLoc->pathLossExponent );
   1328          
   1329             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1330                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
   1331                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
   1332          }
   1333          
   1334          /*********************************************************************
   1335           * @fn      zclGeneral_SendLocationSetDevCfg
   1336           *
   1337           * @brief   Call to send out a Set Device Configuration Command
   1338           *
   1339           * @param   srcEP - Sending application's endpoint
   1340           * @param   dstAddr - where you want the message to go
   1341           * @param   devCfg - device configuration info
   1342           *
   1343           * @return  ZStatus_t
   1344           */
   1345          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1346                                                      zclLocationDevCfg_t *devCfg,
   1347                                                      uint8 disableDefaultRsp, uint8 seqNum )
   1348          {
   1349             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
   1350          
   1351             buf[0] = LO_UINT16( devCfg->power );
   1352             buf[1] = HI_UINT16( devCfg->power );
   1353             buf[2] = LO_UINT16( devCfg->pathLossExponent );
   1354             buf[3] = HI_UINT16( devCfg->pathLossExponent );
   1355             buf[4] = LO_UINT16( devCfg->calcPeriod );
   1356             buf[5] = HI_UINT16( devCfg->calcPeriod );
   1357             buf[6] = devCfg->numMeasurements;
   1358             buf[7] = LO_UINT16( devCfg->reportPeriod );
   1359             buf[8] = HI_UINT16( devCfg->reportPeriod );
   1360          
   1361             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1362                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
   1363                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
   1364          }
   1365          
   1366          /*********************************************************************
   1367           * @fn      zclGeneral_SendLocationGetDevCfg
   1368           *
   1369           * @brief   Call to send out a Get Device Configuration Command
   1370           *
   1371           * @param   srcEP - Sending application's endpoint
   1372           * @param   dstAddr - where you want the message to go
   1373           * @param   targetAddr - device for which location parameters are being requested
   1374           *
   1375           * @return  ZStatus_t
   1376           */
   1377          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1378                                                      uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1379          {
   1380            uint8 buf[8];
   1381          
   1382            zcl_memcpy( buf, targetAddr, 8 );
   1383          
   1384            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1385                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1386                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1387          }
   1388          
   1389          /*********************************************************************
   1390           * @fn      zclGeneral_SendLocationGetData
   1391           *
   1392           * @brief   Call to send out a Get Location Data Command
   1393           *
   1394           * @param   srcEP - Sending application's endpoint
   1395           * @param   dstAddr - where you want the message to go
   1396           * @param   locaData - location information and channel parameters that are requested.
   1397           *
   1398           * @return  ZStatus_t
   1399           */
   1400          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1401                                                    zclLocationGetData_t *locData,
   1402                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1403          {
   1404            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1405            uint8 *pBuf = buf;
   1406            uint8 len = 2; // bitmap + number responses
   1407          
   1408            *pBuf  = locData->absoluteOnly;
   1409            *pBuf |= locData->recalculate << 1;
   1410            *pBuf |= locData->brdcastIndicator << 2;
   1411            *pBuf |= locData->brdcastResponse << 3;
   1412            *pBuf |= locData->compactResponse << 4;
   1413            pBuf++;  // move past the bitmap field
   1414          
   1415            *pBuf++ = locData->numResponses;
   1416          
   1417            if ( locData->brdcastIndicator == 0 )
   1418            {
   1419              zcl_memcpy( pBuf, locData->targetAddr, 8 );
   1420              len += 8; // ieee addr
   1421            }
   1422          
   1423            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1424                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1425                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1426          }
   1427          
   1428          /*********************************************************************
   1429           * @fn      zclGeneral_SendLocationDevCfgResponse
   1430           *
   1431           * @brief   Call to send out a Device Configuration Response Command
   1432           *
   1433           * @param   srcEP - Sending application's endpoint
   1434           * @param   dstAddr - where you want the message to go
   1435           * @param   devCfg - device's location parameters that are requested
   1436           *
   1437           * @return  ZStatus_t
   1438           */
   1439          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1440                                                           zclLocationDevCfgRsp_t *devCfg,
   1441                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1442          {
   1443            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1444            uint8 len = 1; // Status
   1445          
   1446            buf[0] = devCfg->status;
   1447            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1448            {
   1449              buf[1] = LO_UINT16( devCfg->data.power );
   1450              buf[2] = HI_UINT16( devCfg->data.power );
   1451              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1452              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1453              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1454              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1455              buf[7] = devCfg->data.numMeasurements;
   1456              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1457              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1458              len += 9;
   1459            }
   1460          
   1461            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1462                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1463                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1464          }
   1465          
   1466          /*********************************************************************
   1467           * @fn      zclGeneral_SendLocationData
   1468           *
   1469           * @brief   Call to send out location data
   1470           *
   1471           * @param   srcEP - Sending application's endpoint
   1472           * @param   dstAddr - where you want the message to go
   1473           * @param   status - indicates whether response to request was successful or not
   1474           * @param   locData - location information and channel parameters being sent
   1475           *
   1476           * @return  ZStatus_t
   1477           */
   1478          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1479                                                 uint8 status, zclLocationData_t *locData,
   1480                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1481          {
   1482            uint8 buf[16];
   1483            uint8 *pBuf = buf;
   1484            uint8 len = 0;
   1485          
   1486            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1487            {
   1488              // Only response command includes a status field
   1489              *pBuf++ = status;
   1490              len++;
   1491            }
   1492          
   1493            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1494            {
   1495              // Notification or Response with successful status
   1496              *pBuf++ = locData->type;
   1497              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1498              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1499              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1500              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1501              len += 5;
   1502          
   1503              if ( locationType2D(locData->type) == 0 )
   1504              {
   1505                // 2D location doesn't have coordinate 3
   1506                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1507                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1508                len += 2;
   1509              }
   1510          
   1511              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1512              {
   1513                // Compact notification doesn't include these fields
   1514                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1515                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1516                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1517                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1518                len += 4;
   1519              }
   1520          
   1521              if ( locationTypeAbsolute(locData->type) == 0 )
   1522              {
   1523                // Absolute location doesn't include these fields
   1524                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1525                {
   1526                  // Compact notification doesn't include this field
   1527                  *pBuf++ = locData->calcLoc.locationMethod;
   1528                  len++;
   1529                }
   1530          
   1531                *pBuf++ = locData->calcLoc.qualityMeasure;
   1532                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1533                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1534                len += 3;
   1535              }
   1536            }
   1537          
   1538            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1539                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1540                                    disableDefaultRsp, 0, seqNum, len, buf );
   1541          }
   1542          #endif // ZCL_LOCATION
   1543          
   1544          /*********************************************************************
   1545           * @fn      zclGeneral_FindCallbacks
   1546           *
   1547           * @brief   Find the callbacks for an endpoint
   1548           *
   1549           * @param   endpoint - endpoint to find the application callbacks for
   1550           *
   1551           * @return  pointer to the callbacks
   1552           */
   1553          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1554          {
   1555            zclGenCBRec_t *pCBs;
   1556          
   1557            pCBs = zclGenCBs;
   1558            while ( pCBs )
   1559            {
   1560              if ( pCBs->endpoint == endpoint )
   1561                return ( pCBs->CBs );
   1562              pCBs = pCBs->next;
   1563            }
   1564            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1565          }
   1566          
   1567          /*********************************************************************
   1568           * @fn      zclGeneral_HdlIncoming
   1569           *
   1570           * @brief   Callback from ZCL to process incoming Commands specific
   1571           *          to this cluster library or Profile commands for attributes
   1572           *          that aren't in the attribute list
   1573           *
   1574           *
   1575           * @param   pInMsg - pointer to the incoming message
   1576           *
   1577           * @return  ZStatus_t
   1578           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1579          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1580          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1581            ZStatus_t stat = ZSuccess;
   1582          
   1583          #if defined ( INTER_PAN )
   1584            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1585              return ( stat ); // Cluster not supported thru Inter-PAN
   1586          #endif
   1587            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   5407         ANL       A,#0x7
   \   00000D   6401         XRL       A,#0x1
   \   00000F   7007         JNZ       ??zclGeneral_HdlIncoming_0
   1588            {
   1589              // Is this a manufacturer specific command?
   1590              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   1591              {
   1592                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   000011                ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
   \   000011   12....       LCALL     `??zclGeneral_HdlInSpecificCommands::?relay`; Banked call to: zclGeneral_HdlInSpecificCommands
   \   000014   E9           MOV       A,R1
   \   000015   F9           MOV       R1,A
   \   000016   8002         SJMP      ??zclGeneral_HdlIncoming_1
   1593              }
   1594              else
   1595              {
   1596                // We don't support any manufacturer specific command.
   1597                stat = ZFailure;
   1598              }
   1599            }
   1600            else
   1601            {
   1602              // Handle all the normal (Read, Write...) commands -- should never get here
   1603              stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_0:
   \   000018   7901         MOV       R1,#0x1
   1604            }
   1605            return ( stat );
   \                     ??zclGeneral_HdlIncoming_1:
   \   00001A   D083         POP       DPH
   \   00001C   D082         POP       DPL
   \   00001E   02....       LJMP      ?BRET
   1606          }
   1607          
   1608          /*********************************************************************
   1609           * @fn      zclGeneral_HdlInSpecificCommands
   1610           *
   1611           * @brief   Callback from ZCL to process incoming Commands specific
   1612           *          to this cluster library
   1613          
   1614           * @param   pInMsg - pointer to the incoming message
   1615           *
   1616           * @return  ZStatus_t
   1617           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1618          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1619          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1620            ZStatus_t stat;
   1621            zclGeneral_AppCallbacks_t *pCBs;
   1622          
   1623            // make sure endpoint exists
   1624            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000005   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000008   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   00000B   FC           MOV       R4,A
   \   00000C   90....       MOV       DPTR,#zclGenCBs
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   00000F   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000012   6061         JZ        ??zclGeneral_HdlInSpecificCommands_1
   \   000014   8882         MOV       DPL,R0
   \   000016   8983         MOV       DPH,R1
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   6C           XRL       A,R4
   \   00001C   8882         MOV       DPL,R0
   \   00001E   8983         MOV       DPH,R1
   \   000020   70ED         JNZ       ??zclGeneral_HdlInSpecificCommands_0
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   12....       LCALL     ??Subroutine47_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000028   FD           MOV       R5,A
   1625            if ( pCBs == NULL )
   \   000029   EC           MOV       A,R4
   \   00002A   4D           ORL       A,R5
   \   00002B   6048         JZ        ??zclGeneral_HdlInSpecificCommands_1
   1626              return ( ZFailure );
   1627          
   1628            switch ( pInMsg->msg->clusterId )
   \   00002D   8E82         MOV       DPL,R6
   \   00002F   8F83         MOV       DPH,R7
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   F5..         MOV       ?V0,A
   \   000038   A3           INC       DPTR
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   F5..         MOV       ?V1,A
   \   00003C   78..         MOV       R0,#?V0
   \   00003E   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
   \   000041   0000         DW        0
   \   000043   08           DB        8
   \   000044   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   000046   ....         DW        ??zclGeneral_HdlInSpecificCommands_3
   \   000048   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   00004A   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   00004C   ....         DW        ??zclGeneral_HdlInSpecificCommands_4
   \   00004E   ....         DW        ??zclGeneral_HdlInSpecificCommands_5
   \   000050   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   000052   ....         DW        ??zclGeneral_HdlInSpecificCommands_6
   \   000054   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   000056   ....         DW        ??zclGeneral_HdlInSpecificCommands_7
   1629            {
   1630          #ifdef ZCL_BASIC
   1631              case ZCL_CLUSTER_ID_GEN_BASIC:
   1632                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   000058   8A82         MOV       DPL,R2
   \   00005A   8B83         MOV       DPH,R3
   \   00005C   A3           INC       DPTR
   \   00005D   A3           INC       DPTR
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   5408         ANL       A,#0x8
   \   000061   7022         JNZ       ??zclGeneral_HdlInSpecificCommands_8
   \   000063   8A82         MOV       DPL,R2
   \   000065   8B83         MOV       DPH,R3
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   E0           MOVX      A,@DPTR
   \   00006F   6008         JZ        ??zclGeneral_HdlInSpecificCommands_9
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   000071   7E01         MOV       R6,#0x1
   \   000073   806E         SJMP      ??zclGeneral_HdlInSpecificCommands_10
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   000075   7901         MOV       R1,#0x1
   \   000077   806C         SJMP      ??zclGeneral_HdlInSpecificCommands_11
   \                     ??zclGeneral_HdlInSpecificCommands_9:
   \   000079   8C82         MOV       DPL,R4
   \   00007B   8D83         MOV       DPH,R5
   \   00007D   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000080   6003         JZ        ??zclGeneral_HdlInSpecificCommands_8
   \   000082                ; Setup parameters for indirect call
   \   000082   12....       LCALL     ?CALL_IND
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   000085   7E00         MOV       R6,#0x0
   \   000087   805A         SJMP      ??zclGeneral_HdlInSpecificCommands_10
   1633                break;
   1634          #endif // ZCL_BASIC
   1635          
   1636          #ifdef ZCL_IDENTIFY
   1637              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1638                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   000089                ; Setup parameters for call to function zclGeneral_ProcessInIdentity
   \   000089   12....       LCALL     `??zclGeneral_ProcessInIdentity::?relay`; Banked call to: zclGeneral_ProcessInIdentity
   \   00008C   8053         SJMP      ??zclGeneral_HdlInSpecificCommands_12
   1639                break;
   1640          #endif // ZCL_IDENTIFY
   1641          
   1642          #ifdef ZCL_GROUPS
   1643              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1644                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   00008E   8A82         MOV       DPL,R2
   \   000090   8B83         MOV       DPH,R3
   \   000092   A3           INC       DPTR
   \   000093   A3           INC       DPTR
   \   000094   E0           MOVX      A,@DPTR
   \   000095   5408         ANL       A,#0x8
   \   000097   7005         JNZ       ??zclGeneral_HdlInSpecificCommands_13
   1645                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   \   000099                ; Setup parameters for call to function zclGeneral_ProcessInGroupsServer
   \   000099   12....       LCALL     `??zclGeneral_ProcessInGroupsServer::?relay`; Banked call to: zclGeneral_ProcessInGroupsServer
   \   00009C   8043         SJMP      ??zclGeneral_HdlInSpecificCommands_12
   1646                else
   1647                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_13:
   \   00009E                ; Setup parameters for call to function zclGeneral_ProcessInGroupsClient
   \   00009E   12....       LCALL     `??zclGeneral_ProcessInGroupsClient::?relay`; Banked call to: zclGeneral_ProcessInGroupsClient
   \   0000A1   803E         SJMP      ??zclGeneral_HdlInSpecificCommands_12
   1648                break;
   1649          #endif // ZCL_GROUPS
   1650          
   1651          #ifdef ZCL_SCENES
   1652              case ZCL_CLUSTER_ID_GEN_SCENES:
   1653                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1654                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1655                else
   1656                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1657                break;
   1658          #endif // ZCL_SCENES
   1659          
   1660          #ifdef ZCL_ON_OFF
   1661              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1662                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   0000A3   7F00         MOV       R7,#0x0
   \   0000A5   8A82         MOV       DPL,R2
   \   0000A7   8B83         MOV       DPH,R3
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   5408         ANL       A,#0x8
   \   0000AE   702B         JNZ       ??zclGeneral_HdlInSpecificCommands_14
   \   0000B0   8A82         MOV       DPL,R2
   \   0000B2   8B83         MOV       DPH,R3
   \   0000B4   A3           INC       DPTR
   \   0000B5   A3           INC       DPTR
   \   0000B6   A3           INC       DPTR
   \   0000B7   A3           INC       DPTR
   \   0000B8   A3           INC       DPTR
   \   0000B9   A3           INC       DPTR
   \   0000BA   A3           INC       DPTR
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   FA           MOV       R2,A
   \   0000BD   6006         JZ        ??zclGeneral_HdlInSpecificCommands_15
   \   0000BF   14           DEC       A
   \   0000C0   6003         JZ        ??zclGeneral_HdlInSpecificCommands_15
   \   0000C2   14           DEC       A
   \   0000C3   7014         JNZ       ??zclGeneral_HdlInSpecificCommands_16
   \                     ??zclGeneral_HdlInSpecificCommands_15:
   \   0000C5   8C82         MOV       DPL,R4
   \   0000C7   8D83         MOV       DPH,R5
   \   0000C9   A3           INC       DPTR
   \   0000CA   A3           INC       DPTR
   \   0000CB   A3           INC       DPTR
   \   0000CC   A3           INC       DPTR
   \   0000CD   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000D0   6009         JZ        ??zclGeneral_HdlInSpecificCommands_14
   \   0000D2                ; Setup parameters for indirect call
   \   0000D2   EA           MOV       A,R2
   \   0000D3   F9           MOV       R1,A
   \   0000D4   12....       LCALL     ?CALL_IND
   \   0000D7   8002         SJMP      ??zclGeneral_HdlInSpecificCommands_14
   \                     ??zclGeneral_HdlInSpecificCommands_16:
   \   0000D9   7F01         MOV       R7,#0x1
   1663                break;
   1664          #endif // ZCL_ON_OFF
   1665          
   1666          #ifdef ZCL_LEVEL_CTRL
   1667              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1668                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1669                break;
   1670          #endif // ZCL_LEVEL_CTRL
   1671          
   1672          #ifdef ZCL_ALARMS
   1673              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1674                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1675                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1676                else
   1677                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1678                break;
   1679          #endif // ZCL_ALARMS
   1680          
   1681          #ifdef ZCL_LOCATION
   1682              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1683                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1684                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1685                else
   1686                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1687                break;
   1688          #endif // ZCL_LOCATION
   1689          
   1690              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1691              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1692              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1693              case ZCL_CLUSTER_ID_GEN_TIME:
   1694              default:
   1695                stat = ZFailure;
   1696                break;
   1697            }
   \                     ??zclGeneral_HdlInSpecificCommands_14:
   \   0000DB   EF           MOV       A,R7
   \   0000DC   8004         SJMP      ??zclGeneral_HdlInSpecificCommands_17
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   0000DE                ; Setup parameters for call to function zclGeneral_ProcessInLevelControl
   \   0000DE   12....       LCALL     `??zclGeneral_ProcessInLevelControl::?relay`; Banked call to: zclGeneral_ProcessInLevelControl
   \                     ??zclGeneral_HdlInSpecificCommands_12:
   \   0000E1   E9           MOV       A,R1
   \                     ??zclGeneral_HdlInSpecificCommands_17:
   \   0000E2   FE           MOV       R6,A
   1698          
   1699            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_10:
   \   0000E3   EE           MOV       A,R6
   \   0000E4   F9           MOV       R1,A
   \                     ??zclGeneral_HdlInSpecificCommands_11:
   \   0000E5   02....       LJMP      ??Subroutine53_0 & 0xFFFF
   1700          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000007   FE           MOV       R6,A
   \   000008   E9           MOV       A,R1
   \   000009   FF           MOV       R7,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   EE           MOV       A,R6
   \   000001   2414         ADD       A,#0x14
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   3F           ADDC      A,R7
   \   000007   F583         MOV       DPH,A
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000003   8882         MOV       DPL,R0
   \   000005   8983         MOV       DPH,R1
   \   000007   E582         MOV       A,DPL
   \   000009   4583         ORL       A,DPH
   \   00000B   22           RET
   1701          
   1702          #ifdef ZCL_BASIC
   1703          /*********************************************************************
   1704           * @fn      zclGeneral_ProcessInBasic
   1705           *
   1706           * @brief   Process in the received Basic Command.
   1707           *
   1708           * @param   pInMsg - pointer to the incoming message
   1709           *
   1710           * @return  ZStatus_t
   1711           */
   1712          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1713                                                      zclGeneral_AppCallbacks_t *pCBs )
   1714          {
   1715            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1716            {
   1717              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1718                return ( ZFailure );   // Error ignore the command
   1719          
   1720              if ( pCBs->pfnBasicReset )
   1721                pCBs->pfnBasicReset();
   1722            }
   1723            // no Client command
   1724          
   1725            return ( ZSuccess );
   1726          }
   1727          #endif // ZCL_BASIC
   1728          
   1729          #ifdef ZCL_IDENTIFY
   1730          /*********************************************************************
   1731           * @fn      zclGeneral_ProcessInIdentity
   1732           *
   1733           * @brief   Process in the received Identity Command.
   1734           *
   1735           * @param   pInMsg - pointer to the incoming message
   1736           *
   1737           * @return  ZStatus_t
   1738           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1739          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInIdentity:
   1740                                                         zclGeneral_AppCallbacks_t *pCBs )
   1741          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV       A,#-0x6
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   1742            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F8           MOV       R0,A
   \   00001B   8A82         MOV       DPL,R2
   \   00001D   8B83         MOV       DPH,R3
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   5408         ANL       A,#0x8
   \   000024   6003         JZ        $+5
   \   000026   02....       LJMP      ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
   1743            {
   1744              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   \   000029   E8           MOV       A,R0
   \   00002A   7021         JNZ       ??zclGeneral_ProcessInIdentity_1
   1745              {
   1746                uint16 identifyTime;
   1747                
   1748                identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1749                
   1750                bdb_ZclIdentifyCmdInd( identifyTime, pInMsg->msg->endPoint);
   \   00002C   8A82         MOV       DPL,R2
   \   00002E   8B83         MOV       DPH,R3
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   12....       LCALL     ?Subroutine21 & 0xFFFF
   1751              }
   \                     ??CrossCallReturnLabel_42:
   \   00003B   FA           MOV       R2,A
   \   00003C   E9           MOV       A,R1
   \   00003D   FB           MOV       R3,A
   \   00003E                ; Setup parameters for call to function bdb_ZclIdentifyCmdInd
   \   00003E   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000041   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000044   FB           MOV       R3,A
   \   000045   EC           MOV       A,R4
   \   000046   FA           MOV       R2,A
   \   000047   12....       LCALL     `??bdb_ZclIdentifyCmdInd::?relay`; Banked call to: bdb_ZclIdentifyCmdInd
   \   00004A   02....       LJMP      ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
   1752              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_QUERY )
   \                     ??zclGeneral_ProcessInIdentity_1:
   \   00004D   7401         MOV       A,#0x1
   \   00004F   68           XRL       A,R0
   \   000050   6003         JZ        $+5
   \   000052   02....       LJMP      ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
   1753              {
   1754                uint16 identifyTime = 0;
   \   000055   85..82       MOV       DPL,?XSP + 0
   \   000058   85..83       MOV       DPH,?XSP + 1
   \   00005B   E4           CLR       A
   \   00005C   F0           MOVX      @DPTR,A
   \   00005D   A3           INC       DPTR
   \   00005E   F0           MOVX      @DPTR,A
   1755          
   1756                // Retrieve Identify Time
   1757                zcl_ReadAttrData( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   1758                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   \   00005F   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000062                ; Setup parameters for call to function zcl_ReadAttrData
   \   000062   E4           CLR       A
   \   000063   F5..         MOV       ?V2,A
   \   000065   F5..         MOV       ?V3,A
   \   000067   78..         MOV       R0,#?V2
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006C   7402         MOV       A,#0x2
   \   00006E   12....       LCALL     ?XSTACK_DISP100_8
   \   000071   88..         MOV       ?V2,R0
   \   000073   89..         MOV       ?V3,R1
   \   000075   78..         MOV       R0,#?V2
   \   000077   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007A   7C00         MOV       R4,#0x0
   \   00007C   7D00         MOV       R5,#0x0
   \   00007E   8E82         MOV       DPL,R6
   \   000080   8F83         MOV       DPH,R7
   \   000082   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000085   12....       LCALL     ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000088   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   00008B   7404         MOV       A,#0x4
   \   00008D   12....       LCALL     ?DEALLOC_XSTACK8
   1759          
   1760                // Is device identifying itself?
   1761                if ( identifyTime > 0 )
   \   000090   85..82       MOV       DPL,?XSP + 0
   \   000093   85..83       MOV       DPH,?XSP + 1
   \   000096   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000099   6070         JZ        ??zclGeneral_ProcessInIdentity_2
   1762                {
   1763                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1764                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   \   00009B   85..82       MOV       DPL,?V0
   \   00009E   85..83       MOV       DPH,?V1
   \   0000A1   E0           MOVX      A,@DPTR
   \   0000A2   FE           MOV       R6,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   FF           MOV       R7,A
   \   0000A6                ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
   \   0000A6   85..82       MOV       DPL,?V0
   \   0000A9   85..83       MOV       DPH,?V1
   \   0000AC   A3           INC       DPTR
   \   0000AD   A3           INC       DPTR
   \   0000AE   A3           INC       DPTR
   \   0000AF   A3           INC       DPTR
   \   0000B0   A3           INC       DPTR
   \   0000B1   A3           INC       DPTR
   \   0000B2   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0000B5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B8   75..01       MOV       ?V0,#0x1
   \   0000BB   78..         MOV       R0,#?V0
   \   0000BD   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C0   7402         MOV       A,#0x2
   \   0000C2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C5   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   0000C8   12....       LCALL     `??zclGeneral_SendIdentifyQueryResponse::?relay`; Banked call to: zclGeneral_SendIdentifyQueryResponse
   \   0000CB   7402         MOV       A,#0x2
   \   0000CD   12....       LCALL     ?DEALLOC_XSTACK8
   1765                  return ( ZCL_STATUS_CMD_HAS_RSP );
   \   0000D0   79FF         MOV       R1,#-0x1
   \   0000D2   8039         SJMP      ??zclGeneral_ProcessInIdentity_4
   1766                }
   1767              }
   1768          
   1769          #ifdef ZCL_LIGHT_LINK_ENHANCE
   1770              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_TRIGGER_EFFECT )
   1771              {
   1772                if ( pCBs->pfnIdentifyTriggerEffect )
   1773                {
   1774                  zclIdentifyTriggerEffect_t cmd;
   1775          
   1776                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1777                  cmd.effectId = pInMsg->pData[0];
   1778                  cmd.effectVariant = pInMsg->pData[1];
   1779          
   1780                  pCBs->pfnIdentifyTriggerEffect( &cmd );
   1781                }
   1782              }
   1783          #endif //ZCL_LIGHT_LINK_ENHANCE
   1784              else
   1785              {
   1786                return ( ZFailure );   // Error ignore the command
   1787              }
   1788            }
   1789            else // Client Command
   1790            {
   1791              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   \                     ??zclGeneral_ProcessInIdentity_0:
   \   0000D4   E8           MOV       A,R0
   \   0000D5   6004         JZ        ??zclGeneral_ProcessInIdentity_5
   1792                return ( ZFailure );   // Error ignore the command
   \                     ??zclGeneral_ProcessInIdentity_3:
   \   0000D7   7901         MOV       R1,#0x1
   \   0000D9   8032         SJMP      ??zclGeneral_ProcessInIdentity_4
   1793          
   1794              zclIdentifyQueryRsp_t rsp;
   1795              
   1796              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \                     ??zclGeneral_ProcessInIdentity_5:
   \   0000DB   8A82         MOV       DPL,R2
   \   0000DD   8B83         MOV       DPH,R3
   \   0000DF   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0000E2   7402         MOV       A,#0x2
   \   0000E4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E7   12....       LCALL     ?Subroutine27 & 0xFFFF
   1797              rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \                     ??CrossCallReturnLabel_74:
   \   0000EA   8A82         MOV       DPL,R2
   \   0000EC   8B83         MOV       DPH,R3
   \   0000EE   A3           INC       DPTR
   \   0000EF   A3           INC       DPTR
   \   0000F0   A3           INC       DPTR
   \   0000F1   A3           INC       DPTR
   \   0000F2   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   0000F5   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   0000F8   F9           MOV       R1,A
   \   0000F9   EC           MOV       A,R4
   \   0000FA   F8           MOV       R0,A
   \   0000FB   7404         MOV       A,#0x4
   \   0000FD   12....       LCALL     ?XSTACK_DISP0_8
   \   000100   12....       LCALL     ?Subroutine27 & 0xFFFF
   1798              
   1799              bdb_ZclIdentifyQueryCmdInd( &rsp );
   \                     ??CrossCallReturnLabel_75:
   \   000103                ; Setup parameters for call to function bdb_ZclIdentifyQueryCmdInd
   \   000103   7402         MOV       A,#0x2
   \   000105   12....       LCALL     ?XSTACK_DISP101_8
   \   000108   12....       LCALL     `??bdb_ZclIdentifyQueryCmdInd::?relay`; Banked call to: bdb_ZclIdentifyQueryCmdInd
   1800            }
   1801            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInIdentity_2:
   \   00010B   7900         MOV       R1,#0x0
   \                     ??zclGeneral_ProcessInIdentity_4:
   \   00010D   7406         MOV       A,#0x6
   \   00010F   02....       LJMP      ??Subroutine41_0 & 0xFFFF
   1802          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine44_0:
   \   000000   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004                REQUIRE ??Subroutine45_0
   \   000004                ; // Fall through to label ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine46_0:
   \   000000   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000003   49           ORL       A,R1
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL     ??Subroutine47_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000003   FD           MOV       R5,A
   \   000004   EE           MOV       A,R6
   \   000005   2406         ADD       A,#0x6
   \   000007   FA           MOV       R2,A
   \   000008   E4           CLR       A
   \   000009   3F           ADDC      A,R7
   \   00000A   FB           MOV       R3,A
   \   00000B   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000003   F9           MOV       R1,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004                REQUIRE ??Subroutine47_0
   \   000004                ; // Fall through to label ??Subroutine47_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine48_0:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F8           MOV       R0,A
   \   000008   A3           INC       DPTR
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   C8           XCH       A,R0
   \   00000B   2414         ADD       A,#0x14
   \   00000D   F582         MOV       DPL,A
   \   00000F   E4           CLR       A
   \   000010   38           ADDC      A,R0
   \   000011   F583         MOV       DPH,A
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F9           MOV       R1,A
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2406         ADD       A,#0x6
   \   000003   F8           MOV       R0,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   3400         ADDC      A,#0x0
   \   000008   F9           MOV       R1,A
   \   000009   22           RET
   1803          #endif // ZCL_IDENTIFY
   1804          
   1805          #ifdef ZCL_GROUPS
   1806          
   1807          /*********************************************************************
   1808           * @fn      zclGeneral_AddGroup
   1809           *
   1810           * @brief   Add a Group.
   1811           *
   1812           * @param   endPoint - application endpoint
   1813           * @param   group - group to be added
   1814           * @param   pData - pointer to the group info
   1815           *
   1816           * @return  ZStatus_t
   1817           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1818          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   \                     zclGeneral_AddGroup:
   1819          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V1,R1
   \   00000C   EA           MOV       A,R2
   \   00000D   FE           MOV       R6,A
   \   00000E   EB           MOV       A,R3
   \   00000F   FF           MOV       R7,A
   \   000010   8C..         MOV       ?V2,R4
   \   000012   8D..         MOV       ?V3,R5
   1820            uint8 nameLen;
   1821            uint8 nameSupport = FALSE;
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   E4           CLR       A
   \   00001B   F0           MOVX      @DPTR,A
   1822          
   1823            pData += 2;   // Move past group ID
   1824            nameLen = *pData++;
   \   00001C   8C82         MOV       DPL,R4
   \   00001E   8D83         MOV       DPH,R5
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   F5..         MOV       ?V0,A
   1825          
   1826            // Retrieve Name Support attribute
   1827            zcl_ReadAttrData( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS,
   1828                              ATTRID_GROUP_NAME_SUPPORT, &nameSupport, NULL );
   \   000025                ; Setup parameters for call to function zcl_ReadAttrData
   \   000025   E4           CLR       A
   \   000026   F5..         MOV       ?V4,A
   \   000028   F5..         MOV       ?V5,A
   \   00002A   78..         MOV       R0,#?V4
   \   00002C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002F   7402         MOV       A,#0x2
   \   000031   12....       LCALL     ?XSTACK_DISP100_8
   \   000034   88..         MOV       ?V4,R0
   \   000036   89..         MOV       ?V5,R1
   \   000038   78..         MOV       R0,#?V4
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7C00         MOV       R4,#0x0
   \   00003F   7D00         MOV       R5,#0x0
   \   000041   7A04         MOV       R2,#0x4
   \   000043   7B00         MOV       R3,#0x0
   \   000045   A9..         MOV       R1,?V1
   \   000047   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   00004A   7404         MOV       A,#0x4
   \   00004C   12....       LCALL     ?DEALLOC_XSTACK8
   1829          
   1830            if ( nameSupport )
   \   00004F   85..82       MOV       DPL,?XSP + 0
   \   000052   85..83       MOV       DPH,?XSP + 1
   \   000055   E0           MOVX      A,@DPTR
   \   000056   603B         JZ        ??zclGeneral_AddGroup_0
   1831            {
   1832              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   \   000058   E5..         MOV       A,?V0
   \   00005A   C3           CLR       C
   \   00005B   9410         SUBB      A,#0x10
   \   00005D   4003         JC        ??zclGeneral_AddGroup_1
   1833                 nameLen = (APS_GROUP_NAME_LEN-1);
   \   00005F   75..0F       MOV       ?V0,#0xf
   1834              group->name[0] = nameLen;
   \                     ??zclGeneral_AddGroup_1:
   \   000062   8E82         MOV       DPL,R6
   \   000064   8F83         MOV       DPH,R7
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   E5..         MOV       A,?V0
   \   00006A   12....       LCALL     ?Subroutine35 & 0xFFFF
   1835              zcl_memcpy( &(group->name[1]), pData, nameLen );
   1836            }
   \                     ??CrossCallReturnLabel_63:
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A982         MOV       R1,DPL
   \   000072   AA83         MOV       R2,DPH
   \   000074   89..         MOV       ?V4,R1
   \   000076   8A..         MOV       ?V5,R2
   \   000078   75..00       MOV       ?V6,#0x0
   \   00007B   78..         MOV       R0,#?V4
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000080   AC..         MOV       R4,?V0
   \   000082   7D00         MOV       R5,#0x0
   \   000084   EE           MOV       A,R6
   \   000085   2403         ADD       A,#0x3
   \   000087   FA           MOV       R2,A
   \   000088   E4           CLR       A
   \   000089   3F           ADDC      A,R7
   \   00008A   FB           MOV       R3,A
   \   00008B   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00008E   7403         MOV       A,#0x3
   \   000090   12....       LCALL     ?DEALLOC_XSTACK8
   1837          
   1838            return ( aps_AddGroup( endPoint, group ) );
   \                     ??zclGeneral_AddGroup_0:
   \   000093                ; Setup parameters for call to function aps_AddGroup
   \   000093   EE           MOV       A,R6
   \   000094   FA           MOV       R2,A
   \   000095   EF           MOV       A,R7
   \   000096   FB           MOV       R3,A
   \   000097   A9..         MOV       R1,?V1
   \   000099   12....       LCALL     `??aps_AddGroup::?relay`; Banked call to: aps_AddGroup
   \   00009C   7401         MOV       A,#0x1
   \   00009E   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A1   7F07         MOV       R7,#0x7
   \   0000A3   02....       LJMP      ?BANKED_LEAVE_XDATA
   1839          }
   1840          
   1841          /*********************************************************************
   1842           * @fn      zclGeneral_ProcessInGroupsServer
   1843           *
   1844           * @brief   Process in the received Groups Command.
   1845           *
   1846           * @param   pInMsg - pointer to the incoming message
   1847           *
   1848           * @return  ZStatus_t
   1849           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1850          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   \                     zclGeneral_ProcessInGroupsServer:
   1851          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 54
   \   000005   74CA         MOV       A,#-0x36
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   1852            aps_Group_t group;
   1853            aps_Group_t *pGroup;
   1854            uint8 *pData;
   1855            uint8 status;
   1856            uint8 grpCnt;
   1857            uint8 grpRspCnt = 0;
   \   00000E   7F00         MOV       R7,#0x0
   1858            uint16 *grpList;
   1859            uint16 identifyTime = 0;
   \   000010   7402         MOV       A,#0x2
   \   000012   12....       LCALL     ?XSTACK_DISP0_8
   \   000015   E4           CLR       A
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   F0           MOVX      @DPTR,A
   1860            uint8 i;
   1861            ZStatus_t stat = ZSuccess;
   \   000019   7E00         MOV       R6,#0x0
   1862          
   1863            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   \   00001B                ; Setup parameters for call to function osal_memset
   \   00001B   7C12         MOV       R4,#0x12
   \   00001D   FD           MOV       R5,A
   \   00001E   F9           MOV       R1,A
   \   00001F   7404         MOV       A,#0x4
   \   000021   12....       LCALL     ?XSTACK_DISP101_8
   \   000024   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1864          
   1865            pData = pInMsg->pData;
   \   000027   85..82       MOV       DPL,?V0
   \   00002A   85..83       MOV       DPH,?V1
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   12....       LCALL     ?Subroutine15 & 0xFFFF
   1866            group.ID = BUILD_UINT16( pData[0], pData[1] );
   \                     ??CrossCallReturnLabel_28:
   \   000038   A3           INC       DPTR
   \   000039   A882         MOV       R0,DPL
   \   00003B   A983         MOV       R1,DPH
   \   00003D   85..82       MOV       DPL,?V2
   \   000040   F583         MOV       DPH,A
   \   000042   E0           MOVX      A,@DPTR
   \   000043   FC           MOV       R4,A
   \   000044   8882         MOV       DPL,R0
   \   000046   8983         MOV       DPH,R1
   \   000048   E0           MOVX      A,@DPTR
   \   000049   FB           MOV       R3,A
   \   00004A   EC           MOV       A,R4
   \   00004B   FA           MOV       R2,A
   \   00004C   7404         MOV       A,#0x4
   \   00004E   12....       LCALL     ?XSTACK_DISP0_8
   \   000051   EA           MOV       A,R2
   \   000052   F0           MOVX      @DPTR,A
   \   000053   A3           INC       DPTR
   \   000054   EB           MOV       A,R3
   \   000055   F0           MOVX      @DPTR,A
   1867            switch ( pInMsg->hdr.commandID )
   \   000056   E5..         MOV       A,?V0
   \   000058   2406         ADD       A,#0x6
   \   00005A   F5..         MOV       ?V8,A
   \   00005C   E4           CLR       A
   \   00005D   35..         ADDC      A,?V1
   \   00005F   F5..         MOV       ?V9,A
   \   000061   E5..         MOV       A,?V0
   \   000063   2407         ADD       A,#0x7
   \   000065   F5..         MOV       ?V6,A
   \   000067   E4           CLR       A
   \   000068   35..         ADDC      A,?V1
   \   00006A   F5..         MOV       ?V7,A
   \   00006C   85..82       MOV       DPL,?V6
   \   00006F   F583         MOV       DPH,A
   \   000071   E0           MOVX      A,@DPTR
   \   000072   601E         JZ        ??zclGeneral_ProcessInGroupsServer_0
   \   000074   14           DEC       A
   \   000075   6056         JZ        ??zclGeneral_ProcessInGroupsServer_1
   \   000077   14           DEC       A
   \   000078   7003         JNZ       $+5
   \   00007A   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_2 & 0xFFFF
   \   00007D   14           DEC       A
   \   00007E   7003         JNZ       $+5
   \   000080   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_3 & 0xFFFF
   \   000083   14           DEC       A
   \   000084   7003         JNZ       $+5
   \   000086   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_4 & 0xFFFF
   \   000089   14           DEC       A
   \   00008A   7003         JNZ       $+5
   \   00008C   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_5 & 0xFFFF
   \   00008F   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_6 & 0xFFFF
   1868            {
   1869              case COMMAND_GROUP_ADD:
   1870                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   \                     ??zclGeneral_ProcessInGroupsServer_0:
   \   000092                ; Setup parameters for call to function zclGeneral_AddGroup
   \   000092   AC..         MOV       R4,?V2
   \   000094   AD..         MOV       R5,?V3
   \   000096   7404         MOV       A,#0x4
   \   000098   12....       LCALL     ?XSTACK_DISP101_8
   \   00009B   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   00009E   12....       LCALL     `??zclGeneral_AddGroup::?relay`; Banked call to: zclGeneral_AddGroup
   \   0000A1   E9           MOV       A,R1
   \   0000A2   FC           MOV       R4,A
   1871                if ( status != ZSuccess )
   \   0000A3   600B         JZ        ??zclGeneral_ProcessInGroupsServer_7
   1872                {
   1873                  if ( status == ZApsDuplicateEntry )
   \   0000A5   74B8         MOV       A,#-0x48
   \   0000A7   6C           XRL       A,R4
   \   0000A8   7004         JNZ       ??zclGeneral_ProcessInGroupsServer_8
   1874                  {
   1875                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   \   0000AA   7C8A         MOV       R4,#-0x76
   \   0000AC   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_7
   1876                  }
   1877                  else
   1878                  {
   1879                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   \                     ??zclGeneral_ProcessInGroupsServer_8:
   \   0000AE   7C89         MOV       R4,#-0x77
   1880                  }
   1881                }
   1882          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1883                if ( UNICAST_MSG( pInMsg->msg ) )
   1884          #endif
   1885                {
   1886                  zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1887                                                   status, group.ID, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_7:
   \   0000B0   12....       LCALL     ?Subroutine6 & 0xFFFF
   1888                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1889                }
   \                     ??CrossCallReturnLabel_0:
   \   0000B3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B6   75..01       MOV       ?V0,#0x1
   \   0000B9   78..         MOV       R0,#?V0
   \   0000BB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000BE   7406         MOV       A,#0x6
   \   0000C0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C3   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0000C6   EC           MOV       A,R4
   \   0000C7   FD           MOV       R5,A
   \   0000C8   7C00         MOV       R4,#0x0
   \   0000CA   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_9 & 0xFFFF
   1890                break;
   1891          
   1892              case COMMAND_GROUP_VIEW:
   1893          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1894                if ( UNICAST_MSG( pInMsg->msg ) )
   1895          #endif
   1896                {
   1897                  pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   \                     ??zclGeneral_ProcessInGroupsServer_1:
   \   0000CD                ; Setup parameters for call to function aps_FindGroup
   \   0000CD   7404         MOV       A,#0x4
   \   0000CF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D2   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   0000D5   12....       LCALL     `??aps_FindGroup::?relay`; Banked call to: aps_FindGroup
   \   0000D8   8A..         MOV       ?V2,R2
   \   0000DA   8B..         MOV       ?V3,R3
   1898                  if ( pGroup )
   \   0000DC   EA           MOV       A,R2
   \   0000DD   45..         ORL       A,?V3
   \   0000DF   6004         JZ        ??zclGeneral_ProcessInGroupsServer_10
   1899                  {
   1900                    status = ZCL_STATUS_SUCCESS;
   \   0000E1   7C00         MOV       R4,#0x0
   \   0000E3   800B         SJMP      ??zclGeneral_ProcessInGroupsServer_11
   1901                  }
   1902                  else
   1903                  {
   1904                    // Group not found
   1905                    status = ZCL_STATUS_NOT_FOUND;
   \                     ??zclGeneral_ProcessInGroupsServer_10:
   \   0000E5   7C8B         MOV       R4,#-0x75
   1906                    pGroup = &group;
   \   0000E7   7404         MOV       A,#0x4
   \   0000E9   12....       LCALL     ?XSTACK_DISP100_8
   \   0000EC   88..         MOV       ?V2,R0
   \   0000EE   89..         MOV       ?V3,R1
   1907                  }
   1908                  zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1909                                                    status, pGroup, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_11:
   \   0000F0   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000F3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000F6   78..         MOV       R0,#?V2
   \   0000F8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000FB   7D01         MOV       R5,#0x1
   \   0000FD   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000100   12....       LCALL     `??zclGeneral_SendGroupViewResponse::?relay`; Banked call to: zclGeneral_SendGroupViewResponse
   \   000103   7403         MOV       A,#0x3
   \   000105   12....       LCALL     ?DEALLOC_XSTACK8
   1910                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \   000108   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_12 & 0xFFFF
   1911                }
   1912                break;
   1913          
   1914              case COMMAND_GROUP_GET_MEMBERSHIP:
   1915          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1916                if ( UNICAST_MSG( pInMsg->msg ) )
   1917          #endif
   1918                {
   1919                  grpCnt = *pData++;
   \                     ??zclGeneral_ProcessInGroupsServer_2:
   \   00010B   85..82       MOV       DPL,?V2
   \   00010E   85..83       MOV       DPH,?V3
   \   000111   E0           MOVX      A,@DPTR
   \   000112   FE           MOV       R6,A
   \   000113   88..         MOV       ?V2,R0
   \   000115   89..         MOV       ?V3,R1
   1920          
   1921                  // Allocate space for the group list
   1922                  grpList = zcl_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   \   000117                ; Setup parameters for call to function osal_mem_alloc
   \   000117   7A20         MOV       R2,#0x20
   \   000119   7B00         MOV       R3,#0x0
   \   00011B   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00011E   8A..         MOV       ?V4,R2
   \   000120   8B..         MOV       ?V5,R3
   1923                  if ( grpList != NULL )
   \   000122   EA           MOV       A,R2
   \   000123   45..         ORL       A,?V5
   \   000125   7003         JNZ       $+5
   \   000127   02....       LJMP      ??zclGeneral_ProcessInGroupsServer_13 & 0xFFFF
   1924                  {
   1925                    if ( grpCnt == 0 )
   \   00012A   EE           MOV       A,R6
   \   00012B   700A         JNZ       ??zclGeneral_ProcessInGroupsServer_14
   1926                    {
   1927                      // Find out all the groups of which the endpoint is a member.
   1928                      grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   \   00012D                ; Setup parameters for call to function aps_FindAllGroupsForEndpoint
   \   00012D   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   1929                    }
   \                     ??CrossCallReturnLabel_107:
   \   000130   12....       LCALL     `??aps_FindAllGroupsForEndpoint::?relay`; Banked call to: aps_FindAllGroupsForEndpoint
   \   000133   E9           MOV       A,R1
   \   000134   FF           MOV       R7,A
   \   000135   8056         SJMP      ??zclGeneral_ProcessInGroupsServer_15
   1930                    else
   1931                    {
   1932                      // Find out the groups (in the list) of which the endpoint is a member.
   1933                      for ( i = 0; i < grpCnt; i++ )
   \                     ??zclGeneral_ProcessInGroupsServer_14:
   \   000137   8E..         MOV       ?V10,R6
   1934                      {
   1935                        group.ID = BUILD_UINT16( pData[0], pData[1] );
   \                     ??zclGeneral_ProcessInGroupsServer_16:
   \   000139   85..82       MOV       DPL,?V2
   \   00013C   85..83       MOV       DPH,?V3
   \   00013F   E0           MOVX      A,@DPTR
   \   000140   FA           MOV       R2,A
   \   000141   A3           INC       DPTR
   \   000142   E0           MOVX      A,@DPTR
   \   000143   F9           MOV       R1,A
   \   000144   EA           MOV       A,R2
   \   000145   F8           MOV       R0,A
   \   000146   7404         MOV       A,#0x4
   \   000148   12....       LCALL     ?XSTACK_DISP0_8
   \   00014B   12....       LCALL     ?Subroutine27 & 0xFFFF
   1936                        pData += 2;
   \                     ??CrossCallReturnLabel_76:
   \   00014E   E5..         MOV       A,?V2
   \   000150   2402         ADD       A,#0x2
   \   000152   F5..         MOV       ?V2,A
   \   000154   5002         JNC       ??zclGeneral_ProcessInGroupsServer_17
   \   000156   05..         INC       ?V3
   1937          
   1938                        if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   \                     ??zclGeneral_ProcessInGroupsServer_17:
   \   000158                ; Setup parameters for call to function aps_FindGroup
   \   000158   7404         MOV       A,#0x4
   \   00015A   12....       LCALL     ?XSTACK_DISP0_8
   \   00015D   12....       LCALL     ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000160   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000163   12....       LCALL     `??aps_FindGroup::?relay`; Banked call to: aps_FindGroup
   \   000166   8B..         MOV       ?V7,R3
   \   000168   EA           MOV       A,R2
   \   000169   45..         ORL       A,?V7
   \   00016B   6017         JZ        ??zclGeneral_ProcessInGroupsServer_18
   1939                          grpList[grpRspCnt++] = group.ID;
   \   00016D   7404         MOV       A,#0x4
   \   00016F   12....       LCALL     ?XSTACK_DISP0_8
   \   000172   12....       LCALL     ??Subroutine45_0 & 0xFFFF
   1940                      }
   \                     ??CrossCallReturnLabel_88:
   \   000175   EF           MOV       A,R7
   \   000176   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000179   E5..         MOV       A,?V5
   \   00017B   39           ADDC      A,R1
   \   00017C   F583         MOV       DPH,A
   \   00017E   EA           MOV       A,R2
   \   00017F   F0           MOVX      @DPTR,A
   \   000180   A3           INC       DPTR
   \   000181   EB           MOV       A,R3
   \   000182   F0           MOVX      @DPTR,A
   \   000183   0F           INC       R7
   \                     ??zclGeneral_ProcessInGroupsServer_18:
   \   000184   15..         DEC       ?V10
   \   000186   E5..         MOV       A,?V10
   \   000188   70AF         JNZ       ??zclGeneral_ProcessInGroupsServer_16
   \   00018A   EF           MOV       A,R7
   \   00018B   606A         JZ        ??zclGeneral_ProcessInGroupsServer_19
   1941                    }
   1942          
   1943                    if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1944                    {
   1945                      zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1946                                                                 aps_GroupsRemaingCapacity(), grpRspCnt,
   1947                                                                 grpList, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_15:
   \   00018D                ; Setup parameters for call to function aps_CountAllGroups
   \   00018D   12....       LCALL     `??aps_CountAllGroups::?relay`; Banked call to: aps_CountAllGroups
   \   000190   E9           MOV       A,R1
   \   000191   F9           MOV       R1,A
   \   000192   85..82       MOV       DPL,?V0
   \   000195   85..83       MOV       DPH,?V1
   \   000198   E0           MOVX      A,@DPTR
   \   000199   F5..         MOV       ?V0,A
   \   00019B   A3           INC       DPTR
   \   00019C   E0           MOVX      A,@DPTR
   \   00019D   F5..         MOV       ?V1,A
   \   00019F                ; Setup parameters for call to function zclGeneral_SendGroupGetMembershipRequest
   \   00019F   85..82       MOV       DPL,?V8
   \   0001A2   85..83       MOV       DPH,?V9
   \   0001A5   E0           MOVX      A,@DPTR
   \   0001A6   F5..         MOV       ?V2,A
   \   0001A8   78..         MOV       R0,#?V2
   \   0001AA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001AD   75..01       MOV       ?V2,#0x1
   \   0001B0   78..         MOV       R0,#?V2
   \   0001B2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001B5   78..         MOV       R0,#?V4
   \   0001B7   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001BA   EF           MOV       A,R7
   \   0001BB   F5..         MOV       ?V2,A
   \   0001BD   78..         MOV       R0,#?V2
   \   0001BF   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C2   7410         MOV       A,#0x10
   \   0001C4   C3           CLR       C
   \   0001C5   99           SUBB      A,R1
   \   0001C6   F5..         MOV       ?V2,A
   \   0001C8   78..         MOV       R0,#?V2
   \   0001CA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001CD   75..01       MOV       ?V2,#0x1
   \   0001D0   78..         MOV       R0,#?V2
   \   0001D2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001D5   7D01         MOV       R5,#0x1
   \   0001D7   7C02         MOV       R4,#0x2
   \   0001D9   E5..         MOV       A,?V0
   \   0001DB   2406         ADD       A,#0x6
   \   0001DD   FA           MOV       R2,A
   \   0001DE   E4           CLR       A
   \   0001DF   35..         ADDC      A,?V1
   \   0001E1   FB           MOV       R3,A
   \   0001E2   E5..         MOV       A,?V0
   \   0001E4   2414         ADD       A,#0x14
   \   0001E6   F582         MOV       DPL,A
   \   0001E8   E4           CLR       A
   \   0001E9   35..         ADDC      A,?V1
   \   0001EB   F583         MOV       DPH,A
   \   0001ED   E0           MOVX      A,@DPTR
   \   0001EE   F9           MOV       R1,A
   \   0001EF   12....       LCALL     `??zclGeneral_SendGroupGetMembershipRequest::?re`; Banked call to: zclGeneral_SendGroupGetMembershipRequest
   \   0001F2   7407         MOV       A,#0x7
   \   0001F4   12....       LCALL     ?DEALLOC_XSTACK8
   1948                    }
   1949          
   1950                    zcl_mem_free( grpList );
   \                     ??zclGeneral_ProcessInGroupsServer_19:
   \   0001F7                ; Setup parameters for call to function osal_mem_free
   \   0001F7   AA..         MOV       R2,?V4
   \   0001F9   AB..         MOV       R3,?V5
   \   0001FB   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001FE   8054         SJMP      ??zclGeneral_ProcessInGroupsServer_20
   1951                  }
   1952                  else
   1953                  {
   1954                    // Couldn't allocate space for the group list -- send a Default Response command back.
   1955                    zclDefaultRspCmd_t defaultRspCmd;
   1956          
   1957                    defaultRspCmd.commandID = pInMsg->hdr.commandID;
   \                     ??zclGeneral_ProcessInGroupsServer_13:
   \   000200   85..82       MOV       DPL,?V6
   \   000203   85..83       MOV       DPH,?V7
   \   000206   E0           MOVX      A,@DPTR
   \   000207   85..82       MOV       DPL,?XSP + 0
   \   00020A   85..83       MOV       DPH,?XSP + 1
   \   00020D   F0           MOVX      @DPTR,A
   1958                    defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   \   00020E   7401         MOV       A,#0x1
   \   000210   12....       LCALL     ?XSTACK_DISP0_8
   \   000213   7489         MOV       A,#-0x77
   \   000215   F0           MOVX      @DPTR,A
   1959                    zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1960                                           pInMsg->msg->clusterId, &defaultRspCmd,
   1961                                           ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   \   000216   12....       LCALL     ?Subroutine6 & 0xFFFF
   1962                  }
   \                     ??CrossCallReturnLabel_2:
   \   000219   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00021C   E4           CLR       A
   \   00021D   F5..         MOV       ?V0,A
   \   00021F   F5..         MOV       ?V1,A
   \   000221   78..         MOV       R0,#?V0
   \   000223   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000226   75..01       MOV       ?V0,#0x1
   \   000229   78..         MOV       R0,#?V0
   \   00022B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00022E   78..         MOV       R0,#?V0
   \   000230   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000233   7405         MOV       A,#0x5
   \   000235   12....       LCALL     ?XSTACK_DISP100_8
   \   000238   88..         MOV       ?V0,R0
   \   00023A   89..         MOV       ?V1,R1
   \   00023C   78..         MOV       R0,#?V0
   \   00023E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000241   8E82         MOV       DPL,R6
   \   000243   8F83         MOV       DPH,R7
   \   000245   A3           INC       DPTR
   \   000246   A3           INC       DPTR
   \   000247   A3           INC       DPTR
   \   000248   A3           INC       DPTR
   \   000249   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00024C   12....       LCALL     `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   00024F   7407         MOV       A,#0x7
   \   000251   12....       LCALL     ?DEALLOC_XSTACK8
   1963          
   1964                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \                     ??zclGeneral_ProcessInGroupsServer_20:
   \   000254   8039         SJMP      ??zclGeneral_ProcessInGroupsServer_12
   1965                }
   1966                break;
   1967          
   1968              case COMMAND_GROUP_REMOVE:
   1969          #if defined ( ZCL_SCENES )
   1970                zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, group.ID );
   1971          #endif
   1972                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   \                     ??zclGeneral_ProcessInGroupsServer_3:
   \   000256                ; Setup parameters for call to function aps_RemoveGroup
   \   000256   7404         MOV       A,#0x4
   \   000258   12....       LCALL     ?XSTACK_DISP0_8
   \   00025B   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   00025E   12....       LCALL     `??aps_RemoveGroup::?relay`; Banked call to: aps_RemoveGroup
   \   000261   E9           MOV       A,R1
   \   000262   6004         JZ        ??zclGeneral_ProcessInGroupsServer_21
   1973                {
   1974                  status = ZCL_STATUS_SUCCESS;
   \   000264   7C00         MOV       R4,#0x0
   \   000266   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_22
   1975                }
   1976                else
   1977                {
   1978                  status = ZCL_STATUS_NOT_FOUND;
   \                     ??zclGeneral_ProcessInGroupsServer_21:
   \   000268   7C8B         MOV       R4,#-0x75
   1979                }
   1980          
   1981          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1982                if ( UNICAST_MSG( pInMsg->msg ) )
   1983          #endif
   1984                {
   1985                  zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1986                                                      status, group.ID, true, pInMsg->hdr.transSeqNum );
   \                     ??zclGeneral_ProcessInGroupsServer_22:
   \   00026A   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00026D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000270   75..01       MOV       ?V0,#0x1
   \   000273   78..         MOV       R0,#?V0
   \   000275   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000278   7406         MOV       A,#0x6
   \   00027A   12....       LCALL     ?XSTACK_DISP0_8
   \   00027D   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000280   EC           MOV       A,R4
   \   000281   FD           MOV       R5,A
   \   000282   7C03         MOV       R4,#0x3
   \                     ??zclGeneral_ProcessInGroupsServer_9:
   \   000284   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000287   12....       LCALL     `??zclGeneral_SendGroupResponse::?relay`; Banked call to: zclGeneral_SendGroupResponse
   \   00028A   7404         MOV       A,#0x4
   \   00028C   12....       LCALL     ?DEALLOC_XSTACK8
   1987                  stat = ZCL_STATUS_CMD_HAS_RSP;
   \                     ??zclGeneral_ProcessInGroupsServer_12:
   \   00028F   7EFF         MOV       R6,#-0x1
   1988                }
   1989                break;
   \   000291   805E         SJMP      ??zclGeneral_ProcessInGroupsServer_23
   1990          
   1991              case COMMAND_GROUP_REMOVE_ALL:
   1992                {
   1993                  uint8 numGroups;
   1994                  uint16 groupList[APS_MAX_GROUPS];
   1995          
   1996                  if ( numGroups = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, groupList ) )
   \                     ??zclGeneral_ProcessInGroupsServer_4:
   \   000293                ; Setup parameters for call to function aps_FindAllGroupsForEndpoint
   \   000293   7416         MOV       A,#0x16
   \   000295   12....       LCALL     ?XSTACK_DISP101_8
   \   000298   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   00029B   12....       LCALL     `??aps_FindAllGroupsForEndpoint::?relay`; Banked call to: aps_FindAllGroupsForEndpoint
   \   00029E   E9           MOV       A,R1
   \   00029F   6050         JZ        ??zclGeneral_ProcessInGroupsServer_23
   1997                  {
   1998                    for ( i = 0; i < numGroups; i++ )
   1999                    {
   2000          #if defined ( ZCL_SCENES )
   2001                      zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, groupList[i] );
   2002          #endif
   2003                    }
   2004          
   2005                    aps_RemoveAllGroup( pInMsg->msg->endPoint );
   \   0002A1                ; Setup parameters for call to function aps_RemoveAllGroup
   \   0002A1   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   2006                  }
   2007                }
   \                     ??CrossCallReturnLabel_110:
   \   0002A4   12....       LCALL     `??aps_RemoveAllGroup::?relay`; Banked call to: aps_RemoveAllGroup
   \   0002A7   8048         SJMP      ??zclGeneral_ProcessInGroupsServer_23
   2008                break;
   2009          
   2010              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   2011                // Retrieve Identify Time
   2012                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2013                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   \                     ??zclGeneral_ProcessInGroupsServer_5:
   \   0002A9                ; Setup parameters for call to function zcl_ReadAttrData
   \   0002A9   E4           CLR       A
   \   0002AA   F5..         MOV       ?V4,A
   \   0002AC   F5..         MOV       ?V5,A
   \   0002AE   78..         MOV       R0,#?V4
   \   0002B0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0002B3   7404         MOV       A,#0x4
   \   0002B5   12....       LCALL     ?XSTACK_DISP100_8
   \   0002B8   88..         MOV       ?V4,R0
   \   0002BA   89..         MOV       ?V5,R1
   \   0002BC   78..         MOV       R0,#?V4
   \   0002BE   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0002C1   7C00         MOV       R4,#0x0
   \   0002C3   7D00         MOV       R5,#0x0
   \   0002C5   7A03         MOV       R2,#0x3
   \   0002C7   7B00         MOV       R3,#0x0
   \   0002C9   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   0002CC   12....       LCALL     `??zcl_ReadAttrData::?relay`; Banked call to: zcl_ReadAttrData
   \   0002CF   7404         MOV       A,#0x4
   \   0002D1   12....       LCALL     ?DEALLOC_XSTACK8
   2014          
   2015                // Is device identifying itself?
   2016                if ( identifyTime > 0 )
   \   0002D4   7402         MOV       A,#0x2
   \   0002D6   12....       LCALL     ?XSTACK_DISP0_8
   \   0002D9   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   0002DC   6013         JZ        ??zclGeneral_ProcessInGroupsServer_23
   2017                {
   2018                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   \   0002DE                ; Setup parameters for call to function zclGeneral_AddGroup
   \   0002DE   AC..         MOV       R4,?V2
   \   0002E0   AD..         MOV       R5,?V3
   \   0002E2   7404         MOV       A,#0x4
   \   0002E4   12....       LCALL     ?XSTACK_DISP101_8
   \   0002E7   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   2019                }
   \                     ??CrossCallReturnLabel_112:
   \   0002EA   12....       LCALL     `??zclGeneral_AddGroup::?relay`; Banked call to: zclGeneral_AddGroup
   \   0002ED   8002         SJMP      ??zclGeneral_ProcessInGroupsServer_23
   2020                break;
   2021          
   2022              default:
   2023                stat = ZFailure;
   \                     ??zclGeneral_ProcessInGroupsServer_6:
   \   0002EF   7E01         MOV       R6,#0x1
   2024                break;
   2025            }
   2026          
   2027            return ( stat );
   \                     ??zclGeneral_ProcessInGroupsServer_23:
   \   0002F1   EE           MOV       A,R6
   \   0002F2   F9           MOV       R1,A
   \   0002F3   7436         MOV       A,#0x36
   \   0002F5   02....       LJMP      ?Subroutine2 & 0xFFFF
   2028          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   EE           MOV       A,R6
   \   000001   2406         ADD       A,#0x6
   \   000003   FA           MOV       R2,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   FB           MOV       R3,A
   \   000007                REQUIRE ??Subroutine44_0
   \   000007                ; // Fall through to label ??Subroutine44_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FE           MOV       R6,A
   \   000008   A3           INC       DPTR
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   FF           MOV       R7,A
   \   00000B                ; Setup parameters for call to function zclGeneral_SendGroupResponse
   \   00000B                ; Setup parameters for call to function zclGeneral_SendGroupViewResponse
   \   00000B                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   00000B                ; Setup parameters for call to function zclGeneral_SendGroupResponse
   \   00000B   85..82       MOV       DPL,?V8
   \   00000E   85..83       MOV       DPH,?V9
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F5..         MOV       ?V0,A
   \   000014   78..         MOV       R0,#?V0
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002                REQUIRE ??Subroutine48_0
   \   000002                ; // Fall through to label ??Subroutine48_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   25E0         ADD       A,0xE0 /* A   */
   \   000002   F8           MOV       R0,A
   \   000003   E4           CLR       A
   \   000004   33           RLC       A
   \   000005   F9           MOV       R1,A
   \   000006   E5..         MOV       A,?V4
   \   000008   28           ADD       A,R0
   \   000009   F582         MOV       DPL,A
   \   00000B   22           RET
   2029          
   2030          /*********************************************************************
   2031           * @fn      zclGeneral_ProcessInGroupsClient
   2032           *
   2033           * @brief   Process in the received Groups Command.
   2034           *
   2035           * @param   pInMsg - pointer to the incoming message
   2036           *
   2037           * @return  ZStatus_t
   2038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006                REQUIRE ??Subroutine46_0
   \   000006                ; // Fall through to label ??Subroutine46_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2039          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInGroupsClient:
   2040                                                             zclGeneral_AppCallbacks_t *pCBs )
   2041          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 28
   \   000005   74E4         MOV       A,#-0x1c
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
   2042            aps_Group_t group;
   2043            uint8 *pData = pInMsg->pData;
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   FE           MOV       R6,A
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   FF           MOV       R7,A
   2044            uint8 grpCnt;
   2045            uint8 nameLen;
   2046            zclGroupRsp_t rsp;
   2047            uint8 i;
   2048            ZStatus_t stat = ZSuccess;
   \   000023   75..00       MOV       ?V11,#0x0
   2049          
   2050            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   \   000026                ; Setup parameters for call to function osal_memset
   \   000026   7C12         MOV       R4,#0x12
   \   000028   7D00         MOV       R5,#0x0
   \   00002A   7900         MOV       R1,#0x0
   \   00002C   740A         MOV       A,#0xa
   \   00002E   12....       LCALL     ?XSTACK_DISP101_8
   \   000031   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2051            zcl_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   \   000034                ; Setup parameters for call to function osal_memset
   \   000034   7C0A         MOV       R4,#0xa
   \   000036   7D00         MOV       R5,#0x0
   \   000038   7900         MOV       R1,#0x0
   \   00003A   AA..         MOV       R2,?XSP + 0
   \   00003C   AB..         MOV       R3,?XSP + 1
   \   00003E   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2052          
   2053            switch ( pInMsg->hdr.commandID )
   \   000041   EE           MOV       A,R6
   \   000042   2402         ADD       A,#0x2
   \   000044   FA           MOV       R2,A
   \   000045   E4           CLR       A
   \   000046   3F           ADDC      A,R7
   \   000047   FB           MOV       R3,A
   \   000048   E5..         MOV       A,?V0
   \   00004A   2414         ADD       A,#0x14
   \   00004C   F5..         MOV       ?V0,A
   \   00004E   5002         JNC       ??zclGeneral_ProcessInGroupsClient_0
   \   000050   05..         INC       ?V1
   \                     ??zclGeneral_ProcessInGroupsClient_0:
   \   000052   8E82         MOV       DPL,R6
   \   000054   8F83         MOV       DPH,R7
   \   000056   A3           INC       DPTR
   \   000057   A882         MOV       R0,DPL
   \   000059   A983         MOV       R1,DPH
   \   00005B   E5..         MOV       A,?V6
   \   00005D   2407         ADD       A,#0x7
   \   00005F   F5..         MOV       ?V2,A
   \   000061   E4           CLR       A
   \   000062   35..         ADDC      A,?V7
   \   000064   F5..         MOV       ?V3,A
   \   000066   85..82       MOV       DPL,?V2
   \   000069   F583         MOV       DPH,A
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   600F         JZ        ??zclGeneral_ProcessInGroupsClient_1
   \   00006E   14           DEC       A
   \   00006F   600C         JZ        ??zclGeneral_ProcessInGroupsClient_1
   \   000071   14           DEC       A
   \   000072   7003         JNZ       $+5
   \   000074   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_2 & 0xFFFF
   \   000077   14           DEC       A
   \   000078   6003         JZ        $+5
   \   00007A   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_3 & 0xFFFF
   2054            {
   2055              case COMMAND_GROUP_ADD_RSP:
   2056              case COMMAND_GROUP_VIEW_RSP:
   2057              case COMMAND_GROUP_REMOVE_RSP:
   2058                rsp.status = *pData++;
   \                     ??zclGeneral_ProcessInGroupsClient_1:
   \   00007D   8E82         MOV       DPL,R6
   \   00007F   8F83         MOV       DPH,R7
   \   000081   E0           MOVX      A,@DPTR
   \   000082   FC           MOV       R4,A
   \   000083   7403         MOV       A,#0x3
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   EC           MOV       A,R4
   \   000089   F0           MOVX      @DPTR,A
   \   00008A   E8           MOV       A,R0
   \   00008B   FE           MOV       R6,A
   \   00008C   E9           MOV       A,R1
   \   00008D   FF           MOV       R7,A
   2059                group.ID = BUILD_UINT16( pData[0], pData[1] );
   \   00008E   8E82         MOV       DPL,R6
   \   000090   8F83         MOV       DPH,R7
   \   000092   E0           MOVX      A,@DPTR
   \   000093   F5..         MOV       ?V4,A
   \   000095   8A82         MOV       DPL,R2
   \   000097   8B83         MOV       DPH,R3
   \   000099   E0           MOVX      A,@DPTR
   \   00009A   F9           MOV       R1,A
   \   00009B   740A         MOV       A,#0xa
   \   00009D   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A0   E5..         MOV       A,?V4
   \   0000A2   12....       LCALL     ??Subroutine43_0 & 0xFFFF
   2060          
   2061                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   \                     ??CrossCallReturnLabel_72:
   \   0000A5   EC           MOV       A,R4
   \   0000A6   705B         JNZ       ??CrossCallReturnLabel_77
   \   0000A8   85..82       MOV       DPL,?V2
   \   0000AB   85..83       MOV       DPH,?V3
   \   0000AE   E0           MOVX      A,@DPTR
   \   0000AF   6401         XRL       A,#0x1
   \   0000B1   7050         JNZ       ??CrossCallReturnLabel_77
   2062                {
   2063                  pData += 2;   // Move past ID
   2064                  nameLen = *pData++;
   \   0000B3   8E82         MOV       DPL,R6
   \   0000B5   8F83         MOV       DPH,R7
   \   0000B7   A3           INC       DPTR
   \   0000B8   A3           INC       DPTR
   \   0000B9   E0           MOVX      A,@DPTR
   \   0000BA   F9           MOV       R1,A
   \   0000BB   EE           MOV       A,R6
   \   0000BC   2403         ADD       A,#0x3
   \   0000BE   FE           MOV       R6,A
   \   0000BF   5001         JNC       ??zclGeneral_ProcessInGroupsClient_4
   \   0000C1   0F           INC       R7
   2065                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   \                     ??zclGeneral_ProcessInGroupsClient_4:
   \   0000C2   E9           MOV       A,R1
   \   0000C3   C3           CLR       C
   \   0000C4   9410         SUBB      A,#0x10
   \   0000C6   4002         JC        ??zclGeneral_ProcessInGroupsClient_5
   2066                    nameLen = (APS_GROUP_NAME_LEN-1);
   \   0000C8   790F         MOV       R1,#0xf
   2067                  group.name[0] = nameLen;
   \                     ??zclGeneral_ProcessInGroupsClient_5:
   \   0000CA   740C         MOV       A,#0xc
   \   0000CC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CF   E9           MOV       A,R1
   \   0000D0   F0           MOVX      @DPTR,A
   2068                  zcl_memcpy( &(group.name[1]), pData, nameLen );
   \   0000D1                ; Setup parameters for call to function osal_memcpy
   \   0000D1   8E..         MOV       ?V8,R6
   \   0000D3   8F..         MOV       ?V9,R7
   \   0000D5   75..00       MOV       ?V10,#0x0
   \   0000D8   78..         MOV       R0,#?V8
   \   0000DA   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000DD   E9           MOV       A,R1
   \   0000DE   FC           MOV       R4,A
   \   0000DF   7D00         MOV       R5,#0x0
   \   0000E1   7410         MOV       A,#0x10
   \   0000E3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E6   AA82         MOV       R2,DPL
   \   0000E8   AB83         MOV       R3,DPH
   \   0000EA   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000ED   7403         MOV       A,#0x3
   \   0000EF   12....       LCALL     ?DEALLOC_XSTACK8
   2069                  rsp.grpName = group.name;
   \   0000F2   740C         MOV       A,#0xc
   \   0000F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F7   A882         MOV       R0,DPL
   \   0000F9   A983         MOV       R1,DPH
   \   0000FB   7408         MOV       A,#0x8
   \   0000FD   12....       LCALL     ?XSTACK_DISP0_8
   \   000100   12....       LCALL     ?Subroutine27 & 0xFFFF
   2070                }
   2071          
   2072                if ( pCBs->pfnGroupRsp )
   \                     ??CrossCallReturnLabel_77:
   \   000103   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000106   7003         JNZ       $+5
   \   000108   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_6 & 0xFFFF
   2073                {
   2074                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   00010B   12....       LCALL     ?Subroutine8 & 0xFFFF
   2075                  rsp.cmdID = pInMsg->hdr.commandID;
   \                     ??CrossCallReturnLabel_17:
   \   00010E   C0E0         PUSH      A
   \   000110   7402         MOV       A,#0x2
   \   000112   12....       LCALL     ?XSTACK_DISP0_8
   \   000115   D0E0         POP       A
   \   000117   F0           MOVX      @DPTR,A
   2076                  rsp.grpCnt = 1;
   \   000118   7404         MOV       A,#0x4
   \   00011A   12....       LCALL     ?XSTACK_DISP0_8
   \   00011D   7401         MOV       A,#0x1
   \   00011F   F0           MOVX      @DPTR,A
   2077                  rsp.grpList = &group.ID;
   \   000120   740A         MOV       A,#0xa
   \   000122   12....       LCALL     ?XSTACK_DISP100_8
   \   000125   7405         MOV       A,#0x5
   \   000127   12....       LCALL     ?XSTACK_DISP0_8
   \   00012A   12....       LCALL     ?Subroutine27 & 0xFFFF
   2078                  rsp.capacity = 0;
   \                     ??CrossCallReturnLabel_78:
   \   00012D   7407         MOV       A,#0x7
   \   00012F   12....       LCALL     ?XSTACK_DISP0_8
   \   000132   E4           CLR       A
   \   000133   12....       LCALL     ?Subroutine14 & 0xFFFF
   2079          
   2080                  pCBs->pfnGroupRsp( &rsp );
   2081                }
   \                     ??CrossCallReturnLabel_115:
   \   000136   12....       LCALL     ?CALL_IND
   \   000139   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_6 & 0xFFFF
   2082                break;
   2083          
   2084              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   2085                {
   2086                  uint16 *grpList = NULL;
   \                     ??zclGeneral_ProcessInGroupsClient_2:
   \   00013C   75..00       MOV       ?V4,#0x0
   \   00013F   75..00       MOV       ?V5,#0x0
   2087                  rsp.capacity = *pData++;
   \   000142   8E82         MOV       DPL,R6
   \   000144   8F83         MOV       DPH,R7
   \   000146   E0           MOVX      A,@DPTR
   \   000147   C0E0         PUSH      A
   \   000149   7407         MOV       A,#0x7
   \   00014B   12....       LCALL     ?XSTACK_DISP0_8
   \   00014E   D0E0         POP       A
   \   000150   F0           MOVX      @DPTR,A
   2088                  grpCnt = *pData++;
   \   000151   8882         MOV       DPL,R0
   \   000153   8983         MOV       DPH,R1
   \   000155   E0           MOVX      A,@DPTR
   \   000156   F5..         MOV       ?V8,A
   \   000158   0E           INC       R6
   \   000159   0E           INC       R6
   \   00015A   EB           MOV       A,R3
   \   00015B   FF           MOV       R7,A
   2089          
   2090                  if ( grpCnt > 0 )
   \   00015C   E5..         MOV       A,?V8
   \   00015E   6049         JZ        ??zclGeneral_ProcessInGroupsClient_7
   2091                  {
   2092                    // Allocate space for the group list
   2093                    grpList = zcl_mem_alloc( sizeof( uint16 ) * grpCnt );
   \   000160                ; Setup parameters for call to function osal_mem_alloc
   \   000160   25E0         ADD       A,0xE0 /* A   */
   \   000162   FA           MOV       R2,A
   \   000163   E4           CLR       A
   \   000164   33           RLC       A
   \   000165   FB           MOV       R3,A
   \   000166   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000169   8A..         MOV       ?V4,R2
   \   00016B   8B..         MOV       ?V5,R3
   2094                    if ( grpList != NULL )
   \   00016D   EA           MOV       A,R2
   \   00016E   45..         ORL       A,?V5
   \   000170   6037         JZ        ??zclGeneral_ProcessInGroupsClient_7
   2095                    {
   2096                      rsp.grpCnt = grpCnt;
   \   000172   7404         MOV       A,#0x4
   \   000174   12....       LCALL     ?XSTACK_DISP0_8
   \   000177   E5..         MOV       A,?V8
   \   000179   F0           MOVX      @DPTR,A
   2097                      for ( i = 0; i < grpCnt; i++ )
   \   00017A   7A00         MOV       R2,#0x0
   \   00017C   8025         SJMP      ??zclGeneral_ProcessInGroupsClient_8
   2098                      {
   2099                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   \                     ??zclGeneral_ProcessInGroupsClient_9:
   \   00017E   8E82         MOV       DPL,R6
   \   000180   8F83         MOV       DPH,R7
   \   000182   12....       LCALL     ??Subroutine47_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000185   F8           MOV       R0,A
   \   000186   E4           CLR       A
   \   000187   C8           XCH       A,R0
   \   000188   F9           MOV       R1,A
   \   000189   EC           MOV       A,R4
   \   00018A   28           ADD       A,R0
   \   00018B   E4           CLR       A
   \   00018C   39           ADDC      A,R1
   \   00018D   FD           MOV       R5,A
   \   00018E   EA           MOV       A,R2
   \   00018F   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000192   EB           MOV       A,R3
   \   000193   39           ADDC      A,R1
   \   000194   F583         MOV       DPH,A
   \   000196   EC           MOV       A,R4
   \   000197   F0           MOVX      @DPTR,A
   \   000198   A3           INC       DPTR
   \   000199   ED           MOV       A,R5
   \   00019A   F0           MOVX      @DPTR,A
   2100                        pData += 2;
   \   00019B   EE           MOV       A,R6
   \   00019C   2402         ADD       A,#0x2
   \   00019E   FE           MOV       R6,A
   \   00019F   5001         JNC       ??zclGeneral_ProcessInGroupsClient_10
   \   0001A1   0F           INC       R7
   2101                      }
   \                     ??zclGeneral_ProcessInGroupsClient_10:
   \   0001A2   0A           INC       R2
   \                     ??zclGeneral_ProcessInGroupsClient_8:
   \   0001A3   EA           MOV       A,R2
   \   0001A4   C3           CLR       C
   \   0001A5   95..         SUBB      A,?V8
   \   0001A7   40D5         JC        ??zclGeneral_ProcessInGroupsClient_9
   2102                    }
   2103                  }
   2104          
   2105                  if ( pCBs->pfnGroupRsp )
   \                     ??zclGeneral_ProcessInGroupsClient_7:
   \   0001A9   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   0001AC   601E         JZ        ??zclGeneral_ProcessInGroupsClient_11
   2106                  {
   2107                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   0001AE   12....       LCALL     ?Subroutine8 & 0xFFFF
   2108                    rsp.cmdID = pInMsg->hdr.commandID;
   \                     ??CrossCallReturnLabel_18:
   \   0001B1   C0E0         PUSH      A
   \   0001B3   7402         MOV       A,#0x2
   \   0001B5   12....       LCALL     ?XSTACK_DISP0_8
   \   0001B8   D0E0         POP       A
   \   0001BA   F0           MOVX      @DPTR,A
   2109                    rsp.grpList = grpList;
   \   0001BB   7405         MOV       A,#0x5
   \   0001BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0001C0   E5..         MOV       A,?V4
   \   0001C2   F0           MOVX      @DPTR,A
   \   0001C3   A3           INC       DPTR
   \   0001C4   E5..         MOV       A,?V5
   \   0001C6   12....       LCALL     ?Subroutine14 & 0xFFFF
   2110          
   2111                    pCBs->pfnGroupRsp( &rsp );
   2112                  }
   \                     ??CrossCallReturnLabel_116:
   \   0001C9   12....       LCALL     ?CALL_IND
   2113          
   2114                  if ( grpList != NULL )
   \                     ??zclGeneral_ProcessInGroupsClient_11:
   \   0001CC   E5..         MOV       A,?V4
   \   0001CE   45..         ORL       A,?V5
   \   0001D0   600C         JZ        ??zclGeneral_ProcessInGroupsClient_6
   2115                  {
   2116                    zcl_mem_free( grpList );
   \   0001D2                ; Setup parameters for call to function osal_mem_free
   \   0001D2   AA..         MOV       R2,?V4
   \   0001D4   AB..         MOV       R3,?V5
   \   0001D6   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001D9   8003         SJMP      ??zclGeneral_ProcessInGroupsClient_6
   2117                  }
   2118                }
   2119                break;
   2120          
   2121              default:
   2122                stat = ZFailure;
   \                     ??zclGeneral_ProcessInGroupsClient_3:
   \   0001DB   75..01       MOV       ?V11,#0x1
   2123                break;
   2124            }
   2125          
   2126            return ( stat );
   \                     ??zclGeneral_ProcessInGroupsClient_6:
   \   0001DE   A9..         MOV       R1,?V11
   \   0001E0   741C         MOV       A,#0x1c
   \   0001E2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001E5   02....       LJMP      ?Subroutine3 & 0xFFFF
   2127          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for indirect call
   \   000001                ; Setup parameters for indirect call
   \   000001   AA..         MOV       R2,?XSP + 0
   \   000003   AB..         MOV       R3,?XSP + 1
   \   000005   85..82       MOV       DPL,?V0
   \   000008   85..83       MOV       DPH,?V1
   \   00000B                REQUIRE ??Subroutine49_0
   \   00000B                ; // Fall through to label ??Subroutine49_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine49_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   85..82       MOV       DPL,?V6
   \   000003   85..83       MOV       DPH,?V7
   \   000006   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   E8           MOV       A,R0
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   E9           MOV       A,R1
   \   000013   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000016   E0           MOVX      A,@DPTR
   \   000017   22           RET
   2128          #endif // ZCL_GROUPS
   2129          
   2130          #if defined( ZCL_SCENES )
   2131          #if !defined ( ZCL_STANDALONE )
   2132          /*********************************************************************
   2133           * @fn      zclGeneral_AddScene
   2134           *
   2135           * @brief   Add a scene for an endpoint
   2136           *
   2137           * @param   endpoint -
   2138           * @param   scene - new scene item
   2139           *
   2140           * @return  ZStatus_t
   2141           */
   2142          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   2143          {
   2144            zclGenSceneItem_t *pNewItem;
   2145            zclGenSceneItem_t *pLoop;
   2146          
   2147            // Fill in the new profile list
   2148            pNewItem = zcl_mem_alloc( sizeof( zclGenSceneItem_t ) );
   2149            if ( pNewItem == NULL )
   2150              return ( ZMemError );
   2151          
   2152            // Fill in the plugin record.
   2153            pNewItem->next = (zclGenSceneItem_t *)NULL;
   2154            pNewItem->endpoint = endpoint;
   2155            zcl_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   2156          
   2157            // Find spot in list
   2158            if (  zclGenSceneTable == NULL )
   2159            {
   2160              zclGenSceneTable = pNewItem;
   2161            }
   2162            else
   2163            {
   2164              // Look for end of list
   2165              pLoop = zclGenSceneTable;
   2166              while ( pLoop->next != NULL )
   2167                pLoop = pLoop->next;
   2168          
   2169              // Put new item at end of list
   2170              pLoop->next = pNewItem;
   2171            }
   2172          
   2173            // Update NV
   2174            zclGeneral_ScenesWriteNV();
   2175          
   2176            return ( ZSuccess );
   2177          }
   2178          #endif // ZCL_STANDALONE
   2179          
   2180          #if !defined ( ZCL_STANDALONE )
   2181          /*********************************************************************
   2182           * @fn      zclGeneral_FindScene
   2183           *
   2184           * @brief   Find a scene with endpoint and sceneID
   2185           *
   2186           * @param   endpoint -
   2187           * @param   groupID - what group the scene belongs to
   2188           * @param   sceneID - ID to look for scene
   2189           *
   2190           * @return  a pointer to the scene information, NULL if not found
   2191           */
   2192          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2193          {
   2194            zclGenSceneItem_t *pLoop;
   2195          
   2196            // Look for end of list
   2197            pLoop = zclGenSceneTable;
   2198            while ( pLoop )
   2199            {
   2200              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   2201                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2202              {
   2203                return ( &(pLoop->scene) );
   2204              }
   2205              pLoop = pLoop->next;
   2206            }
   2207          
   2208            return ( (zclGeneral_Scene_t *)NULL );
   2209          }
   2210          #endif // ZCL_STANDALONE
   2211          
   2212          #if !defined ( ZCL_STANDALONE )
   2213          /*********************************************************************
   2214           * @fn      zclGeneral_FindAllScenesForGroup
   2215           *
   2216           * @brief   Find all the scenes with groupID
   2217           *
   2218           * @param   endpoint - endpoint to look for
   2219           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   2220           *
   2221           * @return  number of scenes copied to sceneList
   2222           */
   2223          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   2224          {
   2225            zclGenSceneItem_t *pLoop;
   2226            uint8 cnt = 0;
   2227          
   2228            // Look for end of list
   2229            pLoop = zclGenSceneTable;
   2230            while ( pLoop )
   2231            {
   2232              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2233                sceneList[cnt++] = pLoop->scene.ID;
   2234              pLoop = pLoop->next;
   2235            }
   2236            return ( cnt );
   2237          }
   2238          #endif // ZCL_STANDALONE
   2239          
   2240          #if !defined ( ZCL_STANDALONE )
   2241          /*********************************************************************
   2242           * @fn      zclGeneral_RemoveScene
   2243           *
   2244           * @brief   Remove a scene with endpoint and sceneID
   2245           *
   2246           * @param   endpoint -
   2247           * @param   groupID - what group the scene belongs to
   2248           * @param   sceneID - ID to look for scene
   2249           *
   2250           * @return  TRUE if removed, FALSE if not found
   2251           */
   2252          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2253          {
   2254            zclGenSceneItem_t *pLoop;
   2255            zclGenSceneItem_t *pPrev;
   2256          
   2257            // Look for end of list
   2258            pLoop = zclGenSceneTable;
   2259            pPrev = NULL;
   2260            while ( pLoop )
   2261            {
   2262              if ( pLoop->endpoint == endpoint
   2263                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2264              {
   2265                if ( pPrev == NULL )
   2266                  zclGenSceneTable = pLoop->next;
   2267                else
   2268                  pPrev->next = pLoop->next;
   2269          
   2270                // Free the memory
   2271                zcl_mem_free( pLoop );
   2272          
   2273                // Update NV
   2274                zclGeneral_ScenesWriteNV();
   2275          
   2276                return ( TRUE );
   2277              }
   2278              pPrev = pLoop;
   2279              pLoop = pLoop->next;
   2280            }
   2281          
   2282            return ( FALSE );
   2283          }
   2284          #endif // ZCL_STANDALONE
   2285          
   2286          #if !defined ( ZCL_STANDALONE )
   2287          /*********************************************************************
   2288           * @fn      zclGeneral_RemoveAllScenes
   2289           *
   2290           * @brief   Remove all scenes with endpoint and group Id
   2291           *
   2292           * @param   endpoint -
   2293           * @param   groupID - ID to look for group
   2294           *
   2295           * @return  none
   2296           */
   2297          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   2298          {
   2299            zclGenSceneItem_t *pLoop;
   2300            zclGenSceneItem_t *pPrev;
   2301            zclGenSceneItem_t *pNext;
   2302          
   2303            // Look for end of list
   2304            pLoop = zclGenSceneTable;
   2305            pPrev = NULL;
   2306            while ( pLoop )
   2307            {
   2308              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2309              {
   2310                if ( pPrev == NULL )
   2311                  zclGenSceneTable = pLoop->next;
   2312                else
   2313                  pPrev->next = pLoop->next;
   2314                pNext = pLoop->next;
   2315          
   2316                // Free the memory
   2317                zcl_mem_free( pLoop );
   2318                pLoop = pNext;
   2319              }
   2320              else
   2321              {
   2322                pPrev = pLoop;
   2323                pLoop = pLoop->next;
   2324              }
   2325            }
   2326          
   2327            // Update NV
   2328            zclGeneral_ScenesWriteNV();
   2329          }
   2330          #endif // ZCL_STANDALONE
   2331          
   2332          #if !defined ( ZCL_STANDALONE )
   2333          /*********************************************************************
   2334           * @fn      zclGeneral_CountScenes
   2335           *
   2336           * @brief   Count the number of scenes for an endpoint
   2337           *
   2338           * @param   endpoint -
   2339           *
   2340           * @return  number of scenes assigned to an endpoint
   2341           */
   2342          uint8 zclGeneral_CountScenes( uint8 endpoint )
   2343          {
   2344            zclGenSceneItem_t *pLoop;
   2345            uint8 cnt = 0;
   2346          
   2347            // Look for end of list
   2348            pLoop = zclGenSceneTable;
   2349            while ( pLoop )
   2350            {
   2351              if ( pLoop->endpoint == endpoint  )
   2352                cnt++;
   2353              pLoop = pLoop->next;
   2354            }
   2355            return ( cnt );
   2356          }
   2357          #endif
   2358          
   2359          #if !defined ( ZCL_STANDALONE )
   2360          /*********************************************************************
   2361           * @fn      zclGeneral_CountAllScenes
   2362           *
   2363           * @brief   Count the total number of scenes
   2364           *
   2365           * @param   none
   2366           *
   2367           * @return  number of scenes
   2368           */
   2369          uint8 zclGeneral_CountAllScenes( void )
   2370          {
   2371            zclGenSceneItem_t *pLoop;
   2372            uint8 cnt = 0;
   2373          
   2374            // Look for end of list
   2375            pLoop = zclGenSceneTable;
   2376            while ( pLoop )
   2377            {
   2378              cnt++;
   2379              pLoop = pLoop->next;
   2380            }
   2381            return ( cnt );
   2382          }
   2383          #endif // ZCL_STANDALONE
   2384          
   2385          /*********************************************************************
   2386           * @fn      zclGeneral_ReadSceneCountCB
   2387           *
   2388           * @brief   Read the number of scenes currently in the device's
   2389           *          scene table (i.e., the Scene Count attribute).
   2390           *
   2391           *          Note: This function gets called only when the pointer
   2392           *                'dataPtr' to the Scene Count attribute value is
   2393           *                NULL in the attribute database registered with
   2394           *                the ZCL.
   2395           *
   2396           * @param   clusterId - cluster that attribute belongs to
   2397           * @param   attrId - attribute to be read or written
   2398           * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ, or ZCL_OPER_WRITE
   2399           * @param   pValue - pointer to attribute value
   2400           * @param   pLen - pointer to length of attribute value read
   2401           *
   2402           * @return  status
   2403           */
   2404          ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
   2405                                                 uint8 oper, uint8 *pValue, uint16 *pLen )
   2406          {
   2407            ZStatus_t status = ZCL_STATUS_SUCCESS;
   2408          
   2409            // This callback function should only be called for the Scene Count attribute
   2410            switch ( oper )
   2411            {
   2412              case ZCL_OPER_LEN:
   2413                *pLen = 1; // uint8
   2414                break;
   2415          
   2416              case ZCL_OPER_READ:
   2417                *pValue = zclGeneral_CountAllScenes();
   2418          
   2419                if ( pLen != NULL )
   2420                {
   2421                  *pLen = 1;
   2422                }
   2423                break;
   2424          
   2425              case ZCL_OPER_WRITE:
   2426                // Fall through
   2427          
   2428              default:
   2429                status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
   2430                break;
   2431            }
   2432          
   2433            return ( status );
   2434          }
   2435          
   2436          /*********************************************************************
   2437           * @fn      zclGeneral_ProcessInScenesServer
   2438           *
   2439           * @brief   Process in the received Scenes Command.
   2440           *
   2441           * @param   pInMsg - pointer to the incoming message
   2442           *
   2443           * @return  ZStatus_t
   2444           */
   2445          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   2446                                                             zclGeneral_AppCallbacks_t *pCBs )
   2447          {
   2448            zclGeneral_Scene_t scene;
   2449            zclGeneral_Scene_t *pScene;
   2450            uint8 *pData = pInMsg->pData;
   2451            uint8 nameLen;
   2452            uint8 status;
   2453            uint8 sceneCnt = 0;
   2454            uint8 *sceneList = NULL;
   2455            uint8 sendRsp = TRUE;
   2456            uint8 nameSupport = FALSE;
   2457            ZStatus_t stat = ZSuccess;
   2458          
   2459            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2460          
   2461            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2462            pData += 2;   // Move past group ID
   2463            scene.ID = *pData++;
   2464          
   2465            switch ( pInMsg->hdr.commandID )
   2466            {
   2467              case COMMAND_SCENE_ADD:
   2468          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2469              case COMMAND_SCENE_ENHANCED_ADD:
   2470          #endif // ZCL_LIGHT_LINK_ENHANCE
   2471                // Parse the rest of the incoming message
   2472                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2473                pData += 2;
   2474          
   2475                if ( pInMsg->hdr.commandID == COMMAND_SCENE_ENHANCED_ADD )
   2476                {
   2477                  // Received transition time is in 1/10 second
   2478                  scene.transTime100ms = scene.transTime % 10;
   2479                  scene.transTime /= 10;
   2480                }
   2481          
   2482                nameLen= *pData++; // Name length
   2483          
   2484                // Retrieve Name Support attribute
   2485                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES,
   2486                                  ATTRID_SCENES_NAME_SUPPORT, &nameSupport, NULL );
   2487          
   2488                if ( nameSupport )
   2489                {
   2490                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2491                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2492                  scene.name[0] = nameLen;
   2493                  zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2494                }
   2495          
   2496                pData += nameLen; // move past name, use original length
   2497          
   2498                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2499                if ( scene.extLen > 0 )
   2500                {
   2501                  // Copy the extention field(s)
   2502                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2503                  {
   2504                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2505                  }
   2506                  zcl_memcpy( scene.extField, pData, scene.extLen );
   2507                }
   2508          
   2509                if ( scene.groupID == 0x0000 ||
   2510                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2511                {
   2512                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2513                  // does and the corresponding Group exits
   2514                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2515                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2516                  {
   2517                    status = ZCL_STATUS_SUCCESS;
   2518                    if ( pScene != NULL )
   2519                    {
   2520                      // The Scene already exists so update it
   2521                      pScene->transTime = scene.transTime;
   2522                      zcl_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2523          
   2524                      // Use the new extention field(s)
   2525                      zcl_memcpy( pScene->extField, scene.extField, scene.extLen );
   2526                      pScene->extLen = scene.extLen;
   2527          
   2528                      // Save Scenes
   2529                      zclGeneral_ScenesSave();
   2530                    }
   2531                    else
   2532                    {
   2533                      // The Scene doesn't exist so add it
   2534                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2535                    }
   2536                  }
   2537                  else
   2538                  {
   2539                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2540                  }
   2541                }
   2542                else
   2543                {
   2544                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2545                }
   2546          
   2547                if ( UNICAST_MSG( pInMsg->msg ) )
   2548                {
   2549                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_ADD )
   2550                  {
   2551                    zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2552                                                    status, scene.groupID, scene.ID,
   2553                                                    true, pInMsg->hdr.transSeqNum );
   2554                  }
   2555          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2556                  else // COMMAND_SCENE_ENHANCED_ADD
   2557                  {
   2558                    zclGeneral_SendSceneEnhancedAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2559                                                            status, scene.groupID, scene.ID,
   2560                                                            true, pInMsg->hdr.transSeqNum );
   2561                  }
   2562          #endif // ZCL_LIGHT_LINK_ENHANCE
   2563                }
   2564                stat = ZCL_STATUS_CMD_HAS_RSP;
   2565          
   2566                break;
   2567          
   2568              case COMMAND_SCENE_VIEW:
   2569          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2570              case COMMAND_SCENE_ENHANCED_VIEW:
   2571          #endif // ZCL_LIGHT_LINK_ENHANCE
   2572                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2573                if ( pScene != NULL )
   2574                {
   2575                  status = ZCL_STATUS_SUCCESS;
   2576                }
   2577                else
   2578                {
   2579                  // Scene not found
   2580                  if ( scene.groupID != 0x0000 &&
   2581                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2582                  {
   2583                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2584                  }
   2585                  else
   2586                  {
   2587                    status = ZCL_STATUS_NOT_FOUND;
   2588                  }
   2589                  pScene = &scene;
   2590                }
   2591          
   2592                if ( UNICAST_MSG( pInMsg->msg ) )
   2593                {
   2594                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_VIEW )
   2595                  {
   2596                    zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2597                                                     status, pScene, true, pInMsg->hdr.transSeqNum );
   2598                  }
   2599          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2600                  else
   2601                  {
   2602                    zclGeneral_SendSceneEnhancedViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2603                                                             status, pScene, true, pInMsg->hdr.transSeqNum );
   2604                  }
   2605          #endif // ZCL_LIGHT_LINK_ENHANCE
   2606                }
   2607                stat = ZCL_STATUS_CMD_HAS_RSP;
   2608                break;
   2609          
   2610              case COMMAND_SCENE_REMOVE:
   2611                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2612                {
   2613                  status = ZCL_STATUS_SUCCESS;
   2614                }
   2615                else
   2616                {
   2617                  // Scene not found
   2618                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2619                  {
   2620                    // The Group is not in the Group Table
   2621                    status = ZCL_STATUS_INVALID_FIELD;
   2622                  }
   2623                  else
   2624                  {
   2625                    status = ZCL_STATUS_NOT_FOUND;
   2626                  }
   2627                }
   2628          
   2629                if ( UNICAST_MSG( pInMsg->msg ) )
   2630                {
   2631                  // Addressed to this device (not to a group) - send a response back
   2632                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2633                                                      status, scene.groupID,
   2634                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2635                }
   2636                stat = ZCL_STATUS_CMD_HAS_RSP;
   2637                break;
   2638          
   2639              case COMMAND_SCENE_REMOVE_ALL:
   2640                if ( scene.groupID == 0x0000 ||
   2641                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2642                {
   2643                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2644                  status = ZCL_STATUS_SUCCESS;
   2645                }
   2646                else
   2647                {
   2648                  status = ZCL_STATUS_INVALID_FIELD;
   2649                }
   2650          
   2651                if ( UNICAST_MSG( pInMsg->msg ) )
   2652                {
   2653                  // Addressed to this device (not to a group) - send a response back
   2654                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2655                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2656                }
   2657                stat = ZCL_STATUS_CMD_HAS_RSP;
   2658                break;
   2659          
   2660              case COMMAND_SCENE_STORE:
   2661                if ( scene.groupID == 0x0000 ||
   2662                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2663                {
   2664                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2665                  // does and the corresponding Group exits
   2666                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2667                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2668                  {
   2669                    uint8 sceneChanged = FALSE;
   2670          
   2671                    status = ZCL_STATUS_SUCCESS;
   2672                    if ( pScene == NULL )
   2673                    {
   2674                      // Haven't been added yet
   2675                      pScene = &scene;
   2676                    }
   2677          
   2678                    if ( pCBs->pfnSceneStoreReq )
   2679                    {
   2680                      zclSceneReq_t req;
   2681          
   2682                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2683                      req.scene = pScene;
   2684          
   2685                      // Get the latest Scene info
   2686                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2687                      {
   2688                        sceneChanged = TRUE;
   2689                      }
   2690                    }
   2691          
   2692                    if ( pScene == &scene )
   2693                    {
   2694                      // The Scene doesn't exist so add it
   2695                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2696                    }
   2697                    else if ( sceneChanged )
   2698                    {
   2699                      // The Scene already exists so update only NV
   2700                      zclGeneral_ScenesSave();
   2701                    }
   2702                  }
   2703                  else
   2704                  {
   2705                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2706                  }
   2707                }
   2708                else
   2709                {
   2710                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2711                }
   2712          
   2713                if ( UNICAST_MSG( pInMsg->msg ) )
   2714                {
   2715                  // Addressed to this device (not to a group) - send a response back
   2716                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2717                                                     status, scene.groupID, scene.ID,
   2718                                                     true, pInMsg->hdr.transSeqNum );
   2719                }
   2720                stat = ZCL_STATUS_CMD_HAS_RSP;
   2721                break;
   2722          
   2723              case COMMAND_SCENE_RECALL:
   2724                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2725                if ( pScene && pCBs->pfnSceneRecallReq )
   2726                {
   2727                  zclSceneReq_t req;
   2728          
   2729                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2730                  req.scene = pScene;
   2731          
   2732                  pCBs->pfnSceneRecallReq( &req );
   2733                }
   2734                // No response
   2735                break;
   2736          
   2737              case COMMAND_SCENE_GET_MEMBERSHIP:
   2738                // Find all the Scenes corresponding to the Group ID
   2739                if ( scene.groupID == 0x0000 ||
   2740                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2741                {
   2742                  // Allocate space for the scene list
   2743                  sceneList = zcl_mem_alloc( ZCL_GEN_MAX_SCENES );
   2744                  if ( sceneList != NULL )
   2745                  {
   2746                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2747                                                                 scene.groupID, sceneList );
   2748                    status = ZCL_STATUS_SUCCESS;
   2749                    if ( ! UNICAST_MSG( pInMsg->msg ) )
   2750                    {
   2751                      // Addressed to the Group - ONLY send a response if an entry within the
   2752                      // Scene Table corresponds to the Group ID
   2753                      if ( sceneCnt == 0 )
   2754                      {
   2755                        sendRsp = FALSE;
   2756                      }
   2757                    }
   2758                  }
   2759                  else
   2760                  {
   2761                    // Couldn't allocate space for the scene list!
   2762                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2763                  }
   2764                }
   2765                else
   2766                {
   2767                  // The Group is not in the Group Table - send a response back
   2768                  status = ZCL_STATUS_INVALID_FIELD;
   2769                }
   2770          
   2771          #ifdef ZCL_LIGHT_LINK_ENHANCE //ZLL allows response to unicast only
   2772                if ( sendRsp && UNICAST_MSG( pInMsg->msg ) )
   2773          #else
   2774                if ( sendRsp )
   2775          #endif //ZCL_LIGHT_LINK_ENHANCE
   2776                {
   2777                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2778                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2779                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2780                }
   2781          
   2782                if ( sceneList != NULL )
   2783                  zcl_mem_free( sceneList );
   2784          
   2785                stat = ZCL_STATUS_CMD_HAS_RSP;
   2786                break;
   2787          
   2788          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2789              case COMMAND_SCENE_COPY:
   2790                {
   2791                  uint8 mode;
   2792                  uint16 groupIDFrom, groupIDTo;
   2793                  uint8 sceneIDFrom, sceneIDTo;
   2794          
   2795                  pData = pInMsg->pData; // different payload format
   2796          
   2797                  mode = *pData++;
   2798                  groupIDFrom = BUILD_UINT16( pData[0], pData[1] ); // from group ID
   2799                  pData += 2;
   2800                  sceneIDFrom = *pData++; // from scene ID
   2801                  groupIDTo = BUILD_UINT16( pData[0], pData[1] ); // to group ID
   2802                  pData += 2;
   2803                  if ( (mode & SCENE_COPY_MODE_ALL_BIT) == 0 )
   2804                  {
   2805                    sceneIDTo = *pData++; // to scene ID
   2806                  }
   2807          
   2808                  // Make sure the groups exist
   2809                  if ( ( aps_FindGroup( pInMsg->msg->endPoint, groupIDFrom ) != NULL ) &&
   2810                       ( aps_FindGroup( pInMsg->msg->endPoint, groupIDTo ) != NULL ) )
   2811                  {
   2812                    // Allocate space for the scene list
   2813                    sceneList = zcl_mem_alloc( (mode & SCENE_COPY_MODE_ALL_BIT) ? ZCL_GEN_MAX_SCENES : 1 );
   2814                    if ( sceneList == NULL )
   2815                    {
   2816                      status = ZCL_STATUS_INSUFFICIENT_SPACE; // Couldn't allocate space for the scene list!
   2817                    }
   2818                    else
   2819                    {
   2820                      status = ZCL_STATUS_SUCCESS;
   2821                      if ( mode & SCENE_COPY_MODE_ALL_BIT ) // Copy all scenes
   2822                      {
   2823                        sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2824                                                                     groupIDFrom, sceneList );
   2825                      }
   2826                      else // Copy single scene
   2827                      {
   2828                        // Make sure the scene exists
   2829                        pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneIDFrom );
   2830                        if ( pScene != NULL )
   2831                        {
   2832                          sceneList[0] = sceneIDFrom;
   2833                          sceneCnt = 1;
   2834                        }
   2835                        else
   2836                        {
   2837                          status = ZCL_STATUS_INVALID_FIELD; // Scene not found
   2838                        }
   2839                      }
   2840                    }
   2841          
   2842                    if ( status == ZCL_STATUS_SUCCESS )
   2843                    {
   2844                      uint8 numScenesToAdd = 0;
   2845                      uint8 i;
   2846                      for ( i = 0; i < sceneCnt; i++ )
   2847                      {
   2848                        if ( zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, sceneList[i] ) == NULL )
   2849                        {
   2850                          numScenesToAdd++;
   2851                        }
   2852                      }
   2853                      if ( zclGeneral_ScenesRemaingCapacity() >= numScenesToAdd )
   2854                      {
   2855                        // Copy the scenes
   2856                        for ( i = 0; i < sceneCnt; i++ )
   2857                        {
   2858                          // Ignore scene ID from and scene ID to fields
   2859                          pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneList[i] );
   2860                          if ( pScene != NULL )
   2861                          {
   2862                            zclGeneral_Scene_t *pToScene;
   2863                            scene = *pScene;
   2864                            scene.groupID = groupIDTo;
   2865                            scene.ID = ( (mode & SCENE_COPY_MODE_ALL_BIT) ? sceneList[i] : sceneIDTo );
   2866          
   2867                            pToScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2868                            if( pToScene != NULL )
   2869                            {
   2870                              zclGeneral_RemoveScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2871                            }
   2872                            // Add the scene
   2873                            zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2874                          }
   2875                        }
   2876                      }
   2877                      else
   2878                      {
   2879                        status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2880                      }
   2881                    }
   2882                  }
   2883                  else
   2884                  {
   2885                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2886                  }
   2887          
   2888                  if ( UNICAST_MSG( pInMsg->msg ) )
   2889                  {
   2890                    if ( pScene == NULL )
   2891                    {
   2892                      pScene = &scene;
   2893                    }
   2894                    // Addressed to this device (not to a group) - send a response back
   2895                    zclGeneral_SendSceneCopyResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2896                                                      status, pScene->groupID, pScene->ID,
   2897                                                      true, pInMsg->hdr.transSeqNum );
   2898                  }
   2899          
   2900                  if ( sceneList != NULL )
   2901                  {
   2902                    zcl_mem_free( sceneList );
   2903                  }
   2904                }
   2905          
   2906                stat = ZCL_STATUS_CMD_HAS_RSP;
   2907                break;
   2908          #endif // ZCL_LIGHT_LINK_ENHANCE
   2909          
   2910              default:
   2911                stat = ZFailure;
   2912              break;
   2913            }
   2914          
   2915            return ( stat );
   2916          }
   2917          
   2918          /*********************************************************************
   2919           * @fn      zclGeneral_ProcessInScenesClient
   2920           *
   2921           * @brief   Process in the received Scenes Command.
   2922           *
   2923           * @param   pInMsg - pointer to the incoming message
   2924           *
   2925           * @return  ZStatus_t
   2926           */
   2927          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2928                                                             zclGeneral_AppCallbacks_t *pCBs )
   2929          {
   2930            zclGeneral_Scene_t scene;
   2931            uint8 *pData = pInMsg->pData;
   2932            uint8 nameLen;
   2933            zclSceneRsp_t rsp;
   2934            uint8 i;
   2935            ZStatus_t stat = ZSuccess;
   2936          
   2937            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2938            zcl_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2939          
   2940            // Get the status field first
   2941            rsp.status = *pData++;
   2942          
   2943            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2944            {
   2945              rsp.capacity = *pData++;
   2946            }
   2947          
   2948            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2949            pData += 2;   // Move past group ID
   2950          
   2951            switch ( pInMsg->hdr.commandID )
   2952            {
   2953              case COMMAND_SCENE_VIEW_RSP:
   2954                // Parse the rest of the incoming message
   2955                scene.ID = *pData++; // Not applicable to Remove All Response command
   2956                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2957                pData += 2;
   2958                nameLen = *pData++; // Name length
   2959                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2960                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2961          
   2962                scene.name[0] = nameLen;
   2963                zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2964          
   2965                pData += nameLen; // move past name, use original length
   2966          
   2967                //*** Do something with the extension field(s)
   2968          
   2969                // Fall through to callback - break is left off intentionally
   2970          
   2971              case COMMAND_SCENE_ADD_RSP:
   2972              case COMMAND_SCENE_REMOVE_RSP:
   2973              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2974              case COMMAND_SCENE_STORE_RSP:
   2975                if ( pCBs->pfnSceneRsp )
   2976                {
   2977                  if ( pInMsg->hdr.commandID != COMMAND_SCENE_REMOVE_ALL_RSP )
   2978                  {
   2979                    scene.ID = *pData++;
   2980                  }
   2981                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2982                  rsp.cmdID = pInMsg->hdr.commandID;
   2983                  rsp.scene = &scene;
   2984          
   2985                  pCBs->pfnSceneRsp( &rsp );
   2986                }
   2987                break;
   2988          
   2989              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2990                {
   2991                  uint8 *sceneList = NULL;
   2992          
   2993                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   2994                  {
   2995                    uint8 sceneCnt = *pData++;
   2996          
   2997                    if ( sceneCnt > 0 )
   2998                    {
   2999                      // Allocate space for the scene list
   3000                      sceneList = zcl_mem_alloc( sceneCnt );
   3001                      if ( sceneList != NULL )
   3002                      {
   3003                        rsp.sceneCnt = sceneCnt;
   3004                        for ( i = 0; i < sceneCnt; i++ )
   3005                          sceneList[i] = *pData++;
   3006                      }
   3007                    }
   3008                  }
   3009          
   3010                  if ( pCBs->pfnSceneRsp )
   3011                  {
   3012                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3013                    rsp.cmdID = pInMsg->hdr.commandID;
   3014                    rsp.sceneList = sceneList;
   3015                    rsp.scene = &scene;
   3016          
   3017                    pCBs->pfnSceneRsp( &rsp);
   3018                  }
   3019          
   3020                  if ( sceneList != NULL )
   3021                  {
   3022                    zcl_mem_free( sceneList );
   3023                  }
   3024                }
   3025                break;
   3026          
   3027              default:
   3028                stat = ZFailure;
   3029                break;
   3030            }
   3031          
   3032            return ( stat );
   3033          }
   3034          #endif // ZCL_SCENES
   3035          
   3036          #ifdef ZCL_ON_OFF
   3037          /*********************************************************************
   3038           * @fn      zclGeneral_ProcessInCmdOnOff
   3039           *
   3040           * @brief   Process in the received On/Off Command.
   3041           *
   3042           * @param   pInMsg - pointer to the incoming message
   3043           *
   3044           * @return  ZStatus_t
   3045           */
   3046          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   3047                                                      zclGeneral_AppCallbacks_t *pCBs )
   3048          {
   3049            ZStatus_t stat = ZSuccess;
   3050          
   3051            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3052            {
   3053              switch ( pInMsg->hdr.commandID )
   3054              {
   3055                case COMMAND_OFF:
   3056                case COMMAND_ON:
   3057                case COMMAND_TOGGLE:
   3058                  if ( pCBs->pfnOnOff )
   3059                  {
   3060                    pCBs->pfnOnOff( pInMsg->hdr.commandID );
   3061                  }
   3062                  break;
   3063          
   3064          #ifdef ZCL_LIGHT_LINK_ENHANCE
   3065                case COMMAND_OFF_WITH_EFFECT:
   3066                  if ( pCBs->pfnOnOff_OffWithEffect )
   3067                  {
   3068                    zclOffWithEffect_t cmd;
   3069          
   3070                    cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3071                    cmd.effectId = pInMsg->pData[0];
   3072                    cmd.effectVariant = pInMsg->pData[1];
   3073          
   3074                    pCBs->pfnOnOff_OffWithEffect( &cmd );
   3075                  }
   3076                  break;
   3077          
   3078                case COMMAND_ON_WITH_RECALL_GLOBAL_SCENE:
   3079                  if ( pCBs->pfnOnOff_OnWithRecallGlobalScene )
   3080                  {
   3081                    pCBs->pfnOnOff_OnWithRecallGlobalScene();
   3082                  }
   3083                  break;
   3084          
   3085                case COMMAND_ON_WITH_TIMED_OFF:
   3086                  if ( pCBs->pfnOnOff_OnWithTimedOff )
   3087                  {
   3088                    zclOnWithTimedOff_t cmd;
   3089          
   3090                    cmd.onOffCtrl.byte = pInMsg->pData[0];
   3091                    cmd.onTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3092                    cmd.offWaitTime = BUILD_UINT16( pInMsg->pData[3], pInMsg->pData[4] );
   3093                    pCBs->pfnOnOff_OnWithTimedOff( &cmd );
   3094                  }
   3095                  break;
   3096          #endif // ZCL_LIGHT_LINK_ENHANCE
   3097          
   3098                default:
   3099                  stat = ZFailure;
   3100                  break;
   3101              }
   3102            }
   3103            // no Client command
   3104          
   3105            return ( stat );
   3106          }
   3107          #endif // ZCL_ON_OFF
   3108          
   3109          #ifdef ZCL_LEVEL_CTRL
   3110          /*********************************************************************
   3111           * @fn      zclGeneral_ProcessInLevelControl
   3112           *
   3113           * @brief   Process in the received Level Control Command.
   3114           *
   3115           * @param   pInMsg - pointer to the incoming message
   3116           *
   3117           * @return  ZStatus_t
   3118           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3119          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInLevelControl:
   3120                                                             zclGeneral_AppCallbacks_t *pCBs )
   3121          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV       A,#-0xc
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3122            uint8 withOnOff = FALSE;
   \   00000A   7800         MOV       R0,#0x0
   3123            ZStatus_t stat = ZSuccess;
   \   00000C   7E00         MOV       R6,#0x0
   3124          
   3125            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   5408         ANL       A,#0x8
   \   000017   6003         JZ        $+5
   \   000019   02....       LJMP      ??zclGeneral_ProcessInLevelControl_0 & 0xFFFF
   3126            {
   3127              switch ( pInMsg->hdr.commandID )
   \   00001C   EA           MOV       A,R2
   \   00001D   2408         ADD       A,#0x8
   \   00001F   F5..         MOV       ?V0,A
   \   000021   E4           CLR       A
   \   000022   3B           ADDC      A,R3
   \   000023   F5..         MOV       ?V1,A
   \   000025   8A82         MOV       DPL,R2
   \   000027   8B83         MOV       DPH,R3
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   6023         JZ        ??zclGeneral_ProcessInLevelControl_1
   \   000033   14           DEC       A
   \   000034   6061         JZ        ??zclGeneral_ProcessInLevelControl_2
   \   000036   14           DEC       A
   \   000037   7003         JNZ       $+5
   \   000039   02....       LJMP      ??zclGeneral_ProcessInLevelControl_3 & 0xFFFF
   \   00003C   14           DEC       A
   \   00003D   7003         JNZ       $+5
   \   00003F   02....       LJMP      ??zclGeneral_ProcessInLevelControl_4 & 0xFFFF
   \   000042   14           DEC       A
   \   000043   600F         JZ        ??zclGeneral_ProcessInLevelControl_5
   \   000045   14           DEC       A
   \   000046   604D         JZ        ??zclGeneral_ProcessInLevelControl_6
   \   000048   14           DEC       A
   \   000049   607B         JZ        ??zclGeneral_ProcessInLevelControl_7
   \   00004B   14           DEC       A
   \   00004C   7003         JNZ       $+5
   \   00004E   02....       LJMP      ??zclGeneral_ProcessInLevelControl_4 & 0xFFFF
   \   000051   02....       LJMP      ??zclGeneral_ProcessInLevelControl_8 & 0xFFFF
   3128              {
   3129                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   3130                  withOnOff = TRUE;
   \                     ??zclGeneral_ProcessInLevelControl_5:
   \   000054   7801         MOV       R0,#0x1
   3131                  // fall through
   3132                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   3133                  if ( pCBs->pfnLevelControlMoveToLevel )
   \                     ??zclGeneral_ProcessInLevelControl_1:
   \   000056   EC           MOV       A,R4
   \   000057   240C         ADD       A,#0xc
   \   000059   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   00005C   7003         JNZ       $+5
   \   00005E   02....       LJMP      ??zclGeneral_ProcessInLevelControl_0 & 0xFFFF
   3134                  {
   3135                    zclLCMoveToLevel_t cmd;
   3136          
   3137                    cmd.level = pInMsg->pData[0];
   \   000061   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000064   85..82       MOV       DPL,?XSP + 0
   \   000067   85..83       MOV       DPH,?XSP + 1
   \   00006A   F0           MOVX      @DPTR,A
   3138          
   3139                    if ( ( cmd.level >= ATTR_LEVEL_MIN_LEVEL ) &&
   3140                         ( cmd.level <= ATTR_LEVEL_MAX_LEVEL ) )
   \   00006B   6023         JZ        ??zclGeneral_ProcessInLevelControl_9
   \   00006D   F4           CPL       A
   \   00006E   6020         JZ        ??zclGeneral_ProcessInLevelControl_9
   3141                    {
   3142                      cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   \   000070   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000073   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000076   E0           MOVX      A,@DPTR
   \   000077   FB           MOV       R3,A
   \   000078   7401         MOV       A,#0x1
   \   00007A   12....       LCALL     ?XSTACK_DISP0_8
   \   00007D   E5..         MOV       A,?V0
   \   00007F   F0           MOVX      @DPTR,A
   \   000080   A3           INC       DPTR
   \   000081   EB           MOV       A,R3
   \   000082   F0           MOVX      @DPTR,A
   3143                      cmd.withOnOff = withOnOff;
   \   000083   7403         MOV       A,#0x3
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   E8           MOV       A,R0
   \   000089   F0           MOVX      @DPTR,A
   3144          
   3145                      pCBs->pfnLevelControlMoveToLevel( &cmd );
   \   00008A                ; Setup parameters for indirect call
   \   00008A   AA..         MOV       R2,?XSP + 0
   \   00008C   AB..         MOV       R3,?XSP + 1
   \   00008E   807A         SJMP      ??zclGeneral_ProcessInLevelControl_10
   3146                    }
   3147                    else
   3148                    {
   3149                      // level range requested is invalid
   3150                      stat = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclGeneral_ProcessInLevelControl_9:
   \   000090   7E87         MOV       R6,#-0x79
   \   000092   02....       LJMP      ??zclGeneral_ProcessInLevelControl_0 & 0xFFFF
   3151                    }
   3152                  }
   3153                  break;
   3154          
   3155                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   3156                  withOnOff = TRUE;
   \                     ??zclGeneral_ProcessInLevelControl_6:
   \   000095   7801         MOV       R0,#0x1
   3157                  // fall through
   3158                case COMMAND_LEVEL_MOVE:
   3159                  if ( pCBs->pfnLevelControlMove )
   \                     ??zclGeneral_ProcessInLevelControl_2:
   \   000097   EC           MOV       A,R4
   \   000098   240E         ADD       A,#0xe
   \   00009A   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   00009D   7003         JNZ       $+5
   \   00009F   02....       LJMP      ??zclGeneral_ProcessInLevelControl_0 & 0xFFFF
   3160                  {
   3161                    zclLCMove_t cmd;
   3162          
   3163                    cmd.moveMode = pInMsg->pData[0];
   \   0000A2   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000A5   C0E0         PUSH      A
   \   0000A7   7404         MOV       A,#0x4
   \   0000A9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AC   D0E0         POP       A
   \   0000AE   12....       LCALL     ?Subroutine17 & 0xFFFF
   3164                    cmd.rate = pInMsg->pData[1];
   \                     ??CrossCallReturnLabel_34:
   \   0000B1   C0E0         PUSH      A
   \   0000B3   7405         MOV       A,#0x5
   \   0000B5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B8   D0E0         POP       A
   \   0000BA   F0           MOVX      @DPTR,A
   3165                    cmd.withOnOff = withOnOff;
   \   0000BB   7406         MOV       A,#0x6
   \   0000BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C0   E8           MOV       A,R0
   \   0000C1   F0           MOVX      @DPTR,A
   3166          
   3167                    pCBs->pfnLevelControlMove( &cmd );
   \   0000C2                ; Setup parameters for indirect call
   \   0000C2   7404         MOV       A,#0x4
   \   0000C4   8041         SJMP      ??zclGeneral_ProcessInLevelControl_11
   3168                  }
   3169                  break;
   3170          
   3171                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   3172                  withOnOff = TRUE;
   \                     ??zclGeneral_ProcessInLevelControl_7:
   \   0000C6   7801         MOV       R0,#0x1
   3173                  // fall through
   3174                case COMMAND_LEVEL_STEP:
   3175                  if ( pCBs->pfnLevelControlStep )
   \                     ??zclGeneral_ProcessInLevelControl_3:
   \   0000C8   EC           MOV       A,R4
   \   0000C9   2410         ADD       A,#0x10
   \   0000CB   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0000CE   6058         JZ        ??zclGeneral_ProcessInLevelControl_0
   3176                  {
   3177                    zclLCStep_t cmd;
   3178          
   3179                    cmd.stepMode = pInMsg->pData[0];
   \   0000D0   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0000D3   C0E0         PUSH      A
   \   0000D5   7407         MOV       A,#0x7
   \   0000D7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DA   D0E0         POP       A
   \   0000DC   12....       LCALL     ?Subroutine17 & 0xFFFF
   3180                    cmd.amount =  pInMsg->pData[1];
   \                     ??CrossCallReturnLabel_35:
   \   0000DF   C0E0         PUSH      A
   \   0000E1   7408         MOV       A,#0x8
   \   0000E3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E6   D0E0         POP       A
   \   0000E8   F0           MOVX      @DPTR,A
   3181                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   \   0000E9   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000EC   A3           INC       DPTR
   \   0000ED   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   0000F0   A3           INC       DPTR
   \   0000F1   E0           MOVX      A,@DPTR
   \   0000F2   FB           MOV       R3,A
   \   0000F3   7409         MOV       A,#0x9
   \   0000F5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F8   E5..         MOV       A,?V0
   \   0000FA   F0           MOVX      @DPTR,A
   \   0000FB   A3           INC       DPTR
   \   0000FC   EB           MOV       A,R3
   \   0000FD   F0           MOVX      @DPTR,A
   3182                    cmd.withOnOff = withOnOff;
   \   0000FE   740B         MOV       A,#0xb
   \   000100   12....       LCALL     ?XSTACK_DISP0_8
   \   000103   E8           MOV       A,R0
   \   000104   F0           MOVX      @DPTR,A
   3183          
   3184                    pCBs->pfnLevelControlStep( &cmd );
   \   000105                ; Setup parameters for indirect call
   \   000105   7407         MOV       A,#0x7
   \                     ??zclGeneral_ProcessInLevelControl_11:
   \   000107   12....       LCALL     ?XSTACK_DISP101_8
   \                     ??zclGeneral_ProcessInLevelControl_10:
   \   00010A   8C82         MOV       DPL,R4
   \   00010C   8D83         MOV       DPH,R5
   3185                  }
   \   00010E   12....       LCALL     ??Subroutine49_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000111   800E         SJMP      ??zclGeneral_ProcessInLevelControl_12
   3186                  break;
   3187          
   3188                case COMMAND_LEVEL_STOP:
   3189                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   3190                  // Both Stop commands are identical
   3191                  if ( pCBs->pfnLevelControlStop )
   \                     ??zclGeneral_ProcessInLevelControl_4:
   \   000113   EC           MOV       A,R4
   \   000114   2412         ADD       A,#0x12
   \   000116   F582         MOV       DPL,A
   \   000118   E4           CLR       A
   \   000119   3D           ADDC      A,R5
   \   00011A   F583         MOV       DPH,A
   \   00011C   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00011F   6007         JZ        ??zclGeneral_ProcessInLevelControl_0
   3192                  {
   3193                    pCBs->pfnLevelControlStop();
   \   000121                ; Setup parameters for indirect call
   \                     ??zclGeneral_ProcessInLevelControl_12:
   \   000121   12....       LCALL     ?CALL_IND
   \   000124   8002         SJMP      ??zclGeneral_ProcessInLevelControl_0
   3194                  }
   3195                  break;
   3196          
   3197                default:
   3198                  stat = ZFailure;
   \                     ??zclGeneral_ProcessInLevelControl_8:
   \   000126   7E01         MOV       R6,#0x1
   3199                  break;
   3200              }
   3201            }
   3202            // no Client command
   3203          
   3204            return ( stat );
   \                     ??zclGeneral_ProcessInLevelControl_0:
   \   000128   EE           MOV       A,R6
   \   000129   F9           MOV       R1,A
   \   00012A   740C         MOV       A,#0xc
   \   00012C   80..         SJMP      ??Subroutine52_0
   3205          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   8A82         MOV       DPL,R2
   \   000005   8B83         MOV       DPH,R3
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FA           MOV       R2,A
   \   000008   A3           INC       DPTR
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   FB           MOV       R3,A
   \   00000B   8A82         MOV       DPL,R2
   \   00000D   8B83         MOV       DPH,R3
   \   00000F   A3           INC       DPTR
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F9           MOV       R1,A
   \   000008   A3           INC       DPTR
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   F583         MOV       DPH,A
   \   00000C   8982         MOV       DPL,R1
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   FA           MOV       R2,A
   \   000001   E4           CLR       A
   \   000002   3D           ADDC      A,R5
   \   000003   FB           MOV       R3,A
   \   000004   EA           MOV       A,R2
   \   000005   FC           MOV       R4,A
   \   000006   EB           MOV       A,R3
   \   000007                REQUIRE ??Subroutine50_0
   \   000007                ; // Fall through to label ??Subroutine50_0

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_RegisterCmdCallbacks::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_RegisterCmdCallbacks

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendIdentify::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentify

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendIdentifyEZModeInvoke::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyEZModeInvoke

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendIdentifyUpdateCommState::?rela`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyUpdateCommState

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendIdentifyQueryResponse::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyQueryResponse

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendGroupRequest::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendGroupRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendAddGroupRequest::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendAddGroupRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendGroupGetMembershipRequest::?re`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendGroupGetMembershipRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendGroupResponse::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendGroupResponse

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendGroupViewResponse::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendGroupViewResponse

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_SendLevelControlMoveToLevelRequest:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendLevelControlMoveToLevelRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendLevelControlMoveRequest::?rela`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendLevelControlMoveRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendLevelControlStepRequest::?rela`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendLevelControlStepRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendLevelControlStopRequest::?rela`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendLevelControlStopRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_HdlIncoming::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlIncoming

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_HdlInSpecificCommands::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlInSpecificCommands

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_ProcessInIdentity::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInIdentity

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_AddGroup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_AddGroup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_ProcessInGroupsServer::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInGroupsServer

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_ProcessInGroupsClient::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInGroupsClient

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_ProcessInLevelControl::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInLevelControl
   3206          #endif // ZCL_LEVEL_CTRL
   3207          
   3208          #ifdef ZCL_ALARMS
   3209          /*********************************************************************
   3210           * @fn      zclGeneral_AddAlarm
   3211           *
   3212           * @brief   Add an alarm for a cluster
   3213           *
   3214           * @param   endpoint -
   3215           * @param   alarm - new alarm item
   3216           *
   3217           * @return  ZStatus_t
   3218           */
   3219          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   3220          {
   3221            zclGenAlarmItem_t *pNewItem;
   3222            zclGenAlarmItem_t *pLoop;
   3223          
   3224            // Fill in the new profile list
   3225            pNewItem = zcl_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   3226            if ( pNewItem == NULL )
   3227              return ( ZMemError );
   3228          
   3229            // Fill in the plugin record.
   3230            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   3231            pNewItem->endpoint =  endpoint;
   3232            zcl_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   3233          
   3234            // Find spot in list
   3235            if (  zclGenAlarmTable == NULL )
   3236            {
   3237              zclGenAlarmTable = pNewItem;
   3238            }
   3239            else
   3240            {
   3241              // Look for end of list
   3242              pLoop = zclGenAlarmTable;
   3243              while ( pLoop->next != NULL )
   3244                pLoop = pLoop->next;
   3245          
   3246              // Put new item at end of list
   3247              pLoop->next = pNewItem;
   3248            }
   3249          
   3250            return ( ZSuccess );
   3251          }
   3252          
   3253          /*********************************************************************
   3254           * @fn      zclGeneral_FindAlarm
   3255           *
   3256           * @brief   Find an alarm with alarmCode and clusterID
   3257           *
   3258           * @param   endpoint -
   3259           * @param   groupID - what group the scene belongs to
   3260           * @param   sceneID - ID to look for scene
   3261           *
   3262           * @return  a pointer to the alarm information, NULL if not found
   3263           */
   3264          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3265          {
   3266            zclGenAlarmItem_t *pLoop;
   3267          
   3268            // Look for the alarm
   3269            pLoop = zclGenAlarmTable;
   3270            while ( pLoop )
   3271            {
   3272              if ( pLoop->endpoint == endpoint &&
   3273                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3274              {
   3275                return ( &(pLoop->alarm) );
   3276              }
   3277              pLoop = pLoop->next;
   3278            }
   3279          
   3280            return ( (zclGeneral_Alarm_t *)NULL );
   3281          }
   3282          
   3283          /*********************************************************************
   3284           * @fn      zclGeneral_FindEarliestAlarm
   3285           *
   3286           * @brief   Find an alarm with the earliest timestamp
   3287           *
   3288           * @param   endpoint -
   3289           *
   3290           * @return  a pointer to the alarm information, NULL if not found
   3291           */
   3292          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   3293          {
   3294            zclGenAlarmItem_t *pLoop;
   3295            zclGenAlarmItem_t earliestAlarm;
   3296            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   3297          
   3298            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   3299          
   3300            // Look for alarm with earliest time
   3301            pLoop = zclGenAlarmTable;
   3302            while ( pLoop )
   3303            {
   3304              if ( pLoop->endpoint == endpoint &&
   3305                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   3306              {
   3307                pEarliestAlarm = pLoop;
   3308              }
   3309              pLoop = pLoop->next;
   3310            }
   3311          
   3312            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   3313              return ( &(pEarliestAlarm->alarm) );
   3314          
   3315            // No alarm
   3316            return ( (zclGeneral_Alarm_t *)NULL );
   3317          }
   3318          
   3319          /*********************************************************************
   3320           * @fn      zclGeneral_ResetAlarm
   3321           *
   3322           * @brief   Remove an alarm with alarmCode and clusterID
   3323           *
   3324           * @param   endpoint -
   3325           * @param   alarmCode -
   3326           * @param   clusterID -
   3327           *
   3328           * @return  TRUE if removed, FALSE if not found
   3329           */
   3330          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3331          {
   3332            zclGenAlarmItem_t *pLoop;
   3333            zclGenAlarmItem_t *pPrev;
   3334          
   3335            // Look for end of list
   3336            pLoop = zclGenAlarmTable;
   3337            pPrev = NULL;
   3338            while ( pLoop )
   3339            {
   3340              if ( pLoop->endpoint == endpoint &&
   3341                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3342              {
   3343                if ( pPrev == NULL )
   3344                  zclGenAlarmTable = pLoop->next;
   3345                else
   3346                  pPrev->next = pLoop->next;
   3347          
   3348                // Free the memory
   3349                zcl_mem_free( pLoop );
   3350          
   3351                // Notify the Application so that if the alarm condition still active then
   3352                // a new notification will be generated, and a new alarm record will be
   3353                // added to the alarm log
   3354                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   3355                return;
   3356              }
   3357              pPrev = pLoop;
   3358              pLoop = pLoop->next;
   3359            }
   3360          }
   3361          
   3362          /*********************************************************************
   3363           * @fn      zclGeneral_ResetAllAlarms
   3364           *
   3365           * @brief   Remove all alarms with endpoint
   3366           *
   3367           * @param   endpoint -
   3368           * @param   notifyApp -
   3369           *
   3370           * @return  none
   3371           */
   3372          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   3373          {
   3374            zclGenAlarmItem_t *pLoop;
   3375            zclGenAlarmItem_t *pPrev;
   3376            zclGenAlarmItem_t *pNext;
   3377          
   3378            // Look for end of list
   3379            pLoop = zclGenAlarmTable;
   3380            pPrev = NULL;
   3381            while ( pLoop )
   3382            {
   3383              if (  pLoop->endpoint == endpoint )
   3384              {
   3385                if ( pPrev == NULL )
   3386                  zclGenAlarmTable = pLoop->next;
   3387                else
   3388                  pPrev->next = pLoop->next;
   3389          
   3390                pNext = pLoop->next;
   3391          
   3392                // Free the memory
   3393                zcl_mem_free( pLoop );
   3394          
   3395                pLoop = pNext;
   3396              }
   3397              else
   3398              {
   3399                pPrev = pLoop;
   3400                pLoop = pLoop->next;
   3401              }
   3402            }
   3403          
   3404            if ( notifyApp )
   3405            {
   3406              // Notify the Application so that if any alarm conditions still active then
   3407              // a new notification will be generated, and a new alarm record will be
   3408              // added to the alarm log
   3409              // zclGeneral_NotifyResetAll(); // callback function?
   3410            }
   3411          }
   3412          
   3413          /*********************************************************************
   3414           * @fn      zclGeneral_ProcessInAlarmsServer
   3415           *
   3416           * @brief   Process in the received Alarms Command.
   3417           *
   3418           * @param   pInMsg - pointer to the incoming message
   3419           *
   3420           * @return  ZStatus_t
   3421           */
   3422          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   3423                                                             zclGeneral_AppCallbacks_t *pCBs )
   3424          {
   3425            zclAlarm_t alarm;
   3426            zclGeneral_Alarm_t *pAlarm;
   3427            uint8 *pData = pInMsg->pData;
   3428            ZStatus_t stat = ZSuccess;
   3429          
   3430            switch ( pInMsg->hdr.commandID )
   3431            {
   3432              case COMMAND_ALARMS_RESET:
   3433                if ( pCBs->pfnAlarm )
   3434                {
   3435                  alarm.cmdID = pInMsg->hdr.commandID;
   3436                  alarm.alarmCode = pData[0];
   3437                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3438          
   3439                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3440                }
   3441                else
   3442                {
   3443                  stat = ZCL_STATUS_FAILURE;
   3444                }
   3445                break;
   3446          
   3447              case COMMAND_ALARMS_RESET_ALL:
   3448                if ( pCBs->pfnAlarm )
   3449                {
   3450                  alarm.cmdID = pInMsg->hdr.commandID;
   3451          
   3452                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3453                }
   3454                else
   3455                {
   3456                  stat = ZCL_STATUS_FAILURE;
   3457                }
   3458                break;
   3459          
   3460              case COMMAND_ALARMS_GET:
   3461                if ( pCBs->pfnAlarm )
   3462                {
   3463                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3464                  alarm.cmdID = pInMsg->hdr.commandID;
   3465          
   3466                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3467          
   3468                  pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   3469                  if ( pAlarm )
   3470                  {
   3471                    // Send a response back
   3472                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3473                                                     ZCL_STATUS_SUCCESS, pAlarm->code,
   3474                                                     pAlarm->clusterID, pAlarm->timeStamp,
   3475                                                     true, pInMsg->hdr.transSeqNum );
   3476                    // Remove the entry from the Alarm table
   3477                    zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   3478                  }
   3479                  else
   3480                  {
   3481                    // Send a response back
   3482                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3483                                                     ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   3484                                                     true, pInMsg->hdr.transSeqNum );
   3485                  }
   3486                  stat = ZCL_STATUS_CMD_HAS_RSP;
   3487                }
   3488                else
   3489                {
   3490                  stat = ZCL_STATUS_FAILURE;
   3491                }
   3492                break;
   3493          
   3494              case COMMAND_ALARMS_RESET_LOG:
   3495                if ( pCBs->pfnAlarm )
   3496                {
   3497                  alarm.cmdID = pInMsg->hdr.commandID;
   3498          
   3499                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3500          
   3501                  zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   3502                }
   3503                else
   3504                {
   3505                  stat = ZCL_STATUS_FAILURE;
   3506                }
   3507                break;
   3508          
   3509          #ifdef SE_UK_EXT
   3510              case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
   3511                if ( pCBs->pfnPublishEventLog )
   3512                {
   3513                  zclPublishEventLog_t eventLog;
   3514          
   3515                  eventLog.logID = *pData++;
   3516                  eventLog.cmdIndex = *pData++;
   3517                  eventLog.totalCmds = *pData++;
   3518          
   3519                  // First try to find out number of Sub Log Payloads
   3520                  eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
   3521                  if ( eventLog.numSubLogs > 0 )
   3522                  {
   3523                    // Try to alloc space for Log Payload
   3524                    eventLog.pLogs = (zclEventLogPayload_t *)zcl_mem_alloc( sizeof( zclEventLogPayload_t ) *
   3525                                                                             eventLog.numSubLogs );
   3526                    if ( eventLog.pLogs != NULL )
   3527                    {
   3528                      // Copy Log Payload
   3529                      for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
   3530                      {
   3531                        eventLog.pLogs[i].eventId = *pData++;
   3532                        eventLog.pLogs[i].eventTime = zcl_build_uint32( pData, 4 );
   3533                        pData += 4;
   3534                      }
   3535                    }
   3536                    else
   3537                    {
   3538                      stat = ZCL_STATUS_SOFTWARE_FAILURE;
   3539                    }
   3540                  }
   3541                  else
   3542                  {
   3543                    eventLog.pLogs = NULL;
   3544                  }
   3545          
   3546                  if ( stat == ZSuccess )
   3547                  {
   3548                    pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
   3549                  }
   3550          
   3551                  if ( eventLog.pLogs != NULL )
   3552                  {
   3553                    zcl_mem_free( eventLog.pLogs );
   3554                  }
   3555                }
   3556                break;
   3557          #endif // SE_UK_EXT
   3558          
   3559              default:
   3560                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3561                break;
   3562            }
   3563          
   3564            return ( stat );
   3565          }
   3566          
   3567          /*********************************************************************
   3568           * @fn      zclGeneral_ProcessInAlarmsClient
   3569           *
   3570           * @brief   Process in the received Alarms Command.
   3571           *
   3572           * @param   pInMsg - pointer to the incoming message
   3573           *
   3574           * @return  ZStatus_t
   3575           */
   3576          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   3577                                                             zclGeneral_AppCallbacks_t *pCBs )
   3578          {
   3579            uint8 *pData = pInMsg->pData;
   3580            zclAlarm_t alarm;
   3581            ZStatus_t stat = ZSuccess;
   3582          
   3583            zcl_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   3584          
   3585            switch ( pInMsg->hdr.commandID )
   3586            {
   3587              case COMMAND_ALARMS_ALARM:
   3588                if ( pCBs->pfnAlarm )
   3589                {
   3590                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3591                  alarm.cmdID = pInMsg->hdr.commandID;
   3592                  alarm.alarmCode = pData[0];
   3593                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3594          
   3595                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3596                }
   3597                else
   3598                {
   3599                  stat = ZCL_STATUS_FAILURE;
   3600                }
   3601                break;
   3602          
   3603              case COMMAND_ALARMS_GET_RSP:
   3604                if ( pCBs->pfnAlarm )
   3605                {
   3606                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3607                  alarm.cmdID = pInMsg->hdr.commandID;
   3608                  alarm.alarmCode = *pData++;
   3609                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   3610          
   3611                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3612                }
   3613                else
   3614                {
   3615                  stat = ZCL_STATUS_FAILURE;
   3616                }
   3617                break;
   3618          
   3619          #ifdef SE_UK_EXT
   3620              case COMMAND_ALARMS_GET_EVENT_LOG:
   3621                if ( pCBs->pfnGetEventLog )
   3622                {
   3623                  zclGetEventLog_t eventLog;
   3624          
   3625                  eventLog.logID = *pData++;
   3626                  eventLog.startTime = zcl_build_uint32( pData, 4 );
   3627                  pData += 4;
   3628                  eventLog.endTime = zcl_build_uint32( pData, 4 );
   3629                  pData += 4;
   3630                  eventLog.numEvents = *pData;
   3631          
   3632                  pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3633                                        &eventLog, pInMsg->hdr.transSeqNum );
   3634                }
   3635                break;
   3636          #endif // SE_UK_EXT
   3637          
   3638              default:
   3639                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3640                break;
   3641            }
   3642          
   3643            return ( stat );
   3644          }
   3645          #endif // ZCL_ALARMS
   3646          
   3647          #ifdef ZCL_LOCATION
   3648          /*********************************************************************
   3649           * @fn      zclGeneral_ProcessInLocationServer
   3650           *
   3651           * @brief   Process in the received Location Command.
   3652           *
   3653           * @param   pInMsg - pointer to the incoming message
   3654           *
   3655           * @return  ZStatus_t
   3656           */
   3657          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   3658                                                               zclGeneral_AppCallbacks_t *pCBs )
   3659          {
   3660            uint8 *pData = pInMsg->pData;
   3661            zclLocation_t cmd;
   3662            ZStatus_t stat = ZSuccess;
   3663          
   3664            zcl_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   3665          
   3666            switch ( pInMsg->hdr.commandID )
   3667            {
   3668              case COMMAND_LOCATION_SET_ABSOLUTE:
   3669                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3670                pData += 2;
   3671                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3672                pData += 2;
   3673                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3674                pData += 2;
   3675                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3676                pData += 2;
   3677                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3678          
   3679                if ( pCBs->pfnLocation )
   3680                {
   3681                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3682                  cmd.cmdID = pInMsg->hdr.commandID;
   3683          
   3684                  // Update the absolute location info
   3685                  pCBs->pfnLocation( &cmd );
   3686                }
   3687                break;
   3688          
   3689              case COMMAND_LOCATION_SET_DEV_CFG:
   3690                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   3691                pData += 2;
   3692                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3693                pData += 2;
   3694                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3695                pData += 2;
   3696                cmd.un.devCfg.numMeasurements = *pData++;
   3697                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3698          
   3699                if ( pCBs->pfnLocation )
   3700                {
   3701                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3702                  cmd.cmdID = pInMsg->hdr.commandID;
   3703          
   3704                  // Update the device configuration info
   3705                  pCBs->pfnLocation( &cmd );
   3706                }
   3707                break;
   3708          
   3709              case COMMAND_LOCATION_GET_DEV_CFG:
   3710                cmd.un.ieeeAddr = pData;
   3711          
   3712                if ( pCBs->pfnLocation )
   3713                {
   3714                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3715                  cmd.cmdID = pInMsg->hdr.commandID;
   3716                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3717          
   3718                  // Retreive the Device Configuration
   3719                  pCBs->pfnLocation( &cmd );
   3720                }
   3721                stat = ZCL_STATUS_CMD_HAS_RSP;
   3722                break;
   3723          
   3724              case COMMAND_LOCATION_GET_DATA:
   3725                cmd.un.loc.bitmap.locByte = *pData++;
   3726                cmd.un.loc.numResponses = *pData++;
   3727          
   3728                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   3729                  zcl_memcpy( cmd.un.loc.targetAddr, pData, 8 );
   3730          
   3731                if ( pCBs->pfnLocation )
   3732                {
   3733                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3734                  cmd.cmdID = pInMsg->hdr.commandID;
   3735                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3736          
   3737                  // Retreive the Location Data
   3738                  pCBs->pfnLocation( &cmd );
   3739                }
   3740                stat = ZCL_STATUS_CMD_HAS_RSP;
   3741                break;
   3742          
   3743              default:
   3744                stat = ZFailure;
   3745                break;
   3746            }
   3747          
   3748            return ( stat );
   3749          }
   3750          
   3751          /*********************************************************************
   3752           * @fn      zclGeneral_ProcessInLocationDataRsp
   3753           *
   3754           * @brief   Process in the received Location Command.
   3755           *
   3756           * @param   pInMsg - pointer to the incoming message
   3757           *
   3758           * @return  ZStatus_t
   3759           */
   3760          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   3761                                                           zclGeneral_AppCallbacks_t *pCBs )
   3762          {
   3763            uint8 *pData = pInMsg->pData;
   3764            zclLocationRsp_t rsp;
   3765          
   3766            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3767          
   3768            if ( pCBs->pfnLocationRsp )
   3769            {
   3770              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   3771                rsp.un.loc.status = *pData++;
   3772          
   3773              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   3774                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   3775              {
   3776                rsp.un.loc.data.type = *pData++;
   3777                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3778                pData += 2;
   3779                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3780                pData += 2;
   3781          
   3782                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   3783                {
   3784                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3785                  pData += 2;
   3786                }
   3787          
   3788                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3789                {
   3790                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3791                  pData += 2;
   3792                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3793                  pData += 2;
   3794                }
   3795          
   3796                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   3797                {
   3798                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3799                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   3800          
   3801                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   3802                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   3803                }
   3804              }
   3805          
   3806              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3807              rsp.cmdID = pInMsg->hdr.commandID;
   3808          
   3809              // Notify the Application
   3810              pCBs->pfnLocationRsp( &rsp );
   3811            }
   3812          }
   3813          
   3814          /*********************************************************************
   3815           * @fn      zclGeneral_ProcessInLocationClient
   3816           *
   3817           * @brief   Process in the received Location Command.
   3818           *
   3819           * @param   pInMsg - pointer to the incoming message
   3820           *
   3821           * @return  ZStatus_t
   3822           */
   3823          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   3824                                                               zclGeneral_AppCallbacks_t *pCBs )
   3825          {
   3826            uint8 *pData = pInMsg->pData;
   3827            zclLocationRsp_t rsp;
   3828            ZStatus_t stat = ZSuccess;
   3829          
   3830            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3831          
   3832            switch ( pInMsg->hdr.commandID )
   3833            {
   3834              case COMMAND_LOCATION_DEV_CFG_RSP:
   3835                if ( pCBs->pfnLocationRsp )
   3836                {
   3837                  rsp.un.devCfg.status = *pData++;
   3838                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   3839                  {
   3840                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   3841                    pData += 2;
   3842                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3843                    pData += 2;
   3844                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3845                    pData += 2;
   3846                    rsp.un.devCfg.data.numMeasurements = *pData++;
   3847                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3848          
   3849                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3850                    rsp.cmdID = pInMsg->hdr.commandID;
   3851          
   3852                    // Notify the Application
   3853                    pCBs->pfnLocationRsp( &rsp );
   3854                  }
   3855                }
   3856                break;
   3857          
   3858              case COMMAND_LOCATION_DATA_RSP:
   3859              case COMMAND_LOCATION_DATA_NOTIF:
   3860              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3861                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3862                break;
   3863          
   3864              case COMMAND_LOCATION_RSSI_PING:
   3865                if ( pCBs->pfnLocationRsp )
   3866                {
   3867                  rsp.un.locationType = *pData;
   3868          
   3869                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3870                  rsp.cmdID = pInMsg->hdr.commandID;
   3871          
   3872                  // Notify the Application
   3873                  pCBs->pfnLocationRsp( &rsp );
   3874                }
   3875                break;
   3876          
   3877              default:
   3878                stat = ZFailure;
   3879                break;
   3880            }
   3881          
   3882            return ( stat );
   3883          }
   3884          #endif // ZCL_LOCATION
   3885          
   3886          #ifdef ZCL_SCENES
   3887          #if !defined ( ZCL_STANDALONE )
   3888          /*********************************************************************
   3889           * @fn      zclGeneral_ScenesInitNV
   3890           *
   3891           * @brief   Initialize the NV Scene Table Items
   3892           *
   3893           * @param   none
   3894           *
   3895           * @return  number of scenes
   3896           */
   3897          static uint8 zclGeneral_ScenesInitNV( void )
   3898          {
   3899            uint8  status;
   3900            uint16 size;
   3901          
   3902            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3903                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3904          
   3905            status = zcl_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3906          
   3907            if ( status != ZSUCCESS )
   3908            {
   3909              zclGeneral_ScenesSetDefaultNV();
   3910            }
   3911          
   3912            return status;
   3913          }
   3914          #endif // ZCL_STANDALONE
   3915          
   3916          #if !defined ( ZCL_STANDALONE )
   3917          /*********************************************************************
   3918           * @fn          zclGeneral_ScenesSetDefaultNV
   3919           *
   3920           * @brief       Write the defaults to NV
   3921           *
   3922           * @param       none
   3923           *
   3924           * @return      none
   3925           */
   3926          static void zclGeneral_ScenesSetDefaultNV( void )
   3927          {
   3928            nvGenScenesHdr_t hdr;
   3929          
   3930            // Initialize the header
   3931            hdr.numRecs = 0;
   3932          
   3933            // Save off the header
   3934            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3935          }
   3936          #endif // ZCL_STANDALONE
   3937          
   3938          #if !defined ( ZCL_STANDALONE )
   3939          /*********************************************************************
   3940           * @fn          zclGeneral_ScenesWriteNV
   3941           *
   3942           * @brief       Save the Scene Table in NV
   3943           *
   3944           * @param       none
   3945           *
   3946           * @return      none
   3947           */
   3948          static void zclGeneral_ScenesWriteNV( void )
   3949          {
   3950            nvGenScenesHdr_t hdr;
   3951            zclGenSceneItem_t *pLoop;
   3952            zclGenSceneNVItem_t item;
   3953          
   3954            hdr.numRecs = 0;
   3955          
   3956            // Look for end of list
   3957            pLoop = zclGenSceneTable;
   3958            while ( pLoop )
   3959            {
   3960              // Build the record
   3961              item.endpoint = pLoop->endpoint;
   3962              zcl_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3963          
   3964              // Save the record to NV
   3965              zcl_nv_write( ZCD_NV_SCENE_TABLE,
   3966                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3967                              sizeof ( zclGenSceneNVItem_t ), &item );
   3968          
   3969              hdr.numRecs++;
   3970          
   3971              pLoop = pLoop->next;
   3972            }
   3973          
   3974            // Save off the header
   3975            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3976          }
   3977          #endif // ZCL_STANDALONE
   3978          
   3979          #if !defined ( ZCL_STANDALONE )
   3980          /*********************************************************************
   3981           * @fn          zclGeneral_ScenesRestoreFromNV
   3982           *
   3983           * @brief       Restore the Scene table from NV
   3984           *
   3985           * @param       none
   3986           *
   3987           * @return      Number of entries restored
   3988           */
   3989          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   3990          {
   3991            uint16 x;
   3992            nvGenScenesHdr_t hdr;
   3993          
   3994            zclGenSceneNVItem_t item;
   3995            uint16 numAdded = 0;
   3996          
   3997            if ( zcl_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   3998            {
   3999              // Read in the device list
   4000              for ( x = 0; x < hdr.numRecs; x++ )
   4001              {
   4002                if ( zcl_nv_read( ZCD_NV_SCENE_TABLE,
   4003                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   4004                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   4005                {
   4006                  // Add the scene
   4007                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   4008                  {
   4009                    numAdded++;
   4010                  }
   4011                }
   4012              }
   4013            }
   4014          
   4015            return ( numAdded );
   4016          }
   4017          #endif // ZCL_STANDALONE
   4018          
   4019          #if !defined ( ZCL_STANDALONE )
   4020          /*********************************************************************
   4021           * @fn          zclGeneral_ScenesInit
   4022           *
   4023           * @brief       Initialize the scenes table
   4024           *
   4025           * @param       none
   4026           *
   4027           * @return      none
   4028           */
   4029          void zclGeneral_ScenesInit( void )
   4030          {
   4031            // Initialize NV items
   4032            zclGeneral_ScenesInitNV();
   4033          
   4034            // Restore the Scene table
   4035            zclGeneral_ScenesRestoreFromNV();
   4036          }
   4037          #endif // ZCL_STANDALONE
   4038          
   4039          #if !defined ( ZCL_STANDALONE )
   4040          /*********************************************************************
   4041           * @fn          zclGeneral_ScenesSave
   4042           *
   4043           * @brief       Save the scenes table
   4044           *
   4045           * @param       none
   4046           *
   4047           * @return      none
   4048           */
   4049          void zclGeneral_ScenesSave( void )
   4050          {
   4051            // Update NV
   4052            zclGeneral_ScenesWriteNV();
   4053          }
   4054          #endif // ZCL_STANDALONE
   4055          
   4056          #endif // ZCL_SCENES
   4057          
   4058          /***************************************************************************
   4059          ****************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     94   zclGeneral_AddGroup
        0     16   -> aps_AddGroup
        0     19   -> osal_memcpy
        0     20   -> zcl_ReadAttrData
      0     10   zclGeneral_HdlInSpecificCommands
        0     10   -> zclGeneral_ProcessInGroupsClient
        0     10   -> zclGeneral_ProcessInGroupsServer
        0     10   -> zclGeneral_ProcessInIdentity
        0     10   -> zclGeneral_ProcessInLevelControl
      2      0   zclGeneral_HdlIncoming
        2      0   -> zclGeneral_HdlInSpecificCommands
      1     63   zclGeneral_ProcessInGroupsClient
        0     50   -> osal_mem_alloc
        0     50   -> osal_mem_free
        0     53   -> osal_memcpy
        0     50   -> osal_memset
      1     91   zclGeneral_ProcessInGroupsServer
        0     74   -> aps_CountAllGroups
        0     74   -> aps_FindAllGroupsForEndpoint
        0     74   -> aps_FindGroup
        0     74   -> aps_RemoveAllGroup
        0     74   -> aps_RemoveGroup
        0     74   -> osal_mem_alloc
        0     74   -> osal_mem_free
        0     74   -> osal_memset
        0     74   -> zclGeneral_AddGroup
        0     81   -> zclGeneral_SendGroupGetMembershipRequest
        0     78   -> zclGeneral_SendGroupResponse
        0     77   -> zclGeneral_SendGroupViewResponse
        0     78   -> zcl_ReadAttrData
        0     81   -> zcl_SendDefaultRspCmd
      0     32   zclGeneral_ProcessInIdentity
        0     18   -> bdb_ZclIdentifyCmdInd
        0     18   -> bdb_ZclIdentifyQueryCmdInd
        0     20   -> zclGeneral_SendIdentifyQueryResponse
        0     22   -> zcl_ReadAttrData
      1     32   zclGeneral_ProcessInLevelControl
      1     14   zclGeneral_RegisterCmdCallbacks
        0     12   -> osal_mem_alloc
        0     14   -> zcl_registerPlugin
      1     37   zclGeneral_SendAddGroupRequest
        0     21   -> osal_mem_alloc
        0     21   -> osal_mem_free
        0     24   -> osal_memcpy
        0     32   -> zcl_SendCommand
      1    112   zclGeneral_SendGroupGetMembershipRequest
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     28   zclGeneral_SendGroupRequest
        0     25   -> zcl_SendCommand
      1    104   zclGeneral_SendGroupResponse
        0     26   -> zcl_SendCommand
      1    110   zclGeneral_SendGroupViewResponse
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     25   -> osal_memcpy
        0     33   -> zcl_SendCommand
      1     25   zclGeneral_SendIdentify
        0     23   -> zcl_SendCommand
      1     25   zclGeneral_SendIdentifyEZModeInvoke
        0     24   -> zcl_SendCommand
      1     43   zclGeneral_SendIdentifyQueryResponse
        0     23   -> zcl_SendCommand
      1     27   zclGeneral_SendIdentifyUpdateCommState
        0     25   -> zcl_SendCommand
      1     28   zclGeneral_SendLevelControlMoveRequest
        0     25   -> zcl_SendCommand
      1     30   zclGeneral_SendLevelControlMoveToLevelRequest
        0     26   -> zcl_SendCommand
      1     32   zclGeneral_SendLevelControlStepRequest
        0     27   -> zcl_SendCommand
      0     24   zclGeneral_SendLevelControlStopRequest
        0     23   -> zcl_SendCommand


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      12  ??Subroutine38_0
       5  ??Subroutine39_0
      10  ??Subroutine40_0
       3  ??Subroutine41_0
       5  ??Subroutine42_0
       5  ??Subroutine43_0
       4  ??Subroutine44_0
       6  ??Subroutine45_0
       5  ??Subroutine46_0
       5  ??Subroutine47_0
      22  ??Subroutine48_0
       9  ??Subroutine49_0
       5  ??Subroutine50_0
       8  ??Subroutine51_0
       3  ??Subroutine52_0
       5  ??Subroutine53_0
       4  ?Subroutine0
      29  ?Subroutine1
      12  ?Subroutine10
       7  ?Subroutine11
       6  ?Subroutine12
       5  ?Subroutine13
      11  ?Subroutine14
      13  ?Subroutine15
       6  ?Subroutine16
       7  ?Subroutine17
      17  ?Subroutine18
       4  ?Subroutine19
       3  ?Subroutine2
      11  ?Subroutine20
       4  ?Subroutine21
       7  ?Subroutine22
      10  ?Subroutine23
       9  ?Subroutine24
       1  ?Subroutine25
      13  ?Subroutine26
       1  ?Subroutine27
       7  ?Subroutine28
      12  ?Subroutine29
       5  ?Subroutine3
       7  ?Subroutine30
       6  ?Subroutine31
      10  ?Subroutine32
       4  ?Subroutine33
      15  ?Subroutine34
       8  ?Subroutine35
       5  ?Subroutine36
      11  ?Subroutine37
      17  ?Subroutine4
       2  ?Subroutine5
      23  ?Subroutine6
       6  ?Subroutine7
      24  ?Subroutine8
      15  ?Subroutine9
       2  zclGenCBs
       1  zclGenPluginRegisted
     166  zclGeneral_AddGroup
       6  zclGeneral_AddGroup::?relay
     232  zclGeneral_HdlInSpecificCommands
       6  zclGeneral_HdlInSpecificCommands::?relay
      33  zclGeneral_HdlIncoming
       6  zclGeneral_HdlIncoming::?relay
     488  zclGeneral_ProcessInGroupsClient
       6  zclGeneral_ProcessInGroupsClient::?relay
     760  zclGeneral_ProcessInGroupsServer
       6  zclGeneral_ProcessInGroupsServer::?relay
     274  zclGeneral_ProcessInIdentity
       6  zclGeneral_ProcessInIdentity::?relay
     302  zclGeneral_ProcessInLevelControl
       6  zclGeneral_ProcessInLevelControl::?relay
     138  zclGeneral_RegisterCmdCallbacks
       6  zclGeneral_RegisterCmdCallbacks::?relay
     233  zclGeneral_SendAddGroupRequest
       6  zclGeneral_SendAddGroupRequest::?relay
     266  zclGeneral_SendGroupGetMembershipRequest
       6  zclGeneral_SendGroupGetMembershipRequest::?relay
     113  zclGeneral_SendGroupRequest
       6  zclGeneral_SendGroupRequest::?relay
     112  zclGeneral_SendGroupResponse
       6  zclGeneral_SendGroupResponse::?relay
     279  zclGeneral_SendGroupViewResponse
       6  zclGeneral_SendGroupViewResponse::?relay
      86  zclGeneral_SendIdentify
       6  zclGeneral_SendIdentify::?relay
     106  zclGeneral_SendIdentifyEZModeInvoke
       6  zclGeneral_SendIdentifyEZModeInvoke::?relay
      83  zclGeneral_SendIdentifyQueryResponse
       6  zclGeneral_SendIdentifyQueryResponse::?relay
     102  zclGeneral_SendIdentifyUpdateCommState
       6  zclGeneral_SendIdentifyUpdateCommState::?relay
     113  zclGeneral_SendLevelControlMoveRequest
       6  zclGeneral_SendLevelControlMoveRequest::?relay
     118  zclGeneral_SendLevelControlMoveToLevelRequest
       6  zclGeneral_SendLevelControlMoveToLevelRequest::?relay
     148  zclGeneral_SendLevelControlStepRequest
       6  zclGeneral_SendLevelControlStepRequest::?relay
      82  zclGeneral_SendLevelControlStopRequest
       6  zclGeneral_SendLevelControlStopRequest::?relay

 
 4 703 bytes in segment BANKED_CODE
   126 bytes in segment BANK_RELAYS
     3 bytes in segment XDATA_Z
 
   126 bytes of CODE     memory
 4 703 bytes of HUGECODE memory
     3 bytes of XDATA    memory

Errors: none
Warnings: none
