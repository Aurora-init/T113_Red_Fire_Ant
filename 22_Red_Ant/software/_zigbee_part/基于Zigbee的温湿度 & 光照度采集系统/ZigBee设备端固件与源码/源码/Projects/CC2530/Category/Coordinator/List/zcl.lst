###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               26/Mar/2023  16:30:24
# Copyright 2004-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Components\stack\zcl\zcl.c
#    Command line       =  
#        -f C:\Users\11148\AppData\Local\Temp\EWCE72.tmp
#        ("D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Components\stack\zcl\zcl.c"
#        -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xZTOOL_P1
#        -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D LCD_SUPPORTED=DEBUG -D
#        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_DISCOVER -D ZCL_WRITE -D
#        ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF -D ZCL_GROUPS -D
#        ZCL_LEVEL_CTRL -D HAL_KEY=TRUE -D xISR_KEYINTERRUPT -D HAL_UART=TRUE
#        -D INT_HEAP_LEN=2048 -D HAL_LCD=TRUE -D HAL_LCD_OLED12864=TRUE -lC
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Coordinator\List"
#        -lA
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Coordinator\List"
#        --diag_suppress Pe001,Pa010 -o
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Coordinator\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Tools\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Tools\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0402
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x5a, 0x69, 0x67, 0x42,
#        0x65,0x65, 0x41, 0x6c, 0x6c, 0x69, 0x61, 0x6e, 0x63, 0x65, 0x30,
#        0x39}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
#        -DENABLE_LED4_DISABLE_S1) -f
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Tools\f8wZCL.cfg"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        & 光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\" -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\hal\include\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\hal\target\CC2530EB\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\hal\userspace\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mac\include\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mac\high_level\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mac\low_level\srf04\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\mt\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\osal\include\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\services\saddr\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\services\sdata\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\af\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\bdb\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\gp\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\nwk\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\sapi\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\sec\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\sys\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\zcl\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\stack\zdo\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\zmac\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Components\zmac\f8w\"
#        -I
#        "D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\..\..\Applications\"
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_China.936
#    List file          =  
#        D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Coordinator\List\zcl.lst
#    Object file        =  
#        D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度
#        &
#        光照度采集系统\ZigBee设备端固件与源码\源码\Projects\CC2530\Category\Coordinator\Obj\zcl.r51
#
###############################################################################

D:\桌面\《ZigBee3.0开发指南》配套资源（附加部分）\课外篇：项目实战\基于Zigbee的温湿度 & 光照度采集系统\ZigBee设备端固件与源码\源码\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2015-09-09 11:51:49 -0700 (Wed, 09 Sep 2015) $
      4            Revision:       $Revision: 44489 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          #include "APS.h"
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52             
     53          #ifdef BDB_REPORTING
     54            #include "bdb_Reporting.h"
     55          #endif
     56          #include "bdb_interface.h"
     57          
     58          #include "zcl_green_power.h"
     59          
     60             
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          /*** Frame Control ***/
     65          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     66          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     67          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     68          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     69          
     70          /*** Attribute Access Control ***/
     71          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     72          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     73          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     74          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     75          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     76          #define zcl_AccessClient( a )         ( (a) & ACCESS_CLIENT )
     77          
     78          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     79          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     80          
     81          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     82                                                  (zclHdr).fc.manuSpecific == 0          && \
     83                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     84          
     85          // Commands that have corresponding responses (ZCL_CMD_WRITE_NO_RSP, does not have response, but must not send default response)
     86          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     87                                                  (cmd) == ZCL_CMD_WRITE                  || \
     88                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     89                                                  (cmd) == ZCL_CMD_WRITE_NO_RSP           || \
     90                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     91                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     92                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     93                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     94                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     95                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     96                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     97          #define  ZCL_VALID_MIN_HEADER_LEN  3
     98          
     99          /*********************************************************************
    100           * CONSTANTS
    101           */
    102          
    103          /*********************************************************************
    104           * TYPEDEFS
    105           */
    106          typedef struct zclLibPlugin
    107          {
    108            struct zclLibPlugin *next;
    109            uint16              startClusterID;    // starting cluster ID
    110            uint16              endClusterID;      // ending cluster ID
    111            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    112          } zclLibPlugin_t;
    113          
    114          // Command record list
    115          typedef struct zclCmdRecsList
    116          {
    117            struct zclCmdRecsList *pNext;
    118            uint8                 endpoint;
    119            uint8                 numCommands;
    120            CONST zclCommandRec_t *pCmdRecs;
    121          } zclCmdRecsList_t;
    122          
    123          
    124          // Cluster option list item
    125          typedef struct zclClusterOptionList
    126          {
    127            struct zclClusterOptionList *next;
    128            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    129            uint8                       numOptions; // Number of the following records
    130            zclOptionRec_t              *options;   // option records
    131          } zclClusterOptionList;
    132          
    133          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    134          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    135          
    136          typedef struct
    137          {
    138            zclParseInProfileCmd_t   pfnParseInProfile;
    139            zclProcessInProfileCmd_t pfnProcessInProfile;
    140          } zclCmdItems_t;
    141          
    142          
    143          // List record for external handler for unhandled ZCL Foundation commands/rsps
    144          typedef struct zclExternalFoundationHandlerList
    145          {
    146              struct zclExternalFoundationHandlerList *next;
    147              uint8 zcl_ExternalTaskID;
    148              uint8 zcl_ExternalEndPoint;
    149          } zclExternalFoundationHandlerList;
    150          
    151          
    152          /*********************************************************************
    153           * GLOBAL VARIABLES
    154           */
    155          
    156          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    158          #endif
    159          
    160          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    161          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    162          
    163          // ZCL Sequence number
    164          //uint8 zcl_SeqNum = 0x00;  //Not longer used, refer to bdb_getZCLFrameCounter() in bdb_interface.h

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    165          uint8 zcl_InSeqNum = 0x00;
   \                     zcl_InSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    166          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    167          uint8 zcl_radius = AF_DEFAULT_RADIUS;
   \                     zcl_radius:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_radius>`
   \   000001                REQUIRE __INIT_XDATA_I
    168          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    169          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    170          
    171          /*********************************************************************
    172           * EXTERNAL VARIABLES
    173           */
    174          
    175          /*********************************************************************
    176           * EXTERNAL FUNCTIONS
    177           */
    178          
    179          /*********************************************************************
    180           * LOCAL VARIABLES
    181           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    182          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    183          
    184          #if defined ( ZCL_DISCOVER )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    185            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
   \                     gpCmdList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    186          #endif
    187          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    189          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    190          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    191          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    192          
    193          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    194          static zclExternalFoundationHandlerList *externalEndPointHandlerList = (zclExternalFoundationHandlerList *)NULL;
   \                     externalEndPointHandlerList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    195          #endif
    196          
    197          /*********************************************************************
    198           * LOCAL FUNCTIONS
    199           */
    200          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    201          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    202          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    203          
    204          #if !defined ( ZCL_STANDALONE )
    205          static uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId );
    206          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg );
    207          #endif // !defined ( ZCL_STANDALONE )
    208          
    209          #if defined ( ZCL_DISCOVER )
    210            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    211          #endif
    212          
    213          zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    214          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    215          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    216          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    217          
    218          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    219          
    220          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    221          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    222          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    223          #endif // ZCL_READ || ZCL_WRITE
    224          
    225          #ifdef ZCL_READ
    226          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    227          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    228          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    229                                                   uint8 *pAttrData, uint16 *pDataLen );
    230          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    231          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    232          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    233          #endif // ZCL_READ
    234          
    235          #ifdef ZCL_WRITE
    236          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    237                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    238          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    239                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    240          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    241          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    242          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    243          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    244          #endif // ZCL_WRITE
    245          
    246          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    247          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    248          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    249          #endif
    250          
    251          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    252          
    253          #ifdef ZCL_DISCOVER
    254          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    255          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    256          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    257          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    258          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    259          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    260          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    261          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    262          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    263          #endif // ZCL_DISCOVER
    264          
    265          /*********************************************************************
    266           * Parse Profile Command Function Table
    267           */
    268          

   \                                 In  segment CODE_C, align 1
    269          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW `??zclParseInReadCmd::?relay`
   \   000002   ....         DW `??zclProcessInReadCmd::?relay`
   \   000004   ....         DW `??zclParseInReadRspCmd::?relay`
   \   000006   ....         DW `??zcl_HandleExternal::?relay`
   \   000008   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000A   ....         DW `??zclProcessInWriteCmd::?relay`
   \   00000C   ....         DW `??zclParseInWriteCmd::?relay`
   \   00000E   ....         DW `??zclProcessInWriteUndividedCmd::?relay`
   \   000010   ....         DW `??zclParseInWriteRspCmd::?relay`
   \   000012   ....         DW `??zcl_HandleExternal::?relay`
   \   000014   ....         DW `??zclParseInWriteCmd::?relay`
   \   000016   ....         DW `??zclProcessInWriteCmd::?relay`
   \   000018   0000         DW 0H
   \   00001A   0000         DW 0H
   \   00001C   0000         DW 0H
   \   00001E   0000         DW 0H
   \   000020   0000         DW 0H
   \   000022   0000         DW 0H
   \   000024   0000         DW 0H
   \   000026   0000         DW 0H
   \   000028   0000         DW 0H
   \   00002A   0000         DW 0H
   \   00002C   ....         DW `??zclParseInDefaultRspCmd::?relay`
   \   00002E   ....         DW `??zcl_HandleExternal::?relay`
   \   000030   ....         DW `??zclParseInDiscAttrsCmd::?relay`
   \   000032   ....         DW `??zclProcessInDiscAttrs::?relay`
   \   000034   ....         DW `??zclParseInDiscAttrsRspCmd::?relay`
   \   000036   ....         DW `??zcl_HandleExternal::?relay`
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   ....         DW `??zclParseInDiscCmdsCmd::?relay`
   \   000046   ....         DW `??zclProcessInDiscCmd::?relay`
   \   000048   ....         DW `??zclParseInDiscCmdsRspCmd::?relay`
   \   00004A   ....         DW `??zcl_HandleExternal::?relay`
   \   00004C   ....         DW `??zclParseInDiscCmdsCmd::?relay`
   \   00004E   ....         DW `??zclProcessInDiscCmd::?relay`
   \   000050   ....         DW `??zclParseInDiscCmdsRspCmd::?relay`
   \   000052   ....         DW `??zcl_HandleExternal::?relay`
   \   000054   ....         DW `??zclParseInDiscAttrsCmd::?relay`
   \   000056   ....         DW `??zclProcessInDiscAttrs::?relay`
   \   000058   ....         DW `??zclParseInDiscAttrsExtRspCmd::?relay`
   \   00005A   ....         DW `??zcl_HandleExternal::?relay`
    270          {
    271          #ifdef ZCL_READ
    272            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    273            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    274          #else
    275            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    276            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    277          #endif // ZCL_READ
    278          
    279          #ifdef ZCL_WRITE
    280            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    281            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    282            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    283            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    284          #else
    285            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    287            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    288            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    289          #endif // ZCL_WRITE
    290          
    291          #ifdef ZCL_REPORTING_DEVICE
    292              /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    293          #else
    294              /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    295          #endif
    296          
    297          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    298              /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    299          #else
    300              /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    301          #endif
    302          
    303          #ifdef ZCL_REPORTING_DEVICE
    304              /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    305          #else
    306              /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    307          #endif
    308          
    309          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
    310              /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    311          #else
    312              /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    313          #endif
    314          
    315          #ifdef ZCL_REPORT_DESTINATION_DEVICE
    316              /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    317          #else
    318              /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    319          #endif
    320          
    321            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    322          
    323          #ifdef ZCL_DISCOVER
    324            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    325            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    326            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    327            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    328            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    329            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    330            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    331            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    332            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    333            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    334            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    335          #else
    336            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    337            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    338            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    339            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    340            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    341            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    342            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    343            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    344            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    345            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    346            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    347          #endif // ZCL_DISCOVER
    348          };
    349          
    350          /*********************************************************************
    351           * PUBLIC FUNCTIONS
    352           *********************************************************************/
    353          
    354          #if !defined ( ZCL_STANDALONE )
    355          /*********************************************************************
    356           * @fn          zcl_Init
    357           *
    358           * @brief       Initialization function for the zcl layer.
    359           *
    360           * @param       task_id - ZCL task id
    361           *
    362           * @return      none
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    365          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    366            zcl_TaskID = task_id;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#zcl_TaskID
   \   000008   F0           MOVX      @DPTR,A
    367          }
   \   000009   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    368          #endif
    369          
    370          #if !defined ( ZCL_STANDALONE )
    371          /*********************************************************************
    372           * @fn          zcl_event_loop
    373           *
    374           * @brief       Event Loop Processor for zcl.
    375           *
    376           * @param       task_id - task id
    377           * @param       events - event bitmap
    378           *
    379           * @return      unprocessed events
    380           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    381          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    382          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000   74EE         MOV       A,#-0x12
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 74
   \   000005   74B6         MOV       A,#-0x4a
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
    383            uint8 *msgPtr;
    384          
    385            (void)task_id;  // Intentionally unreferenced parameter
    386          
    387            if ( events & SYS_EVENT_MSG )
   \   00000E   EB           MOV       A,R3
   \   00000F   5480         ANL       A,#0x80
   \   000011   604E         JZ        ??zcl_event_loop_0
    388            {
    389              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000013                ; Setup parameters for call to function osal_msg_receive
   \   000013   800E         SJMP      ??zcl_event_loop_1
    390              while ( msgPtr != NULL )
    391              {
    392                uint8 dealloc = TRUE;
    393          
    394                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    395                {
    396                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000015                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000015   EE           MOV       A,R6
   \   000016   FA           MOV       R2,A
   \   000017   EF           MOV       A,R7
   \   000018   FB           MOV       R3,A
   \   000019   12....       LCALL     `??zcl_ProcessMessageMSG::?relay`; Banked call to: zcl_ProcessMessageMSG
    397                }
    398                else
    399                {
    400                  uint8 taskID;
    401                  taskID = zcl_getExternalFoundationHandler( (afIncomingMSGPacket_t *)msgPtr );
    402          
    403                  if ( taskID != TASK_NO_TASK )
    404                  {
    405                    // send it to another task to process.
    406                    osal_msg_send( taskID, msgPtr );
    407                    dealloc = FALSE;
    408                  }
    409                }
    410          
    411                // Release the memory
    412                if ( dealloc )
    413                {
    414                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   00001C                ; Setup parameters for call to function osal_msg_deallocate
   \   00001C   EE           MOV       A,R6
   \   00001D   FA           MOV       R2,A
   \   00001E   EF           MOV       A,R7
   \   00001F   FB           MOV       R3,A
   \   000020   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    415                }
    416          
    417                // Next
    418                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   000023                ; Setup parameters for call to function osal_msg_receive
   \   000023   90....       MOV       DPTR,#zcl_TaskID
   \   000026   E0           MOVX      A,@DPTR
   \   000027   F9           MOV       R1,A
   \   000028   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   00002B   8A..         MOV       ?V2,R2
   \   00002D   8B..         MOV       ?V3,R3
   \   00002F   AE..         MOV       R6,?V2
   \   000031   AF..         MOV       R7,?V3
   \   000033   EE           MOV       A,R6
   \   000034   4F           ORL       A,R7
   \   000035   6020         JZ        ??zcl_event_loop_4
   \   000037   8E82         MOV       DPL,R6
   \   000039   8F83         MOV       DPH,R7
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   641A         XRL       A,#0x1a
   \   00003E   60D5         JZ        ??zcl_event_loop_2
   \   000040                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000040   EE           MOV       A,R6
   \   000041   FA           MOV       R2,A
   \   000042   EF           MOV       A,R7
   \   000043   FB           MOV       R3,A
   \   000044   12....       LCALL     `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000047   E9           MOV       A,R1
   \   000048   F9           MOV       R1,A
   \   000049   74FF         MOV       A,#-0x1
   \   00004B   69           XRL       A,R1
   \   00004C   60CE         JZ        ??zcl_event_loop_3
   \   00004E                ; Setup parameters for call to function osal_msg_send
   \   00004E   EE           MOV       A,R6
   \   00004F   FA           MOV       R2,A
   \   000050   EF           MOV       A,R7
   \   000051   FB           MOV       R3,A
   \   000052   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   000055   80CC         SJMP      ??zcl_event_loop_1
    419              }
    420          
    421              // return unprocessed events
    422              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   000057   AA..         MOV       R2,?V0
   \   000059   E5..         MOV       A,?V1
   \   00005B   6480         XRL       A,#0x80
   \   00005D   FB           MOV       R3,A
   \   00005E   02....       LJMP      ??zcl_event_loop_5 & 0xFFFF
    423            }
    424          
    425          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
    426            if ( events & ZCL_DATABUF_SEND )
   \                     ??zcl_event_loop_0:
   \   000061   EA           MOV       A,R2
   \   000062   5420         ANL       A,#0x20
   \   000064   7003         JNZ       $+5
   \   000066   02....       LJMP      ??zcl_event_loop_6 & 0xFFFF
    427            {
    428              gpNotificationMsg_t *gpNotification = NULL;
    429              gpCmdPayloadMsg_t *pCmdPayloadMsgCurr = NULL;
    430              gpd_ID_t gpd_ID;
    431              uint8 *pgpdid;
    432              uint8 entry[PROXY_TBL_ENTRY_LEN];
    433              uint8 appId;
    434              uint8 nwkSeqNum;
    435              uint8 apsSecNum;
    436              uint16 nwkAddr;
    437              
    438              gpNotification = gp_GetHeadNotificationMsg( );
   \   000069                ; Setup parameters for call to function gp_GetHeadNotificationMsg
   \   000069   12....       LCALL     `??gp_GetHeadNotificationMsg::?relay`; Banked call to: gp_GetHeadNotificationMsg
   \   00006C   8A..         MOV       ?V2,R2
   \   00006E   8B..         MOV       ?V3,R3
    439              
    440              if ( gpNotification == NULL )
   \   000070   EA           MOV       A,R2
   \   000071   45..         ORL       A,?V3
   \   000073   7003         JNZ       $+5
   \   000075   02....       LJMP      ??zcl_event_loop_6 & 0xFFFF
    441              {
    442                return 0;
    443              }
    444              
    445              pCmdPayloadMsgCurr = ( gpCmdPayloadMsg_t* ) gpNotification->pMsg ;
   \   000078   EA           MOV       A,R2
   \   000079   240D         ADD       A,#0xd
   \   00007B   F582         MOV       DPL,A
   \   00007D   E4           CLR       A
   \   00007E   35..         ADDC      A,?V3
   \   000080   F583         MOV       DPH,A
   \   000082   12....       LCALL     ??Subroutine188_0 & 0xFFFF
    446              appId = PROXY_TBL_GET_APPLICTION_ID((uint16)*pCmdPayloadMsgCurr->pMsg);
   \                     ??CrossCallReturnLabel_398:
   \   000085   EE           MOV       A,R6
   \   000086   2402         ADD       A,#0x2
   \   000088   12....       LCALL     ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   00008B   12....       LCALL     ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00008E   E0           MOVX      A,@DPTR
   \   00008F   5407         ANL       A,#0x7
   \   000091   F8           MOV       R0,A
    447              
    448              // To save the NIB nwk sequense number and use the GP alias nwk sequence number
    449              // for the GP notification
    450              nwkSeqNum = _NIB.SequenceNum;
   \   000092   90....       MOV       DPTR,#_NIB
   \   000095   E0           MOVX      A,@DPTR
   \   000096   F5..         MOV       ?V7,A
    451              _NIB.SequenceNum = pCmdPayloadMsgCurr->secNum;
   \   000098   8E82         MOV       DPL,R6
   \   00009A   8F83         MOV       DPH,R7
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   90....       MOV       DPTR,#_NIB
   \   0000A0   F0           MOVX      @DPTR,A
    452              
    453              // To save the NIB nwk address and use the GP alias nwk address for the GP notification
    454              nwkAddr = _NIB.nwkDevAddress;
   \   0000A1   90....       MOV       DPTR,#_NIB + 20
   \   0000A4   12....       LCALL     ?Subroutine104 & 0xFFFF
    455              
    456              if( appId == GP_OPT_APP_ID_GPD )
   \                     ??CrossCallReturnLabel_179:
   \   0000A7   702F         JNZ       ??zcl_event_loop_7
    457              {
    458                pgpdid = pCmdPayloadMsgCurr->pMsg + sizeof( uint16 );
   \   0000A9   12....       LCALL     ?Subroutine75 & 0xFFFF
    459                
    460                osal_memcpy( &_NIB.nwkDevAddress, pgpdid, sizeof(uint16) );
   \                     ??CrossCallReturnLabel_122:
   \   0000AC   75..00       MOV       ?V6,#0x0
   \   0000AF                ; Setup parameters for call to function osal_memcpy
   \   0000AF   78..         MOV       R0,#?V4
   \   0000B1   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000B4   7C02         MOV       R4,#0x2
   \   0000B6   7D00         MOV       R5,#0x0
   \   0000B8   7A..         MOV       R2,#(_NIB + 20) & 0xff
   \   0000BA   7B..         MOV       R3,#((_NIB + 20) >> 8) & 0xff
   \   0000BC   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000BF   7403         MOV       A,#0x3
   \   0000C1   12....       LCALL     ?DEALLOC_XSTACK8
    461                gpd_ID.AppID = GP_OPT_APP_ID_GPD;
   \   0000C4   85..82       MOV       DPL,?XSP + 0
   \   0000C7   85..83       MOV       DPH,?XSP + 1
   \   0000CA   E4           CLR       A
   \   0000CB   F0           MOVX      @DPTR,A
    462                osal_memcpy( &gpd_ID.GPDId.SrcID, pgpdid, sizeof( uint32 ) );
   \   0000CC                ; Setup parameters for call to function osal_memcpy
   \   0000CC   78..         MOV       R0,#?V4
   \   0000CE   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000D1   7C04         MOV       R4,#0x4
   \   0000D3   7D00         MOV       R5,#0x0
   \   0000D5   EC           MOV       A,R4
   \   0000D6   8045         SJMP      ??zcl_event_loop_8
    463              }
    464              else if( appId == GP_OPT_APP_ID_IEEE )
   \                     ??zcl_event_loop_7:
   \   0000D8   7402         MOV       A,#0x2
   \   0000DA   68           XRL       A,R0
   \   0000DB   704F         JNZ       ??zcl_event_loop_9
    465              {
    466                pgpdid = pCmdPayloadMsgCurr->pMsg + Z_EXTADDR_LEN;
    467                
    468                osal_revmemcpy( &_NIB.nwkDevAddress,(pCmdPayloadMsgCurr->pMsg + Z_EXTADDR_LEN), sizeof(uint16) );
   \   0000DD                ; Setup parameters for call to function osal_revmemcpy
   \   0000DD   85..82       MOV       DPL,?V0
   \   0000E0   85..83       MOV       DPH,?V1
   \   0000E3   E0           MOVX      A,@DPTR
   \   0000E4   2408         ADD       A,#0x8
   \   0000E6   F5..         MOV       ?V4,A
   \   0000E8   A3           INC       DPTR
   \   0000E9   E0           MOVX      A,@DPTR
   \   0000EA   3400         ADDC      A,#0x0
   \   0000EC   F5..         MOV       ?V5,A
   \   0000EE   75..00       MOV       ?V6,#0x0
   \   0000F1   78..         MOV       R0,#?V4
   \   0000F3   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000F6   7C02         MOV       R4,#0x2
   \   0000F8   7D00         MOV       R5,#0x0
   \   0000FA   7A..         MOV       R2,#(_NIB + 20) & 0xff
   \   0000FC   7B..         MOV       R3,#((_NIB + 20) >> 8) & 0xff
   \   0000FE   12....       LCALL     `??osal_revmemcpy::?relay`; Banked call to: osal_revmemcpy
   \   000101   7403         MOV       A,#0x3
   \   000103   12....       LCALL     ?DEALLOC_XSTACK8
    469                
    470                gpd_ID.AppID = GP_OPT_APP_ID_IEEE;
   \   000106   85..82       MOV       DPL,?XSP + 0
   \   000109   85..83       MOV       DPH,?XSP + 1
   \   00010C   7402         MOV       A,#0x2
   \   00010E   F0           MOVX      @DPTR,A
    471          
    472                pgpdid = pCmdPayloadMsgCurr->pMsg + sizeof( uint16 );
    473                osal_memcpy( gpd_ID.GPDId.GPDExtAddr, pgpdid, Z_EXTADDR_LEN );
   \   00010F                ; Setup parameters for call to function osal_memcpy
   \   00010F   12....       LCALL     ?Subroutine75 & 0xFFFF
    474              }
   \                     ??CrossCallReturnLabel_123:
   \   000112   78..         MOV       R0,#?V4
   \   000114   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000117   7C08         MOV       R4,#0x8
   \   000119   7D00         MOV       R5,#0x0
   \   00011B   7404         MOV       A,#0x4
   \                     ??zcl_event_loop_8:
   \   00011D   12....       LCALL     ?XSTACK_DISP0_8
   \   000120   AA82         MOV       R2,DPL
   \   000122   AB83         MOV       R3,DPH
   \   000124   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000127   7403         MOV       A,#0x3
   \   000129   12....       LCALL     ?DEALLOC_XSTACK8
    475              
    476              gp_getProxyTableByGpId(&gpd_ID, entry, NULL);
   \                     ??zcl_event_loop_9:
   \   00012C                ; Setup parameters for call to function gp_getProxyTableByGpId
   \   00012C   E4           CLR       A
   \   00012D   F5..         MOV       ?V4,A
   \   00012F   F5..         MOV       ?V5,A
   \   000131   78..         MOV       R0,#?V4
   \   000133   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000136   740B         MOV       A,#0xb
   \   000138   12....       LCALL     ?XSTACK_DISP102_8
   \   00013B   7402         MOV       A,#0x2
   \   00013D   12....       LCALL     ?XSTACK_DISP101_8
   \   000140   12....       LCALL     `??gp_getProxyTableByGpId::?relay`; Banked call to: gp_getProxyTableByGpId
   \   000143   7402         MOV       A,#0x2
   \   000145   12....       LCALL     ?DEALLOC_XSTACK8
    477          
    478              if ( PROXY_TBL_GET_ASSIGNED_ALIAS( entry[PROXY_TBL_ENTRY_OPT + 1] ) )
   \   000148   740A         MOV       A,#0xa
   \   00014A   12....       LCALL     ?XSTACK_DISP0_8
   \   00014D   E0           MOVX      A,@DPTR
   \   00014E   A2E5         MOV       C,0xE0 /* A   */.5
   \   000150   502C         JNC       ??zcl_event_loop_10
    479              {
    480                _NIB.nwkDevAddress = 0;
   \   000152   90....       MOV       DPTR,#_NIB + 20
   \   000155   E4           CLR       A
   \   000156   F0           MOVX      @DPTR,A
   \   000157   A3           INC       DPTR
   \   000158   F0           MOVX      @DPTR,A
    481                osal_memcpy( (uint8*)&_NIB.nwkDevAddress, &entry[PROXY_TBL_ENTRY_ALIAS], sizeof(uint16));
   \   000159                ; Setup parameters for call to function osal_memcpy
   \   000159   7414         MOV       A,#0x14
   \   00015B   12....       LCALL     ?XSTACK_DISP0_8
   \   00015E   A982         MOV       R1,DPL
   \   000160   AA83         MOV       R2,DPH
   \   000162   89..         MOV       ?V4,R1
   \   000164   8A..         MOV       ?V5,R2
   \   000166   75..00       MOV       ?V6,#0x0
   \   000169   78..         MOV       R0,#?V4
   \   00016B   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00016E   7C02         MOV       R4,#0x2
   \   000170   7D00         MOV       R5,#0x0
   \   000172   7A..         MOV       R2,#(_NIB + 20) & 0xff
   \   000174   7B..         MOV       R3,#((_NIB + 20) >> 8) & 0xff
   \   000176   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000179   7403         MOV       A,#0x3
   \   00017B   12....       LCALL     ?DEALLOC_XSTACK8
    482              }
    483              
    484              // save aps sequence number
    485              apsSecNum = APS_Counter;
   \                     ??zcl_event_loop_10:
   \   00017E   90....       MOV       DPTR,#APS_Counter
   \   000181   E0           MOVX      A,@DPTR
   \   000182   F5..         MOV       ?V4,A
    486              APS_Counter = pCmdPayloadMsgCurr->secNum;
   \   000184   8E82         MOV       DPL,R6
   \   000186   8F83         MOV       DPH,R7
   \   000188   E0           MOVX      A,@DPTR
   \   000189   90....       MOV       DPTR,#APS_Counter
   \   00018C   F0           MOVX      @DPTR,A
    487              
    488              // Set nwk radius for zcl frame
    489              if ( entry[PROXY_TBL_ENTRY_GRP_RAD] != 0xFF)
   \   00018D   7448         MOV       A,#0x48
   \   00018F   12....       LCALL     ?XSTACK_DISP0_8
   \   000192   E0           MOVX      A,@DPTR
   \   000193   F8           MOV       R0,A
   \   000194   74FF         MOV       A,#-0x1
   \   000196   68           XRL       A,R0
   \   000197   6005         JZ        ??zcl_event_loop_11
    490              {
    491                zcl_radius =  entry[PROXY_TBL_ENTRY_GRP_RAD];
   \   000199   E8           MOV       A,R0
   \   00019A   90....       MOV       DPTR,#zcl_radius
   \   00019D   F0           MOVX      @DPTR,A
    492              }
    493              
    494              zcl_SendCommand( GREEN_POWER_INTERNAL_ENDPOINT, &gpNotification->addr, ZCL_CLUSTER_ID_GREEN_POWER,
    495                                    COMMAND_GP_NOTIFICATION, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    496                                    TRUE, 0,  bdb_getZCLFrameCounter(), pCmdPayloadMsgCurr->lenght, pCmdPayloadMsgCurr->pMsg );
   \                     ??zcl_event_loop_11:
   \   00019E                ; Setup parameters for call to function bdb_getZCLFrameCounter
   \   00019E   12....       LCALL     `??bdb_getZCLFrameCounter::?relay`; Banked call to: bdb_getZCLFrameCounter
   \   0001A1   E9           MOV       A,R1
   \   0001A2   F9           MOV       R1,A
   \   0001A3                ; Setup parameters for call to function zcl_SendCommand
   \   0001A3   85..82       MOV       DPL,?V0
   \   0001A6   85..83       MOV       DPH,?V1
   \   0001A9   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0001AC   8E82         MOV       DPL,R6
   \   0001AE   8F83         MOV       DPH,R7
   \   0001B0   A3           INC       DPTR
   \   0001B1   E0           MOVX      A,@DPTR
   \   0001B2   F5..         MOV       ?V0,A
   \   0001B4   75..00       MOV       ?V1,#0x0
   \   0001B7   78..         MOV       R0,#?V0
   \   0001B9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001BC   E9           MOV       A,R1
   \   0001BD   F5..         MOV       ?V0,A
   \   0001BF   78..         MOV       R0,#?V0
   \   0001C1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001C4   E4           CLR       A
   \   0001C5   F5..         MOV       ?V0,A
   \   0001C7   78..         MOV       R0,#?V0
   \   0001C9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001CC   75..01       MOV       ?V0,#0x1
   \   0001CF   78..         MOV       R0,#?V0
   \   0001D1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001D4   75..00       MOV       ?V0,#0x0
   \   0001D7   78..         MOV       R0,#?V0
   \   0001D9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001DC   75..01       MOV       ?V0,#0x1
   \   0001DF   78..         MOV       R0,#?V0
   \   0001E1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001E4   75..00       MOV       ?V0,#0x0
   \   0001E7   78..         MOV       R0,#?V0
   \   0001E9   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001EC   7C21         MOV       R4,#0x21
   \   0001EE   7D00         MOV       R5,#0x0
   \   0001F0   AA..         MOV       R2,?V2
   \   0001F2   AB..         MOV       R3,?V3
   \   0001F4   79F2         MOV       R1,#-0xe
   \   0001F6   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0001F9   740B         MOV       A,#0xb
   \   0001FB   12....       LCALL     ?DEALLOC_XSTACK8
    497              
    498              // restore nwk radius
    499              zcl_radius = AF_DEFAULT_RADIUS;
   \   0001FE   90....       MOV       DPTR,#zcl_radius
   \   000201   741E         MOV       A,#0x1e
   \   000203   F0           MOVX      @DPTR,A
    500              
    501              // restore aps sequence number
    502              APS_Counter = apsSecNum;
   \   000204   E5..         MOV       A,?V4
   \   000206   90....       MOV       DPTR,#APS_Counter
   \   000209   F0           MOVX      @DPTR,A
    503               
    504              // Restore the NIB nwk sequence number
    505              _NIB.SequenceNum = nwkSeqNum;
   \   00020A   E5..         MOV       A,?V7
   \   00020C   90....       MOV       DPTR,#_NIB
   \   00020F   F0           MOVX      @DPTR,A
    506              
    507              // Restore the NIB nwk address
    508              _NIB.nwkDevAddress = nwkAddr;
   \   000210   90....       MOV       DPTR,#_NIB + 20
   \   000213   E5..         MOV       A,?V8
   \   000215   F0           MOVX      @DPTR,A
   \   000216   A3           INC       DPTR
   \   000217   E5..         MOV       A,?V9
   \   000219   F0           MOVX      @DPTR,A
    509              
    510              gp_NotificationMsgClean( gp_GetPHeadNotification ( ) );
   \   00021A                ; Setup parameters for call to function gp_GetPHeadNotification
   \   00021A   12....       LCALL     `??gp_GetPHeadNotification::?relay`; Banked call to: gp_GetPHeadNotification
   \   00021D                ; Setup parameters for call to function gp_NotificationMsgClean
   \   00021D   12....       LCALL     `??gp_NotificationMsgClean::?relay`; Banked call to: gp_NotificationMsgClean
    511              
    512              if ( gp_GetHeadNotificationMsg ( ) != NULL )
   \   000220                ; Setup parameters for call to function gp_GetHeadNotificationMsg
   \   000220   12....       LCALL     `??gp_GetHeadNotificationMsg::?relay`; Banked call to: gp_GetHeadNotificationMsg
   \   000223   8B..         MOV       ?V1,R3
   \   000225   EA           MOV       A,R2
   \   000226   45..         ORL       A,?V1
   \   000228   6017         JZ        ??zcl_event_loop_6
    513              {
    514                osal_start_timerEx( zcl_TaskID, ZCL_DATABUF_SEND, 50 );
   \   00022A                ; Setup parameters for call to function osal_start_timerEx
   \   00022A   90....       MOV       DPTR,#__Constant_32
   \   00022D   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000230   7A20         MOV       R2,#0x20
   \   000232   7B00         MOV       R3,#0x0
   \   000234   90....       MOV       DPTR,#zcl_TaskID
   \   000237   E0           MOVX      A,@DPTR
   \   000238   F9           MOV       R1,A
   \   000239   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00023C   7404         MOV       A,#0x4
   \   00023E   12....       LCALL     ?DEALLOC_XSTACK8
    515              }
    516            }
    517          #endif
    518          
    519            // Discard unknown events
    520            return 0;
   \                     ??zcl_event_loop_6:
   \   000241   7A00         MOV       R2,#0x0
   \   000243   7B00         MOV       R3,#0x0
   \                     ??zcl_event_loop_5:
   \   000245   744A         MOV       A,#0x4a
   \   000247   12....       LCALL     ?DEALLOC_XSTACK8
   \   00024A   7F0A         MOV       R7,#0xa
   \   00024C   02....       LJMP      ?BANKED_LEAVE_XDATA
    521          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   2402         ADD       A,#0x2
   \   000009   F5..         MOV       ?V4,A
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   3400         ADDC      A,#0x0
   \   00000F   F5..         MOV       ?V5,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V8,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V9,A
   \   000007   E8           MOV       A,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   F5..         MOV       ?V0,A
   \   000002   E4           CLR       A
   \   000003   3F           ADDC      A,R7
   \   000004   F5..         MOV       ?V1,A
   \   000006                ; Setup parameters for call to function afFindEndPointDesc
   \   000006   85..82       MOV       DPL,?V0
   \   000009   F583         MOV       DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine167:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine188_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FE           MOV       R6,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FF           MOV       R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   12....       LCALL     ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   12....       LCALL     ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_374:
   \   000003   F583         MOV       DPH,A
   \   000005   8882         MOV       DPL,R0
   \   000007   22           RET
    522          #endif
    523          
    524          #if !defined ( ZCL_STANDALONE )
    525          /*********************************************************************
    526           * @fn      zcl_registerForMsg
    527           *
    528           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    529           *          messages that aren't processed to one task (if a task is
    530           *          registered).
    531           *
    532           * @param   taskId - task Id of the Application where commands will be sent to
    533           *
    534           * @return  TRUE if task registeration successful, FALSE otherwise
    535           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    536          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    537          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    538            return zcl_addExternalFoundationHandler( taskId, AF_BROADCAST_ENDPOINT );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   7AFF         MOV       R2,#-0x1
   \   000007   02....       LJMP      ?Subroutine1 & 0xFFFF
    539          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL     `??zcl_addExternalFoundationHandler::?relay`; Banked call to: zcl_addExternalFoundationHandler
   \   000003                REQUIRE ??Subroutine179_0
   \   000003                ; // Fall through to label ??Subroutine179_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine179_0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    540          
    541          /*********************************************************************
    542           * @fn      zcl_registerForMsgExt
    543           *
    544           * @brief   This function enables a Task to register to recieve all
    545           *          incoming Foundation Command/Response messages, for a particular
    546           *          End Point, that aren't processed by ZCL.
    547           *
    548           *          NOTE: Any Task registered for a unique end point will take
    549           *          priority over any Task registered with the AF_BROADCAST_ENDPOINT
    550           *          value.  ie. If task A registers for End Point 1, task B registers
    551           *          for AF_BROADCAST_ENDPOINT,  commands addressed to End Point 1 will be
    552           *          sent to Task A and NOT Task B.
    553           *
    554           * @param   taskId - task Id of the Application where commands will be sent to
    555           * @param   endPointId - end point Id of interest
    556           *
    557           * @return  TRUE if task registeration successful, FALSE otherwise
    558           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    559          uint8 zcl_registerForMsgExt( uint8 taskId, uint8 endPointId  )
   \                     zcl_registerForMsgExt:
    560          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    561            return ( zcl_addExternalFoundationHandler( taskId, endPointId  ) );
   \   000005                ; Setup parameters for call to function zcl_addExternalFoundationHandler
   \   000005   02....       LJMP      ?Subroutine1 & 0xFFFF
    562          }
    563          
    564          /*********************************************************************
    565           * @fn      zcl_addExternalFoundationHandler
    566           *
    567           * @brief   This function adds a record to the internal list of external
    568           *          handlers of unhandled incoming Foundation Command/Response messages.
    569           *
    570           * @param   taskId - task Id of the Application where commands will be sent to
    571           * @param   endPointId - end point Id of interest
    572           *
    573           * @return  TRUE if task registeration successful, FALSE otherwise
    574           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    575          uint8 zcl_addExternalFoundationHandler( uint8 taskId, uint8 endPointId  )
   \                     zcl_addExternalFoundationHandler:
    576          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   \   000007   EA           MOV       A,R2
   \   000008   FF           MOV       R7,A
    577            zclExternalFoundationHandlerList *pNewItem;
    578            zclExternalFoundationHandlerList *pLoop;
    579            zclExternalFoundationHandlerList *pLoopPrev;
    580          
    581            // Fill in the new endpoint registrant list
    582            pNewItem = zcl_mem_alloc( sizeof( zclExternalFoundationHandlerList ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A04         MOV       R2,#0x4
   \   00000B   7B00         MOV       R3,#0x0
   \   00000D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
    583            if ( pNewItem == NULL )
   \   000010   EA           MOV       A,R2
   \   000011   4B           ORL       A,R3
   \   000012   6038         JZ        ??zcl_addExternalFoundationHandler_0
    584            {
    585              return ( false );
    586            }
    587          
    588            pNewItem->zcl_ExternalEndPoint = endPointId;
   \   000014   EF           MOV       A,R7
   \   000015   8A82         MOV       DPL,R2
   \   000017   8B83         MOV       DPH,R3
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   F0           MOVX      @DPTR,A
    589            pNewItem->zcl_ExternalTaskID = taskId;
   \   00001D   EE           MOV       A,R6
   \   00001E   8A82         MOV       DPL,R2
   \   000020   8B83         MOV       DPH,R3
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   12....       LCALL     ?Subroutine132 & 0xFFFF
    590            pNewItem->next = NULL;
   \                     ??CrossCallReturnLabel_332:
   \   000027   E4           CLR       A
   \   000028   F0           MOVX      @DPTR,A
   \   000029   A3           INC       DPTR
   \   00002A   F0           MOVX      @DPTR,A
    591          
    592            // Add to the list
    593            if ( externalEndPointHandlerList == NULL )
   \   00002B   90....       MOV       DPTR,#externalEndPointHandlerList
   \   00002E   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   000031   7009         JNZ       ??zcl_addExternalFoundationHandler_1
    594            {
    595              externalEndPointHandlerList = pNewItem;
   \   000033   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000036   EA           MOV       A,R2
   \   000037   F0           MOVX      @DPTR,A
   \   000038   A3           INC       DPTR
   \   000039   EB           MOV       A,R3
   \   00003A   8042         SJMP      ??zcl_addExternalFoundationHandler_2
    596            }
    597            else
    598            {
    599              // make sure no one else tried to register for this endpoint
    600              pLoop = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_1:
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F9           MOV       R1,A
    601              pLoopPrev = externalEndPointHandlerList;
    602          
    603              while ( pLoop != NULL )
    604              {
    605                if ( ( pLoop->zcl_ExternalEndPoint ) == endPointId )
   \                     ??zcl_addExternalFoundationHandler_3:
   \   00003E   8882         MOV       DPL,R0
   \   000040   8983         MOV       DPH,R1
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   6F           XRL       A,R7
   \   000047   7007         JNZ       ??zcl_addExternalFoundationHandler_4
    606                {
    607                  zcl_mem_free(pNewItem);
   \   000049                ; Setup parameters for call to function osal_mem_free
   \   000049   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    608                  return ( false );
   \                     ??zcl_addExternalFoundationHandler_0:
   \   00004C   7900         MOV       R1,#0x0
   \   00004E   8031         SJMP      ??zcl_addExternalFoundationHandler_5
    609                }
    610                pLoopPrev = pLoop;
   \                     ??zcl_addExternalFoundationHandler_4:
   \   000050   E8           MOV       A,R0
   \   000051   FC           MOV       R4,A
   \   000052   E9           MOV       A,R1
   \   000053   FD           MOV       R5,A
    611                pLoop = pLoop->next;
   \   000054   8882         MOV       DPL,R0
   \   000056   8983         MOV       DPH,R1
   \   000058   12....       LCALL     ??Subroutine182_0 & 0xFFFF
    612              }
   \                     ??CrossCallReturnLabel_337:
   \   00005B   70E1         JNZ       ??zcl_addExternalFoundationHandler_3
    613          
    614              if ( endPointId == AF_BROADCAST_ENDPOINT )
   \   00005D   74FF         MOV       A,#-0x1
   \   00005F   6F           XRL       A,R7
   \   000060   700C         JNZ       ??zcl_addExternalFoundationHandler_6
    615              {
    616                // put new registration at the end of the list
    617                pLoopPrev->next = pNewItem;
   \   000062   8C82         MOV       DPL,R4
   \   000064   8D83         MOV       DPH,R5
   \   000066   12....       LCALL     ?Subroutine34 & 0xFFFF
    618                pNewItem->next = NULL;
    619              }
   \                     ??CrossCallReturnLabel_42:
   \   000069   E4           CLR       A
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   A3           INC       DPTR
   \   00006C   8010         SJMP      ??zcl_addExternalFoundationHandler_2
    620              else
    621              {
    622                // put new registration at the front of the list
    623                zclExternalFoundationHandlerList *temp = externalEndPointHandlerList;
   \                     ??zcl_addExternalFoundationHandler_6:
   \   00006E   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000071   12....       LCALL     ??Subroutine183_0 & 0xFFFF
    624                externalEndPointHandlerList = pNewItem;
   \                     ??CrossCallReturnLabel_353:
   \   000074   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000077   12....       LCALL     ?Subroutine34 & 0xFFFF
    625                pNewItem->next = temp;
    626              }
    627            }
   \                     ??CrossCallReturnLabel_43:
   \   00007A   E8           MOV       A,R0
   \   00007B   F0           MOVX      @DPTR,A
   \   00007C   A3           INC       DPTR
   \   00007D   E9           MOV       A,R1
   \                     ??zcl_addExternalFoundationHandler_2:
   \   00007E   F0           MOVX      @DPTR,A
    628          
    629            return ( true );
   \   00007F   7901         MOV       R1,#0x1
   \                     ??zcl_addExternalFoundationHandler_5:
   \   000081   02....       LJMP      ?Subroutine2 & 0xFFFF
    630          
    631          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   12....       LCALL     ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine182_0:
   \   000000   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   000003   E8           MOV       A,R0
   \   000004   49           ORL       A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine183_0:
   \   000000   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_370:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine152:
   \   000000   12....       LCALL     ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   000003   F9           MOV       R1,A
   \   000004   22           RET
    632          
    633          /*********************************************************************
    634           * @fn      zcl_getExternalFoundationHandler
    635           *
    636           * @brief   This function retrieves the Task ID of the task registered
    637           *          to received unhandled incoming Foundation Command/Response messages
    638           *          for a particular End Point ID.
    639           *
    640           * @param   pInMsg - recevied ZCL command
    641           *
    642           * @return  TASK ID of registered task.  If no task is reigistered, it returns
    643           *          TASK_NO_TASK.
    644           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    645          static uint8 zcl_getExternalFoundationHandler( afIncomingMSGPacket_t *pInMsg )
   \                     zcl_getExternalFoundationHandler:
    646          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    647            zclExternalFoundationHandlerList *pLoop;
    648            uint8 addressedEndPointId = pInMsg->endPoint;
   \   000004   EA           MOV       A,R2
   \   000005   12....       LCALL     ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000008   3B           ADDC      A,R3
   \   000009   F583         MOV       DPH,A
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   FA           MOV       R2,A
    649          
    650            // make sure no one else tried to register for this endpoint
    651            pLoop = externalEndPointHandlerList;
   \   00000D   90....       MOV       DPTR,#externalEndPointHandlerList
   \   000010   8004         SJMP      ??zcl_getExternalFoundationHandler_0
    652          
    653            while ( pLoop != NULL )
    654            {
    655              if ( ( ( pLoop->zcl_ExternalEndPoint ) == addressedEndPointId ) ||
    656                   ( ( pLoop->zcl_ExternalEndPoint ) == AF_BROADCAST_ENDPOINT ) )
    657              {
    658                return ( pLoop->zcl_ExternalTaskID );
    659              }
    660              pLoop = pLoop->next;
   \                     ??zcl_getExternalFoundationHandler_1:
   \   000012   8882         MOV       DPL,R0
   \   000014   8983         MOV       DPH,R1
   \                     ??zcl_getExternalFoundationHandler_0:
   \   000016   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   000019   601C         JZ        ??zcl_getExternalFoundationHandler_2
   \   00001B   8882         MOV       DPL,R0
   \   00001D   8983         MOV       DPH,R1
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   FB           MOV       R3,A
   \   000024   EA           MOV       A,R2
   \   000025   6B           XRL       A,R3
   \   000026   6005         JZ        ??zcl_getExternalFoundationHandler_3
   \   000028   74FF         MOV       A,#-0x1
   \   00002A   6B           XRL       A,R3
   \   00002B   70E5         JNZ       ??zcl_getExternalFoundationHandler_1
   \                     ??zcl_getExternalFoundationHandler_3:
   \   00002D   8882         MOV       DPL,R0
   \   00002F   8983         MOV       DPH,R1
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   F9           MOV       R1,A
   \   000035   8002         SJMP      ??zcl_getExternalFoundationHandler_4
    661            }
    662          
    663            return ( TASK_NO_TASK );
   \                     ??zcl_getExternalFoundationHandler_2:
   \   000037   79FF         MOV       R1,#-0x1
   \                     ??zcl_getExternalFoundationHandler_4:
   \   000039   02....       LJMP      ?Subroutine0 & 0xFFFF
    664          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   12....       LCALL     ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_525:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine161:
   \   000000   2414         ADD       A,#0x14
   \   000002   F582         MOV       DPL,A
   \   000004   E4           CLR       A
   \   000005   22           RET
    665          #endif
    666          
    667          #if !defined ( ZCL_STANDALONE )
    668          /*********************************************************************
    669           * @fn      zcl_HandleExternal
    670           *
    671           * @brief
    672           *
    673           * @param   pInMsg - incoming message to process
    674           *
    675           * @return  TRUE
    676           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    677          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    678          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    679            zclIncomingMsg_t *pCmd;
    680            uint8 taskID;
    681          
    682            taskID = zcl_getExternalFoundationHandler( pInMsg->msg );
   \   000009                ; Setup parameters for call to function zcl_getExternalFoundationHandler
   \   000009   8E82         MOV       DPL,R6
   \   00000B   8F83         MOV       DPH,R7
   \   00000D   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_437:
   \   000010   12....       LCALL     `??zcl_getExternalFoundationHandler::?relay`; Banked call to: zcl_getExternalFoundationHandler
   \   000013   E9           MOV       A,R1
   \   000014   F5..         MOV       ?V0,A
    683          
    684            if ( taskID == TASK_NO_TASK )
   \   000016   74FF         MOV       A,#-0x1
   \   000018   65..         XRL       A,?V0
   \   00001A   7003         JNZ       $+5
   \   00001C   02....       LJMP      ??zcl_HandleExternal_0 & 0xFFFF
    685            {
    686              return ( TRUE );
    687            }
    688          
    689            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   00001F                ; Setup parameters for call to function osal_msg_allocate
   \   00001F   7A19         MOV       R2,#0x19
   \   000021   7B00         MOV       R3,#0x0
   \   000023   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
    690            if ( pCmd != NULL )
   \   000026   EA           MOV       A,R2
   \   000027   4B           ORL       A,R3
   \   000028   7003         JNZ       $+5
   \   00002A   02....       LJMP      ??zcl_HandleExternal_0 & 0xFFFF
    691            {
    692              // fill in the message
    693              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   00002D   8A82         MOV       DPL,R2
   \   00002F   8B83         MOV       DPH,R3
   \   000031   7434         MOV       A,#0x34
   \   000033   12....       LCALL     ?Subroutine32 & 0xFFFF
    694              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_37:
   \   000036   A3           INC       DPTR
   \   000037   EA           MOV       A,R2
   \   000038   2402         ADD       A,#0x2
   \   00003A   FC           MOV       R4,A
   \   00003B   E4           CLR       A
   \   00003C   3B           ADDC      A,R3
   \   00003D   FD           MOV       R5,A
   \   00003E   7406         MOV       A,#0x6
   \   000040   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
    695              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000043   8E82         MOV       DPL,R6
   \   000045   8F83         MOV       DPH,R7
   \   000047   12....       LCALL     ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   00004A   12....       LCALL     ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_469:
   \   00004D   8A82         MOV       DPL,R2
   \   00004F   8B83         MOV       DPH,R3
   \   000051   A3           INC       DPTR
   \   000052   A3           INC       DPTR
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   EC           MOV       A,R4
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   A3           INC       DPTR
   \   00005C   ED           MOV       A,R5
   \   00005D   12....       LCALL     ?Subroutine30 & 0xFFFF
    696              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_35:
   \   000060   A3           INC       DPTR
   \   000061   EA           MOV       A,R2
   \   000062   240A         ADD       A,#0xa
   \   000064   FC           MOV       R4,A
   \   000065   E4           CLR       A
   \   000066   3B           ADDC      A,R3
   \   000067   FD           MOV       R5,A
   \   000068   740C         MOV       A,#0xc
   \   00006A   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
    697              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   00006D   8E82         MOV       DPL,R6
   \   00006F   8F83         MOV       DPH,R7
   \   000071   12....       LCALL     ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   000074   C8           XCH       A,R0
   \   000075   12....       LCALL     ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000078   38           ADDC      A,R0
   \   000079   F583         MOV       DPH,A
   \   00007B   E0           MOVX      A,@DPTR
   \   00007C   C0E0         PUSH      A
   \   00007E   EA           MOV       A,R2
   \   00007F   2416         ADD       A,#0x16
   \   000081   F582         MOV       DPL,A
   \   000083   E4           CLR       A
   \   000084   3B           ADDC      A,R3
   \   000085   F583         MOV       DPH,A
   \   000087   D0E0         POP       A
   \   000089   F0           MOVX      @DPTR,A
    698              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00008A   EE           MOV       A,R6
   \   00008B   240C         ADD       A,#0xc
   \   00008D   F8           MOV       R0,A
   \   00008E   E4           CLR       A
   \   00008F   3F           ADDC      A,R7
   \   000090   F9           MOV       R1,A
   \   000091   8882         MOV       DPL,R0
   \   000093   8983         MOV       DPH,R1
   \   000095   12....       LCALL     ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_463:
   \   000098   EA           MOV       A,R2
   \   000099   2417         ADD       A,#0x17
   \   00009B   F582         MOV       DPL,A
   \   00009D   E4           CLR       A
   \   00009E   3B           ADDC      A,R3
   \   00009F   F583         MOV       DPH,A
   \   0000A1   EC           MOV       A,R4
   \   0000A2   F0           MOVX      @DPTR,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   ED           MOV       A,R5
   \   0000A5   F0           MOVX      @DPTR,A
    699              
    700          #ifdef BDB_REPORTING
    701              if(pCmd->zclHdr.commandID == ZCL_CMD_CONFIG_REPORT)
    702              {
    703                bdb_ProcessInConfigReportCmd(pCmd);
    704                osal_msg_deallocate((uint8*)pCmd);
    705                return TRUE;          
    706              }
    707              if(pCmd->zclHdr.commandID == ZCL_CMD_READ_REPORT_CFG)
    708              {
    709                bdb_ProcessInReadReportCfgCmd(pCmd);
    710                osal_msg_deallocate((uint8*)pCmd);
    711                return TRUE;
    712              }
    713          #endif
    714              // Application will free the attrCmd buffer
    715              pInMsg->attrCmd = NULL;
   \   0000A6   8882         MOV       DPL,R0
   \   0000A8   8983         MOV       DPH,R1
   \   0000AA   E4           CLR       A
   \   0000AB   F0           MOVX      @DPTR,A
   \   0000AC   A3           INC       DPTR
   \   0000AD   F0           MOVX      @DPTR,A
    716          
    717              /* send message through task message */
    718              osal_msg_send( taskID, (uint8 *)pCmd );
   \   0000AE                ; Setup parameters for call to function osal_msg_send
   \   0000AE   A9..         MOV       R1,?V0
   \   0000B0   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
    719            }
    720          
    721            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000B3   7901         MOV       R1,#0x1
   \   0000B5   02....       LJMP      ??Subroutine172_0 & 0xFFFF
    722          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine172_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL     ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   12....       LCALL     ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000003   A3           INC       DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine164:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   12....       LCALL     ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   12....       LCALL     ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   000003   F9           MOV       R1,A
   \   000004   8882         MOV       DPL,R0
   \   000006   8983         MOV       DPH,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000003   A3           INC       DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine196_0:
   \   000000   12....       LCALL     ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_532:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine197_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine202_0
   \   000002                ; // Fall through to label ??Subroutine202_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine202_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine203_0
   \   000002                ; // Fall through to label ??Subroutine203_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine203_0:
   \   000000   12....       LCALL     ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_503:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine209_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   22           RET
    723          #endif
    724          
    725          
    726          /*********************************************************************
    727           * @fn          zcl_getRawAFMsg
    728           *
    729           * @brief       Call to get original unprocessed AF message
    730           *              (not parsed by ZCL).
    731           *
    732           *   NOTE:  This function can only be called during a ZCL callback function
    733           *          and the calling function must NOT change any data in the message.
    734           *
    735           * @param       none
    736           *
    737           * @return      pointer to original AF message, NULL if not processing
    738           *              AF message.
    739           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    740          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    741          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    742            return ( rawAFMsg );
   \   000004   90....       MOV       DPTR,#rawAFMsg
   \   000007   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_438:
   \   00000A   80..         SJMP      ?Subroutine0
    743          }
    744          
    745          /*********************************************************************
    746           * @fn          zcl_getParsedTransSeqNum
    747           *
    748           * @brief       Call to the get the transaction sequence number from
    749           *              the incoming message.
    750           *
    751           *   NOTE:  This function can only be called during a ZCL callback function
    752           *          and the calling function must NOT change any data in the message.
    753           *
    754           * @param       none
    755           *
    756           * @return      transaction sequence number.
    757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    758          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    759          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    760            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV       DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009                REQUIRE ?Subroutine0
   \   000009                ; // Fall through to label ?Subroutine0
    761          }
    762          
    763          /*********************************************************************
    764           * @fn          zcl_registerPlugin
    765           *
    766           * @brief       Add a Cluster Library handler
    767           *
    768           * @param       startClusterID - starting cluster ID
    769           * @param       endClusterID - ending cluster ID
    770           * @param       pfnHdlr - function pointer to incoming message handler
    771           *
    772           * @return      ZSuccess if OK
    773           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    774          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    775                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    776          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
    777            zclLibPlugin_t *pNewItem;
    778            zclLibPlugin_t *pLoop;
    779          
    780            // Fill in the new profile list
    781            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV       R2,#0x8
   \   00000F   7B00         MOV       R3,#0x0
   \   000011   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV       ?V2,R2
   \   000016   8B..         MOV       ?V3,R3
   \   000018   A8..         MOV       R0,?V2
   \   00001A   A9..         MOV       R1,?V3
    782            if ( pNewItem == NULL )
   \   00001C   E8           MOV       A,R0
   \   00001D   49           ORL       A,R1
   \   00001E   7004         JNZ       ??zcl_registerPlugin_0
    783            {
    784              return (ZMemError);
   \   000020   7910         MOV       R1,#0x10
   \   000022   8032         SJMP      ??CrossCallReturnLabel_19
    785            }
    786          
    787            // Fill in the plugin record.
    788            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   12....       LCALL     ?Subroutine22 & 0xFFFF
    789            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_17:
   \   000027   12....       LCALL     ?Subroutine130 & 0xFFFF
    790            pNewItem->endClusterID = endClusterID;
    791            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_233:
   \   00002A   740C         MOV       A,#0xc
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   12....       LCALL     ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   12....       LCALL     ??Subroutine170_0 & 0xFFFF
    792          
    793            // Find spot in list
    794            if (  plugins == NULL )
   \                     ??CrossCallReturnLabel_295:
   \   000037   90....       MOV       DPTR,#plugins
   \   00003A   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   00003D   90....       MOV       DPTR,#plugins
   \   000040   6011         JZ        ??zcl_registerPlugin_1
    795            {
    796              plugins = pNewItem;
    797            }
    798            else
    799            {
    800              // Look for end of list
    801              pLoop = plugins;
   \   000042   12....       LCALL     ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000045   8003         SJMP      ??zcl_registerPlugin_2
    802              while ( pLoop->next != NULL )
    803              {
    804                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   000047   EA           MOV       A,R2
   \   000048   FC           MOV       R4,A
   \   000049   EB           MOV       A,R3
    805              }
   \                     ??zcl_registerPlugin_2:
   \   00004A   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   00004D   70F8         JNZ       ??zcl_registerPlugin_3
    806          
    807              // Put new item at end of list
    808              pLoop->next = pNewItem;
   \   00004F   8C82         MOV       DPL,R4
   \   000051   8D83         MOV       DPH,R5
    809            }
   \                     ??zcl_registerPlugin_1:
   \   000053   12....       LCALL     ?Subroutine23 & 0xFFFF
    810          
    811            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_19:
   \   000056   02....       LJMP      ??Subroutine172_0 & 0xFFFF
    812          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine170_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine171_0
   \   000002                ; // Fall through to label ??Subroutine171_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine171_0:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   7900         MOV       R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL     ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   8882         MOV       DPL,R0
   \   000002   8983         MOV       DPH,R1
   \   000004   E4           CLR       A
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   12....       LCALL     ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   00000A   A3           INC       DPTR
   \   00000B   E5..         MOV       A,?V0
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine155:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   A3           INC       DPTR
   \   000001   E5..         MOV       A,?V1
   \   000003   12....       LCALL     ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000006   EE           MOV       A,R6
   \   000007   F0           MOVX      @DPTR,A
   \   000008   A3           INC       DPTR
   \   000009   EF           MOV       A,R7
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   FD           MOV       R5,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005                REQUIRE ??Subroutine173_0
   \   000005                ; // Fall through to label ??Subroutine173_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine173_0:
   \   000000   12....       LCALL     ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_531:
   \   000003   EA           MOV       A,R2
   \   000004   4B           ORL       A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL     ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine153:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   8882         MOV       DPL,R0
   \   000007   8983         MOV       DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine165:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   A3           INC       DPTR
   \   000006   22           RET
    813          
    814          #ifdef ZCL_DISCOVER
    815          /*********************************************************************
    816           * @fn          zcl_registerCmdList
    817           *
    818           * @brief       Register a Command List with ZCL Foundation
    819           *
    820           * @param       endpoint - endpoint the attribute list belongs to
    821           * @param       newCmdList - array of command records
    822           *
    823           * @return      ZSuccess if OK
    824           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    825          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
   \                     zcl_registerCmdList:
    826          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   8A..         MOV       ?V1,R2
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
    827            zclCmdRecsList_t *pNewItem;
    828            zclCmdRecsList_t *pLoop;
    829          
    830            // Fill in the new profile list
    831            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV       R2,#0x6
   \   00000F   7B00         MOV       R3,#0x0
   \   000011   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV       ?V2,R2
   \   000016   8B..         MOV       ?V3,R3
   \   000018   A8..         MOV       R0,?V2
   \   00001A   A9..         MOV       R1,?V3
    832            if ( pNewItem == NULL )
   \   00001C   E8           MOV       A,R0
   \   00001D   49           ORL       A,R1
   \   00001E   7004         JNZ       ??zcl_registerCmdList_0
    833            {
    834              return (ZMemError);
   \   000020   7910         MOV       R1,#0x10
   \   000022   8022         SJMP      ??CrossCallReturnLabel_20
    835            }
    836          
    837            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
   \                     ??zcl_registerCmdList_0:
   \   000024   12....       LCALL     ?Subroutine12 & 0xFFFF
    838            pNewItem->endpoint = endpoint;
    839            pNewItem->numCommands = cmdListSize;
    840            pNewItem->pCmdRecs = newCmdList;
    841          
    842            // Find spot in list
    843            if ( gpCmdList == NULL )
   \                     ??CrossCallReturnLabel_0:
   \   000027   90....       MOV       DPTR,#gpCmdList
   \   00002A   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   00002D   90....       MOV       DPTR,#gpCmdList
   \   000030   6011         JZ        ??zcl_registerCmdList_1
    844            {
    845              gpCmdList = pNewItem;
    846            }
    847            else
    848            {
    849              // Look for end of list
    850              pLoop = gpCmdList;
   \   000032   12....       LCALL     ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000035   8003         SJMP      ??zcl_registerCmdList_2
    851              while ( pLoop->pNext != NULL )
    852              {
    853                pLoop = pLoop->pNext;
   \                     ??zcl_registerCmdList_3:
   \   000037   EA           MOV       A,R2
   \   000038   FC           MOV       R4,A
   \   000039   EB           MOV       A,R3
    854              }
   \                     ??zcl_registerCmdList_2:
   \   00003A   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   00003D   70F8         JNZ       ??zcl_registerCmdList_3
    855          
    856              // Put new item at end of list
    857              pLoop->pNext = pNewItem;
   \   00003F   8C82         MOV       DPL,R4
   \   000041   8D83         MOV       DPH,R5
    858            }
   \                     ??zcl_registerCmdList_1:
   \   000043   12....       LCALL     ?Subroutine23 & 0xFFFF
    859          
    860            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_20:
   \   000046   02....       LJMP      ??Subroutine172_0 & 0xFFFF
    861          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL     ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000003   8882         MOV       DPL,R0
   \   000005   8983         MOV       DPH,R1
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   12....       LCALL     ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   00000C   22           RET
    862          #endif  // ZCL_DISCOVER
    863          
    864          /*********************************************************************
    865           * @fn          zcl_registerAttrList
    866           *
    867           * @brief       Register an Attribute List with ZCL Foundation
    868           *
    869           * @param       endpoint - endpoint the attribute list belongs to
    870           * @param       numAttr - number of attributes in list
    871           * @param       newAttrList - array of Attribute records.
    872           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    873           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    874           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    875           *
    876           * @return      ZSuccess if OK
    877           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    878          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    879          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   8A..         MOV       ?V1,R2
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
    880            zclAttrRecsList *pNewItem;
    881            zclAttrRecsList *pLoop;
    882          
    883            // Fill in the new profile list
    884            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV       R2,#0xa
   \   00000F   7B00         MOV       R3,#0x0
   \   000011   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV       ?V2,R2
   \   000016   8B..         MOV       ?V3,R3
   \   000018   A8..         MOV       R0,?V2
   \   00001A   A9..         MOV       R1,?V3
    885            if ( pNewItem == NULL )
   \   00001C   E8           MOV       A,R0
   \   00001D   49           ORL       A,R1
   \   00001E   7004         JNZ       ??zcl_registerAttrList_0
    886            {
    887              return (ZMemError);
   \   000020   7910         MOV       R1,#0x10
   \   000022   803A         SJMP      ??CrossCallReturnLabel_21
    888            }
    889          
    890            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000024   12....       LCALL     ?Subroutine22 & 0xFFFF
    891            pNewItem->endpoint = endpoint;
    892            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_18:
   \   000027   8882         MOV       DPL,R0
   \   000029   8983         MOV       DPH,R1
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E4           CLR       A
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   12....       LCALL     ?Subroutine26 & 0xFFFF
    893            pNewItem->numAttributes = numAttr;
   \                     ??CrossCallReturnLabel_29:
   \   000034   E5..         MOV       A,?V1
   \   000036   12....       LCALL     ?Subroutine26 & 0xFFFF
    894            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_30:
   \   000039   A3           INC       DPTR
   \   00003A   EE           MOV       A,R6
   \   00003B   F0           MOVX      @DPTR,A
   \   00003C   A3           INC       DPTR
   \   00003D   EF           MOV       A,R7
   \   00003E   F0           MOVX      @DPTR,A
    895          
    896            // Find spot in list
    897            if ( attrList == NULL )
   \   00003F   90....       MOV       DPTR,#attrList
   \   000042   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000045   90....       MOV       DPTR,#attrList
   \   000048   6011         JZ        ??zcl_registerAttrList_1
    898            {
    899              attrList = pNewItem;
    900            }
    901            else
    902            {
    903              // Look for end of list
    904              pLoop = attrList;
   \   00004A   12....       LCALL     ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   00004D   8003         SJMP      ??zcl_registerAttrList_2
    905              while ( pLoop->next != NULL )
    906              {
    907                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   00004F   EA           MOV       A,R2
   \   000050   FC           MOV       R4,A
   \   000051   EB           MOV       A,R3
    908              }
   \                     ??zcl_registerAttrList_2:
   \   000052   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000055   70F8         JNZ       ??zcl_registerAttrList_3
    909          
    910              // Put new item at end of list
    911              pLoop->next = pNewItem;
   \   000057   8C82         MOV       DPL,R4
   \   000059   8D83         MOV       DPH,R5
    912            }
   \                     ??zcl_registerAttrList_1:
   \   00005B   12....       LCALL     ?Subroutine23 & 0xFFFF
    913          
    914            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_21:
   \   00005E   80..         SJMP      ??Subroutine172_0
    915          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL     ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET
    916          
    917          /*********************************************************************
    918           * @fn          zcl_registerClusterOptionList
    919           *
    920           * @brief       Register a Cluster Option List with ZCL Foundation
    921           *
    922           * @param       endpoint - endpoint the option list belongs to
    923           * @param       numOption - number of options in list
    924           * @param       optionList - array of cluster option records.
    925           *
    926           *              NOTE: This API should be called to enable 'Application
    927           *                    Link Key' security and/or 'APS ACK' for a specific
    928           *                    Cluster. The 'Application Link Key' is discarded
    929           *                    if security isn't enabled on the device.
    930           *                    The default behavior is 'Network Key' when security
    931           *                    is enabled and no 'APS ACK' for the ZCL messages.
    932           *
    933           * @return      ZSuccess if OK
    934           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    935          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    936          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   8A..         MOV       ?V1,R2
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
    937            zclClusterOptionList *pNewItem;
    938            zclClusterOptionList *pLoop;
    939          
    940            // Fill in the new profile list
    941            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV       R2,#0x6
   \   00000F   7B00         MOV       R3,#0x0
   \   000011   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV       ?V2,R2
   \   000016   8B..         MOV       ?V3,R3
   \   000018   A8..         MOV       R0,?V2
   \   00001A   A9..         MOV       R1,?V3
    942            if ( pNewItem == NULL )
   \   00001C   E8           MOV       A,R0
   \   00001D   49           ORL       A,R1
   \   00001E   7004         JNZ       ??zcl_registerClusterOptionList_0
    943            {
    944              return (ZMemError);
   \   000020   7910         MOV       R1,#0x10
   \   000022   8022         SJMP      ??CrossCallReturnLabel_22
    945            }
    946          
    947            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL     ?Subroutine12 & 0xFFFF
    948            pNewItem->endpoint = endpoint;
    949            pNewItem->numOptions = numOption;
    950            pNewItem->options = optionList;
    951          
    952            // Find spot in list
    953            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_1:
   \   000027   90....       MOV       DPTR,#clusterOptionList
   \   00002A   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00002D   90....       MOV       DPTR,#clusterOptionList
   \   000030   6011         JZ        ??zcl_registerClusterOptionList_1
    954            {
    955              clusterOptionList = pNewItem;
    956            }
    957            else
    958            {
    959              // Look for end of list
    960              pLoop = clusterOptionList;
   \   000032   12....       LCALL     ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   000035   8003         SJMP      ??zcl_registerClusterOptionList_2
    961              while ( pLoop->next != NULL )
    962              {
    963                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   000037   EA           MOV       A,R2
   \   000038   FC           MOV       R4,A
   \   000039   EB           MOV       A,R3
    964              }
   \                     ??zcl_registerClusterOptionList_2:
   \   00003A   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   00003D   70F8         JNZ       ??zcl_registerClusterOptionList_3
    965          
    966              // Put new item at end of list
    967              pLoop->next = pNewItem;
   \   00003F   8C82         MOV       DPL,R4
   \   000041   8D83         MOV       DPH,R5
    968            }
   \                     ??zcl_registerClusterOptionList_1:
   \   000043   12....       LCALL     ?Subroutine23 & 0xFFFF
    969          
    970            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_22:
   \   000046   80..         SJMP      ??Subroutine172_0
    971          }
    972          
    973          /*********************************************************************
    974           * @fn          zcl_registerValidateAttrData
    975           *
    976           * @brief       Add a validation function for attribute data
    977           *
    978           * @param       pfnValidateAttrData - function pointer to validate routine
    979           *
    980           * @return      ZSuccess if OK
    981           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    982          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    983          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    984            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV       DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL     ??Subroutine171_0 & 0xFFFF
    985          
    986            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_291:
   \   00000A   7900         MOV       R1,#0x0
   \   00000C   02....       LJMP      ?Subroutine0 & 0xFFFF
    987          }
    988          
    989          /*********************************************************************
    990           * @fn          zcl_registerReadWriteCB
    991           *
    992           * @brief       Register the application's callback function to read/write
    993           *              attribute data, and authorize read/write operation.
    994           *
    995           *              Note: The pfnReadWriteCB callback function is only required
    996           *                    when the attribute data format is unknown to ZCL. The
    997           *                    callback function gets called when the pointer 'dataPtr'
    998           *                    to the attribute value is NULL in the attribute database
    999           *                    registered with the ZCL.
   1000           *
   1001           *              Note: The pfnAuthorizeCB callback function is only required
   1002           *                    when the Read/Write operation on an attribute requires
   1003           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
   1004           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
   1005           *
   1006           * @param       endpoint - application's endpoint
   1007           * @param       pfnReadWriteCB - function pointer to read/write routine
   1008           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
   1009           *
   1010           * @return      ZSuccess if successful. ZFailure, otherwise.
   1011           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1012          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
   1013                                             zclAuthorizeCB_t pfnAuthorizeCB )
   1014          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   1015            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV       ?V4,R2
   \   000012   8B..         MOV       ?V5,R3
   \   000014   A8..         MOV       R0,?V4
   \   000016   A9..         MOV       R1,?V5
   1016          
   1017            if ( pRec != NULL )
   \   000018   E8           MOV       A,R0
   \   000019   49           ORL       A,R1
   \   00001A   6019         JZ        ??zcl_registerReadWriteCB_0
   1018            {
   1019              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00001C   8882         MOV       DPL,R0
   \   00001E   8983         MOV       DPH,R1
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   EE           MOV       A,R6
   \   000024   F0           MOVX      @DPTR,A
   \   000025   A3           INC       DPTR
   \   000026   EF           MOV       A,R7
   \   000027   12....       LCALL     ?Subroutine30 & 0xFFFF
   1020              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_36:
   \   00002A   E5..         MOV       A,?V0
   \   00002C   F0           MOVX      @DPTR,A
   \   00002D   A3           INC       DPTR
   \   00002E   E5..         MOV       A,?V1
   \   000030   F0           MOVX      @DPTR,A
   1021          
   1022              return ( ZSuccess );
   \   000031   7900         MOV       R1,#0x0
   \   000033   8002         SJMP      ??zcl_registerReadWriteCB_1
   1023            }
   1024          
   1025            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000035   7901         MOV       R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000037   02....       LJMP      ?Subroutine4 & 0xFFFF
   1026          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   1027          
   1028          /*********************************************************************
   1029           * @fn      zcl_DeviceOperational
   1030           *
   1031           * @brief   Used to see whether or not the device can send or respond
   1032           *          to application level commands.
   1033           *
   1034           * @param   srcEP - source endpoint
   1035           * @param   clusterID - cluster ID
   1036           * @param   frameType - command type
   1037           * @param   cmd - command ID
   1038           *
   1039           * @return  TRUE if device is operational, FALSE otherwise
   1040           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine172_0
   \   000003                ; // Fall through to label ??Subroutine172_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1041          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
   1042                                              uint8 frameType, uint8 cmd, uint16 profileID )
   1043          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
   \   00000D   FF           MOV       R7,A
   1044            zclAttrRec_t attrRec;
   1045            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7401         MOV       A,#0x1
   \   000016   F0           MOVX      @DPTR,A
   1046          
   1047            (void)profileID;  // Intentionally unreferenced parameter
   1048          
   1049            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
   1050            // cannot send or respond to application level commands, other than commands
   1051            // to read or write attributes. Note that the Identify cluster cannot be
   1052            // disabled, and remains functional regardless of this setting.
   1053            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000017   EF           MOV       A,R7
   \   000018   7006         JNZ       ??zcl_DeviceOperational_0
   \   00001A   ED           MOV       A,R5
   \   00001B   C3           CLR       C
   \   00001C   9406         SUBB      A,#0x6
   \   00001E   4050         JC        ??zcl_DeviceOperational_1
   1054            {
   1055              return ( TRUE );
   1056            }
   1057          
   1058            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV       A,#0x3
   \   000022   6A           XRL       A,R2
   \   000023   4B           ORL       A,R3
   \   000024   604A         JZ        ??zcl_DeviceOperational_1
   1059            {
   1060              return ( TRUE );
   1061            }
   1062          
   1063            // Is device enabled?
   1064            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
   1065                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000026                ; Setup parameters for call to function zclFindAttrRec
   \   000026   7401         MOV       A,#0x1
   \   000028   12....       LCALL     ?XSTACK_DISP100_8
   \   00002B   88..         MOV       ?V2,R0
   \   00002D   89..         MOV       ?V3,R1
   \   00002F   78..         MOV       R0,#?V2
   \   000031   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000034   7C12         MOV       R4,#0x12
   \   000036   7D00         MOV       R5,#0x0
   \   000038   7A00         MOV       R2,#0x0
   \   00003A   7B00         MOV       R3,#0x0
   \   00003C   EE           MOV       A,R6
   \   00003D   F9           MOV       R1,A
   \   00003E   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000041   7402         MOV       A,#0x2
   \   000043   12....       LCALL     ?DEALLOC_XSTACK8
   \   000046   E9           MOV       A,R1
   \   000047   601C         JZ        ??zcl_DeviceOperational_2
   1066            {
   1067          #ifdef ZCL_READ
   1068              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000049                ; Setup parameters for call to function zclReadAttrData
   \   000049   E4           CLR       A
   \   00004A   F5..         MOV       ?V2,A
   \   00004C   F5..         MOV       ?V3,A
   \   00004E   78..         MOV       R0,#?V2
   \   000050   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000053   7403         MOV       A,#0x3
   \   000055   12....       LCALL     ?XSTACK_DISP102_8
   \   000058   7402         MOV       A,#0x2
   \   00005A   12....       LCALL     ?XSTACK_DISP101_8
   \   00005D   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   000060   7402         MOV       A,#0x2
   \   000062   12....       LCALL     ?DEALLOC_XSTACK8
   1069          #endif
   1070            }
   1071          
   1072            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_2:
   \   000065   85..82       MOV       DPL,?XSP + 0
   \   000068   85..83       MOV       DPH,?XSP + 1
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   6401         XRL       A,#0x1
   \   00006E   7004         JNZ       ??zcl_DeviceOperational_3
   \                     ??zcl_DeviceOperational_1:
   \   000070   7901         MOV       R1,#0x1
   \   000072   8002         SJMP      ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_3:
   \   000074   7900         MOV       R1,#0x0
   \                     ??zcl_DeviceOperational_4:
   \   000076   7409         MOV       A,#0x9
   \   000078   02....       LJMP      ?Subroutine3 & 0xFFFF
   1073          }
   1074          
   1075          /*********************************************************************
   1076           * @fn      zcl_SendCommand
   1077           *
   1078           * @brief   Used to send Profile and Cluster Specific Command messages.
   1079           *
   1080           *          NOTE: The calling application is responsible for incrementing
   1081           *                the Sequence Number.
   1082           *
   1083           * @param   srcEp - source endpoint
   1084           * @param   destAddr - destination address
   1085           * @param   clusterID - cluster ID
   1086           * @param   cmd - command ID
   1087           * @param   specific - whether the command is Cluster Specific
   1088           * @param   direction - client/server direction of the command
   1089           * @param   disableDefaultRsp - disable Default Response command
   1090           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1091           * @param   seqNumber - identification number for the transaction
   1092           * @param   cmdFormatLen - length of the command to be sent
   1093           * @param   cmdFormat - command to be sent
   1094           *
   1095           * @return  ZSuccess if OK
   1096           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1097          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
   1098                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
   1099                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
   1100                                     uint16 cmdFormatLen, uint8 *cmdFormat )
   1101          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV       A,#-0x6
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V10,R1
   \   00000C   8A..         MOV       ?V14,R2
   \   00000E   8B..         MOV       ?V15,R3
   \   000010   8C..         MOV       ?V0,R4
   \   000012   8D..         MOV       ?V1,R5
   1102            endPointDesc_t *epDesc;
   1103            zclFrameHdr_t hdr;
   1104            uint8 *msgBuf;
   1105            uint16 msgLen;
   1106            uint8 *pBuf;
   1107            uint8 options;
   1108            ZStatus_t status;
   1109          
   1110            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL     `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV       ?V12,R2
   \   000019   8B..         MOV       ?V13,R3
   1111            if ( epDesc == NULL )
   \   00001B   EA           MOV       A,R2
   \   00001C   45..         ORL       A,?V13
   \   00001E   7005         JNZ       ??zcl_SendCommand_0
   1112            {
   1113              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV       R1,#0x2
   \   000022   02....       LJMP      ??zcl_SendCommand_1 & 0xFFFF
   1114            }
   1115          
   1116          #if defined ( INTER_PAN )
   1117            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
   1118            {
   1119              options = AF_TX_OPTIONS_NONE;
   1120            }
   1121            else
   1122          #endif
   1123            {
   1124              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption
   \   000025   AA..         MOV       R2,?V0
   \   000027   AB..         MOV       R3,?V1
   \   000029   A9..         MOV       R1,?V10
   \   00002B   12....       LCALL     `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00002E   E9           MOV       A,R1
   \   00002F   F5..         MOV       ?V7,A
   1125          
   1126              // The cluster might not have been defined to use security but if this message
   1127              // is in response to another message that was using APS security this message
   1128              // will be sent with APS security
   1129              if ( !( options & AF_EN_SECURITY ) )
   \   000031   A2E6         MOV       C,0xE0 /* A   */.6
   \   000033   401C         JC        ??zcl_SendCommand_2
   1130              {
   1131                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV       DPTR,#rawAFMsg
   \   000038   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   1132          
   1133                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_339:
   \   00003B   6014         JZ        ??zcl_SendCommand_2
   \   00003D   E8           MOV       A,R0
   \   00003E   2419         ADD       A,#0x19
   \   000040   F582         MOV       DPL,A
   \   000042   E4           CLR       A
   \   000043   39           ADDC      A,R1
   \   000044   F583         MOV       DPH,A
   \   000046   E0           MOVX      A,@DPTR
   \   000047   6401         XRL       A,#0x1
   \   000049   7006         JNZ       ??zcl_SendCommand_2
   1134                {
   1135                  options |= AF_EN_SECURITY;
   \   00004B   E5..         MOV       A,?V7
   \   00004D   D2E6         SETB      0xE0 /* A   */.6
   \   00004F   F5..         MOV       ?V7,A
   1136                }
   1137              }
   1138            }
   1139          
   1140            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000051                ; Setup parameters for call to function osal_memset
   \   000051   7C06         MOV       R4,#0x6
   \   000053   7D00         MOV       R5,#0x0
   \   000055   7900         MOV       R1,#0x0
   \   000057   AA..         MOV       R2,?XSP + 0
   \   000059   AB..         MOV       R3,?XSP + 1
   \   00005B   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1141          
   1142            // Not Profile wide command (like READ, WRITE)
   1143            if ( specific )
   \   00005E   741F         MOV       A,#0x1f
   \   000060   12....       LCALL     ?XSTACK_DISP0_8
   \   000063   12....       LCALL     ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   000066   6009         JZ        ??zcl_SendCommand_3
   1144            {
   1145              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000068   E0           MOVX      A,@DPTR
   \   000069   54FC         ANL       A,#0xfc
   \   00006B   F0           MOVX      @DPTR,A
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   4401         ORL       A,#0x1
   \   00006F   8003         SJMP      ??zcl_SendCommand_4
   1146            }
   1147            else
   1148            {
   1149              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   000071   E0           MOVX      A,@DPTR
   \   000072   54FC         ANL       A,#0xfc
   1150            }
   \                     ??zcl_SendCommand_4:
   \   000074   12....       LCALL     ?Subroutine38 & 0xFFFF
   1151          
   1152            if ( ( epDesc->simpleDesc == NULL ) ||
   1153                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
   1154                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_48:
   \   000077   A3           INC       DPTR
   \   000078   12....       LCALL     ??Subroutine181_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   00007B   602B         JZ        ??zcl_SendCommand_5
   \   00007D   741E         MOV       A,#0x1e
   \   00007F   12....       LCALL     ?XSTACK_DISP0_8
   \   000082   E0           MOVX      A,@DPTR
   \   000083   FE           MOV       R6,A
   \   000084                ; Setup parameters for call to function zcl_DeviceOperational
   \   000084   8882         MOV       DPL,R0
   \   000086   8983         MOV       DPH,R1
   \   000088   A3           INC       DPTR
   \   000089   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00008C   EE           MOV       A,R6
   \   00008D   FD           MOV       R5,A
   \   00008E   7402         MOV       A,#0x2
   \   000090   12....       LCALL     ?XSTACK_DISP0_8
   \   000093   E0           MOVX      A,@DPTR
   \   000094   5403         ANL       A,#0x3
   \   000096   FC           MOV       R4,A
   \   000097   AA..         MOV       R2,?V0
   \   000099   AB..         MOV       R3,?V1
   \   00009B   A9..         MOV       R1,?V10
   \   00009D   12....       LCALL     `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   0000A0   7402         MOV       A,#0x2
   \   0000A2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A5   E9           MOV       A,R1
   \   0000A6   7005         JNZ       ??zcl_SendCommand_6
   1155            {
   1156              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   0000A8   7901         MOV       R1,#0x1
   \   0000AA   02....       LJMP      ??zcl_SendCommand_1 & 0xFFFF
   1157            }
   \                     ??zcl_SendCommand_6:
   \   0000AD   7422         MOV       A,#0x22
   \   0000AF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B2   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   1158          
   1159            // Fill in the Maufacturer Code
   1160            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_340:
   \   0000B5   6012         JZ        ??CrossCallReturnLabel_419
   1161            {
   1162              hdr.fc.manuSpecific = 1;
   \   0000B7   85..82       MOV       DPL,?XSP + 0
   \   0000BA   85..83       MOV       DPH,?XSP + 1
   \   0000BD   E0           MOVX      A,@DPTR
   \   0000BE   4404         ORL       A,#0x4
   \   0000C0   F0           MOVX      @DPTR,A
   1163              hdr.manuCode = manuCode;
   \   0000C1   7402         MOV       A,#0x2
   \   0000C3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C6   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   1164            }
   1165          
   1166            // Set the Command Direction
   1167            if ( direction )
   \                     ??CrossCallReturnLabel_419:
   \   0000C9   7420         MOV       A,#0x20
   \   0000CB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CE   12....       LCALL     ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   0000D1   6005         JZ        ??zcl_SendCommand_7
   1168            {
   1169              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000D3   E0           MOVX      A,@DPTR
   \   0000D4   4408         ORL       A,#0x8
   \   0000D6   8003         SJMP      ??zcl_SendCommand_8
   1170            }
   1171            else
   1172            {
   1173              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000D8   E0           MOVX      A,@DPTR
   \   0000D9   54F7         ANL       A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000DB   F0           MOVX      @DPTR,A
   1174            }
   1175          
   1176            // Set the Disable Default Response field
   1177            if ( disableDefaultRsp )
   \   0000DC   7421         MOV       A,#0x21
   \   0000DE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E1   12....       LCALL     ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   0000E4   6005         JZ        ??zcl_SendCommand_9
   1178            {
   1179              hdr.fc.disableDefaultRsp = 1;
   \   0000E6   E0           MOVX      A,@DPTR
   \   0000E7   4410         ORL       A,#0x10
   \   0000E9   8003         SJMP      ??zcl_SendCommand_10
   1180            }
   1181            else
   1182            {
   1183              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000EB   E0           MOVX      A,@DPTR
   \   0000EC   54EF         ANL       A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000EE   F0           MOVX      @DPTR,A
   1184            }
   1185          
   1186            // Fill in the Transaction Sequence Number
   1187            hdr.transSeqNum = seqNum;
   \   0000EF   7424         MOV       A,#0x24
   \   0000F1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F4   E0           MOVX      A,@DPTR
   \   0000F5   C0E0         PUSH      A
   \   0000F7   7404         MOV       A,#0x4
   \   0000F9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000FC   D0E0         POP       A
   \   0000FE   F0           MOVX      @DPTR,A
   1188          
   1189            // Fill in the command
   1190            hdr.commandID = cmd;
   \   0000FF   7405         MOV       A,#0x5
   \   000101   12....       LCALL     ?XSTACK_DISP0_8
   \   000104   EE           MOV       A,R6
   \   000105   F0           MOVX      @DPTR,A
   1191          
   1192            // calculate the needed buffer size
   1193            msgLen = zclCalcHdrSize( &hdr );
   \   000106   7803         MOV       R0,#0x3
   \   000108   85..82       MOV       DPL,?XSP + 0
   \   00010B   85..83       MOV       DPH,?XSP + 1
   \   00010E   E0           MOVX      A,@DPTR
   \   00010F   5404         ANL       A,#0x4
   \   000111   6002         JZ        ??zcl_SendCommand_11
   \   000113   7805         MOV       R0,#0x5
   \                     ??zcl_SendCommand_11:
   \   000115   7425         MOV       A,#0x25
   \   000117   12....       LCALL     ?XSTACK_DISP0_8
   \   00011A   12....       LCALL     ?Subroutine104 & 0xFFFF
   1194            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_180:
   \   00011D   25..         ADD       A,?V8
   \   00011F   FE           MOV       R6,A
   \   000120   E4           CLR       A
   \   000121   35..         ADDC      A,?V9
   \   000123   FF           MOV       R7,A
   1195          
   1196            // Allocate the buffer needed
   1197            msgBuf = zcl_mem_alloc( msgLen );
   \   000124                ; Setup parameters for call to function osal_mem_alloc
   \   000124   EE           MOV       A,R6
   \   000125   FA           MOV       R2,A
   \   000126   EF           MOV       A,R7
   \   000127   FB           MOV       R3,A
   \   000128   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00012B   8A..         MOV       ?V2,R2
   \   00012D   8B..         MOV       ?V3,R3
   1198            if ( msgBuf != NULL )
   \   00012F   EA           MOV       A,R2
   \   000130   45..         ORL       A,?V3
   \   000132   6068         JZ        ??zcl_SendCommand_12
   1199            {
   1200              // Fill in the ZCL Header
   1201              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   000134                ; Setup parameters for call to function zclBuildHdr
   \   000134   AC..         MOV       R4,?V2
   \   000136   AD..         MOV       R5,?V3
   \   000138   AA..         MOV       R2,?XSP + 0
   \   00013A   AB..         MOV       R3,?XSP + 1
   \   00013C   12....       LCALL     `??zclBuildHdr::?relay`; Banked call to: zclBuildHdr
   1202          
   1203              // Fill in the command frame
   1204              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   00013F                ; Setup parameters for call to function osal_memcpy
   \   00013F   7427         MOV       A,#0x27
   \   000141   12....       LCALL     ?XSTACK_DISP0_8
   \   000144   12....       LCALL     ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000147   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00014A   AC..         MOV       R4,?V8
   \   00014C   AD..         MOV       R5,?V9
   \   00014E   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000151   7403         MOV       A,#0x3
   \   000153   12....       LCALL     ?DEALLOC_XSTACK8
   1205          
   1206              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
   1207                                       &APS_Counter, options, zcl_radius );
   \   000156                ; Setup parameters for call to function AF_DataRequest
   \   000156   90....       MOV       DPTR,#zcl_radius
   \   000159   E0           MOVX      A,@DPTR
   \   00015A   F5..         MOV       ?V4,A
   \   00015C   78..         MOV       R0,#?V4
   \   00015E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000161   75....       MOV       ?V4,#APS_Counter & 0xff
   \   000164   75....       MOV       ?V5,#(APS_Counter >> 8) & 0xff
   \   000167   78..         MOV       R0,#?V4
   \   000169   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00016C   78..         MOV       R0,#?V2
   \   00016E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000171   8E..         MOV       ?V4,R6
   \   000173   8F..         MOV       ?V5,R7
   \   000175   78..         MOV       R0,#?V4
   \   000177   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00017A   78..         MOV       R0,#?V0
   \   00017C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00017F   A9..         MOV       R1,?V7
   \   000181   AC..         MOV       R4,?V12
   \   000183   AD..         MOV       R5,?V13
   \   000185   AA..         MOV       R2,?V14
   \   000187   AB..         MOV       R3,?V15
   \   000189   12....       LCALL     `??AF_DataRequest::?relay`; Banked call to: AF_DataRequest
   \   00018C   7409         MOV       A,#0x9
   \   00018E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000191   E9           MOV       A,R1
   \   000192   FE           MOV       R6,A
   1208              zcl_mem_free ( msgBuf );
   \   000193                ; Setup parameters for call to function osal_mem_free
   \   000193   AA..         MOV       R2,?V2
   \   000195   AB..         MOV       R3,?V3
   \   000197   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   00019A   8002         SJMP      ??zcl_SendCommand_13
   1209            }
   1210            else
   1211            {
   1212              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   00019C   7E10         MOV       R6,#0x10
   1213            }
   1214          
   1215            return ( status );
   \                     ??zcl_SendCommand_13:
   \   00019E   EE           MOV       A,R6
   \   00019F   F9           MOV       R1,A
   \                     ??zcl_SendCommand_1:
   \   0001A0   7406         MOV       A,#0x6
   \   0001A2   02....       LJMP      ?Subroutine5 & 0xFFFF
   1216          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   12....       LCALL     ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine166:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?XSP + 0
   \   000004   85..83       MOV       DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL     ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?V12
   \   000004   85..83       MOV       DPH,?V13
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine181_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine182_0
   \   000002                ; // Fall through to label ??Subroutine182_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine149:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V4,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL     ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000003   75..00       MOV       ?V6,#0x0
   \   000006   78..         MOV       R0,#?V4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine191_0:
   \   000000   E8           MOV       A,R0
   \   000001                REQUIRE ??Subroutine192_0
   \   000001                ; // Fall through to label ??Subroutine192_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine192_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   E9           MOV       A,R1
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine200_0
   \   000003                ; // Fall through to label ??Subroutine200_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine200_0:
   \   000000   7F10         MOV       R7,#0x10
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   1217          
   1218          #ifdef ZCL_READ
   1219          /*********************************************************************
   1220           * @fn      zcl_SendRead
   1221           *
   1222           * @brief   Send a Read command
   1223           *
   1224           * @param   srcEP - Application's endpoint
   1225           * @param   dstAddr - destination address
   1226           * @param   clusterID - cluster ID
   1227           * @param   readCmd - read command to be sent
   1228           * @param   direction - direction of the command
   1229           * @param   seqNum - transaction sequence number
   1230           *
   1231           * @return  ZSuccess if OK
   1232           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1233          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
   1234                                  uint16 clusterID, zclReadCmd_t *readCmd,
   1235                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
   1236          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7414         MOV       A,#0x14
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   12....       LCALL     ?Subroutine70 & 0xFFFF
   1237            uint16 dataLen;
   1238            uint8 *buf;
   1239            uint8 *pBuf;
   1240            ZStatus_t status;
   1241          
   1242            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_112:
   \   000017   25E0         ADD       A,0xE0 /* A   */
   \   000019   F5..         MOV       ?V6,A
   \   00001B   E4           CLR       A
   \   00001C   33           RLC       A
   \   00001D   F5..         MOV       ?V7,A
   1243          
   1244            buf = zcl_mem_alloc( dataLen );
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   AA..         MOV       R2,?V6
   \   000021   FB           MOV       R3,A
   \   000022   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000025   8A..         MOV       ?V0,R2
   \   000027   8B..         MOV       ?V1,R3
   1245            if ( buf != NULL )
   \   000029   EA           MOV       A,R2
   \   00002A   45..         ORL       A,?V1
   \   00002C   7003         JNZ       $+5
   \   00002E   02....       LJMP      ??zcl_SendRead_0 & 0xFFFF
   1246            {
   1247              uint8 i;
   1248          
   1249              // Load the buffer - serially
   1250              pBuf = buf;
   \   000031   A8..         MOV       R0,?V0
   \   000033   A9..         MOV       R1,?V1
   1251              for (i = 0; i < readCmd->numAttr; i++)
   \   000035   7C00         MOV       R4,#0x0
   \   000037   801D         SJMP      ??zcl_SendRead_1
   1252              {
   1253                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   000039   EC           MOV       A,R4
   \   00003A   25E0         ADD       A,0xE0 /* A   */
   \   00003C   FA           MOV       R2,A
   \   00003D   E4           CLR       A
   \   00003E   33           RLC       A
   \   00003F   FB           MOV       R3,A
   \   000040   12....       LCALL     ?Subroutine123 & 0xFFFF
   1254                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   1255              }
   \                     ??CrossCallReturnLabel_219:
   \   000043   AA82         MOV       R2,DPL
   \   000045   AB83         MOV       R3,DPH
   \   000047   12....       LCALL     ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   00004A   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00004D   F0           MOVX      @DPTR,A
   \   00004E   E8           MOV       A,R0
   \   00004F   2402         ADD       A,#0x2
   \   000051   F8           MOV       R0,A
   \   000052   5001         JNC       ??zcl_SendRead_3
   \   000054   09           INC       R1
   \                     ??zcl_SendRead_3:
   \   000055   0C           INC       R4
   \                     ??zcl_SendRead_1:
   \   000056   85..82       MOV       DPL,?V4
   \   000059   85..83       MOV       DPH,?V5
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   FA           MOV       R2,A
   \   00005E   EC           MOV       A,R4
   \   00005F   C3           CLR       C
   \   000060   9A           SUBB      A,R2
   \   000061   40D6         JC        ??zcl_SendRead_2
   1256          
   1257              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
   1258                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000063                ; Setup parameters for call to function zcl_SendCommand
   \   000063   78..         MOV       R0,#?V0
   \   000065   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000068   78..         MOV       R0,#?V6
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006D   741C         MOV       A,#0x1c
   \   00006F   12....       LCALL     ?XSTACK_DISP0_8
   \   000072   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000075   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000078   E4           CLR       A
   \   000079   F5..         MOV       ?V4,A
   \   00007B   F5..         MOV       ?V5,A
   \   00007D   78..         MOV       R0,#?V4
   \   00007F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000082   741E         MOV       A,#0x1e
   \   000084   12....       LCALL     ?XSTACK_DISP0_8
   \   000087   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00008A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008D   741E         MOV       A,#0x1e
   \   00008F   12....       LCALL     ?XSTACK_DISP0_8
   \   000092   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000095   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000098   75..00       MOV       ?V3,#0x0
   \   00009B   78..         MOV       R0,#?V3
   \   00009D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A0   78..         MOV       R0,#?V3
   \   0000A2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A5   EE           MOV       A,R6
   \   0000A6   FC           MOV       R4,A
   \   0000A7   EF           MOV       A,R7
   \   0000A8   FD           MOV       R5,A
   \   0000A9   AA..         MOV       R2,?V8
   \   0000AB   AB..         MOV       R3,?V9
   \   0000AD   A9..         MOV       R1,?V2
   \   0000AF   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000B2   740B         MOV       A,#0xb
   \   0000B4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B7   E9           MOV       A,R1
   \   0000B8   FE           MOV       R6,A
   1259              zcl_mem_free( buf );
   \   0000B9                ; Setup parameters for call to function osal_mem_free
   \   0000B9   AA..         MOV       R2,?V0
   \   0000BB   AB..         MOV       R3,?V1
   \   0000BD   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000C0   8002         SJMP      ??zcl_SendRead_4
   1260            }
   1261            else
   1262            {
   1263              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000C2   7E10         MOV       R6,#0x10
   1264            }
   1265          
   1266            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000C4                REQUIRE ?Subroutine10
   \   0000C4                ; // Fall through to label ?Subroutine10
   1267          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EE           MOV       A,R6
   \   000001   F9           MOV       R1,A
   \   000002   02....       LJMP      ??Subroutine199_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   E5..         MOV       A,?V4
   \   000002   2A           ADD       A,R2
   \   000003   F582         MOV       DPL,A
   \   000005   E5..         MOV       A,?V5
   \   000007   3B           ADDC      A,R3
   \   000008   F583         MOV       DPH,A
   \   00000A   A3           INC       DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL     ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V3,A
   \   000003   78..         MOV       R0,#?V3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL     ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   000003   A3           INC       DPTR
   \   000004   12....       LCALL     ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine148:
   \   000000   12....       LCALL     ?Subroutine168 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000003   A3           INC       DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   12....       LCALL     ?Subroutine168 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine168:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine147:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V4,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V5,A
   \   000007   85..82       MOV       DPL,?V4
   \   00000A   F583         MOV       DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine199_0:
   \   000000   7F0C         MOV       R7,#0xc
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   1268          
   1269          /*********************************************************************
   1270           * @fn      zcl_SendReadRsp
   1271           *
   1272           * @brief   Send a Read Response command.
   1273           *
   1274           * @param   srcEP - Application's endpoint
   1275           * @param   dstAddr - destination address
   1276           * @param   clusterID - cluster ID
   1277           * @param   readRspCmd - read response command to be sent
   1278           * @param   direction - direction of the command
   1279           * @param   seqNum - transaction sequence number
   1280           *
   1281           * @return  ZSuccess if OK
   1282           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1283          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1284                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1285                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1286          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V3,R1
   \   00000C   8A..         MOV       ?V12,R2
   \   00000E   8B..         MOV       ?V13,R3
   \   000010   8C..         MOV       ?V6,R4
   \   000012   8D..         MOV       ?V7,R5
   1287            uint8 *buf;
   1288            uint16 len = 0;
   \   000014   7E00         MOV       R6,#0x0
   \   000016   7F00         MOV       R7,#0x0
   1289            ZStatus_t status;
   1290            uint8 i;
   1291          
   1292            // calculate the size of the command
   1293            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000018   75..00       MOV       ?V2,#0x0
   \   00001B   7418         MOV       A,#0x18
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   12....       LCALL     ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_432:
   \   000023   8011         SJMP      ??zcl_SendReadRsp_0
   1294            {
   1295              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1296          
   1297              len += 2 + 1; // Attribute ID + Status
   1298          
   1299              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1300              {
   1301                len++; // Attribute Data Type length
   1302          
   1303                // Attribute Data length
   1304                if ( statusRec->data != NULL )
   1305                {
   1306                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1307                }
   1308                else
   1309                {
   1310                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000025                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000025   12....       LCALL     ?Subroutine78 & 0xFFFF
   1311                }
   \                     ??CrossCallReturnLabel_126:
   \   000028   12....       LCALL     `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_2:
   \   00002B   8B..         MOV       ?V1,R3
   \   00002D   EE           MOV       A,R6
   \   00002E   2A           ADD       A,R2
   \   00002F   FE           MOV       R6,A
   \   000030   EF           MOV       A,R7
   \   000031   35..         ADDC      A,?V1
   \   000033   FF           MOV       R7,A
   \                     ??zcl_SendReadRsp_3:
   \   000034   05..         INC       ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000036   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_416:
   \   000039   503F         JNC       ??zcl_SendReadRsp_4
   \   00003B   E5..         MOV       A,?V2
   \   00003D   75F006       MOV       B,#0x6
   \   000040   A4           MUL       AB
   \   000041   F8           MOV       R0,A
   \   000042   A9F0         MOV       R1,B
   \   000044   E5..         MOV       A,?V8
   \   000046   28           ADD       A,R0
   \   000047   F582         MOV       DPL,A
   \   000049   E5..         MOV       A,?V9
   \   00004B   12....       LCALL     ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   00004E   EE           MOV       A,R6
   \   00004F   2403         ADD       A,#0x3
   \   000051   FE           MOV       R6,A
   \   000052   E4           CLR       A
   \   000053   3F           ADDC      A,R7
   \   000054   FF           MOV       R7,A
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   E0           MOVX      A,@DPTR
   \   000058   70DA         JNZ       ??zcl_SendReadRsp_3
   \   00005A   0E           INC       R6
   \   00005B   EE           MOV       A,R6
   \   00005C   7001         JNZ       ??zcl_SendReadRsp_5
   \   00005E   0F           INC       R7
   \                     ??zcl_SendReadRsp_5:
   \   00005F   8882         MOV       DPL,R0
   \   000061   8983         MOV       DPH,R1
   \   000063   A3           INC       DPTR
   \   000064   A3           INC       DPTR
   \   000065   A3           INC       DPTR
   \   000066   A3           INC       DPTR
   \   000067   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   00006A   8882         MOV       DPL,R0
   \   00006C   8983         MOV       DPH,R1
   \   00006E   60B5         JZ        ??zcl_SendReadRsp_1
   \   000070                ; Setup parameters for call to function zclGetAttrDataLength
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   A3           INC       DPTR
   \   000073   E0           MOVX      A,@DPTR
   \   000074   F9           MOV       R1,A
   \   000075   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000078   80B1         SJMP      ??zcl_SendReadRsp_2
   1312              }
   1313            }
   1314          
   1315            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_4:
   \   00007A                ; Setup parameters for call to function osal_mem_alloc
   \   00007A   EE           MOV       A,R6
   \   00007B   FA           MOV       R2,A
   \   00007C   EF           MOV       A,R7
   \   00007D   FB           MOV       R3,A
   \   00007E   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000081   8A..         MOV       ?V0,R2
   \   000083   8B..         MOV       ?V1,R3
   \   000085   8A..         MOV       ?V4,R2
   \   000087   8B..         MOV       ?V5,R3
   1316            if ( buf != NULL )
   \   000089   EA           MOV       A,R2
   \   00008A   45..         ORL       A,?V5
   \   00008C   7003         JNZ       $+5
   \   00008E   02....       LJMP      ??zcl_SendReadRsp_6 & 0xFFFF
   1317            {
   1318              // Load the buffer - serially
   1319              uint8 *pBuf = buf;
   1320          
   1321              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000091   75..00       MOV       ?V2,#0x0
   \   000094   8036         SJMP      ??zcl_SendReadRsp_7
   1322              {
   1323                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1324          
   1325                *pBuf++ = LO_UINT16( statusRec->attrID );
   1326                *pBuf++ = HI_UINT16( statusRec->attrID );
   1327                *pBuf++ = statusRec->status;
   1328          
   1329                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1330                {
   1331                  *pBuf++ = statusRec->dataType;
   1332          
   1333                  if ( statusRec->data != NULL )
   1334                  {
   1335                    // Copy attribute data to the buffer to be sent out
   1336                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1337                  }
   1338                  else
   1339                  {
   1340                    uint16 dataLen;
   1341          
   1342                    // Read attribute data directly into the buffer to be sent out
   1343                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_8:
   \   000096                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000096   A8..         MOV       R0,?XSP + 0
   \   000098   A9..         MOV       R1,?XSP + 1
   \   00009A   88..         MOV       ?V10,R0
   \   00009C   89..         MOV       ?V11,R1
   \   00009E   78..         MOV       R0,#?V10
   \   0000A0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A3   78..         MOV       R0,#?V0
   \   0000A5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A8   8A82         MOV       DPL,R2
   \   0000AA   8B83         MOV       DPH,R3
   \   0000AC   12....       LCALL     ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   0000AF   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   0000B2   7404         MOV       A,#0x4
   \   0000B4   12....       LCALL     ?DEALLOC_XSTACK8
   1344                    pBuf += dataLen;
   \   0000B7   85..82       MOV       DPL,?XSP + 0
   \   0000BA   85..83       MOV       DPH,?XSP + 1
   \   0000BD   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   1345                  }
   \                     ??CrossCallReturnLabel_354:
   \   0000C0   E5..         MOV       A,?V0
   \   0000C2   28           ADD       A,R0
   \   0000C3   F5..         MOV       ?V0,A
   \   0000C5   E5..         MOV       A,?V1
   \   0000C7   39           ADDC      A,R1
   \   0000C8   F5..         MOV       ?V1,A
   \                     ??zcl_SendReadRsp_9:
   \   0000CA   05..         INC       ?V2
   \                     ??zcl_SendReadRsp_7:
   \   0000CC   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_417:
   \   0000CF   5078         JNC       ??zcl_SendReadRsp_10
   \   0000D1   E5..         MOV       A,?V2
   \   0000D3   75F006       MOV       B,#0x6
   \   0000D6   A4           MUL       AB
   \   0000D7   F8           MOV       R0,A
   \   0000D8   A9F0         MOV       R1,B
   \   0000DA   E5..         MOV       A,?V8
   \   0000DC   28           ADD       A,R0
   \   0000DD   F582         MOV       DPL,A
   \   0000DF   E5..         MOV       A,?V9
   \   0000E1   12....       LCALL     ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   0000E4   12....       LCALL     ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   0000E7   8A82         MOV       DPL,R2
   \   0000E9   8B83         MOV       DPH,R3
   \   0000EB   A3           INC       DPTR
   \   0000EC   12....       LCALL     ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   0000EF   F0           MOVX      @DPTR,A
   \   0000F0   12....       LCALL     ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   0000F3   12....       LCALL     ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   0000F6   A3           INC       DPTR
   \   0000F7   F0           MOVX      @DPTR,A
   \   0000F8   E5..         MOV       A,?V0
   \   0000FA   2403         ADD       A,#0x3
   \   0000FC   F5..         MOV       ?V0,A
   \   0000FE   5002         JNC       ??zcl_SendReadRsp_11
   \   000100   05..         INC       ?V1
   \                     ??zcl_SendReadRsp_11:
   \   000102   8882         MOV       DPL,R0
   \   000104   8983         MOV       DPH,R1
   \   000106   E0           MOVX      A,@DPTR
   \   000107   70C1         JNZ       ??zcl_SendReadRsp_9
   \   000109   EA           MOV       A,R2
   \   00010A   2403         ADD       A,#0x3
   \   00010C   08           INC       R0
   \   00010D   E4           CLR       A
   \   00010E   3B           ADDC      A,R3
   \   00010F   F9           MOV       R1,A
   \   000110   8882         MOV       DPL,R0
   \   000112   8983         MOV       DPH,R1
   \   000114   12....       LCALL     ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000117   A3           INC       DPTR
   \   000118   8582..       MOV       ?V0,DPL
   \   00011B   8583..       MOV       ?V1,DPH
   \   00011E   8A82         MOV       DPL,R2
   \   000120   8B83         MOV       DPH,R3
   \   000122   12....       LCALL     ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_470:
   \   000125   8C82         MOV       DPL,R4
   \   000127   8D83         MOV       DPH,R5
   \   000129   E582         MOV       A,DPL
   \   00012B   4583         ORL       A,DPH
   \   00012D   7003         JNZ       $+5
   \   00012F   02....       LJMP      ??zcl_SendReadRsp_8 & 0xFFFF
   \   000132                ; Setup parameters for call to function zclSerializeData
   \   000132   AC..         MOV       R4,?V0
   \   000134   AD..         MOV       R5,?V1
   \   000136   AA82         MOV       R2,DPL
   \   000138   AB83         MOV       R3,DPH
   \   00013A   8882         MOV       DPL,R0
   \   00013C   8983         MOV       DPH,R1
   \   00013E   E0           MOVX      A,@DPTR
   \   00013F   F9           MOV       R1,A
   \   000140   12....       LCALL     `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   000143   8A..         MOV       ?V0,R2
   \   000145   8B..         MOV       ?V1,R3
   \   000147   8081         SJMP      ??zcl_SendReadRsp_9
   1346                }
   1347              } // for loop
   1348          
   1349              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1350                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_10:
   \   000149                ; Setup parameters for call to function zcl_SendCommand
   \   000149   78..         MOV       R0,#?V4
   \   00014B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00014E   8E..         MOV       ?V0,R6
   \   000150   8F..         MOV       ?V1,R7
   \   000152   78..         MOV       R0,#?V0
   \   000154   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000157   7420         MOV       A,#0x20
   \   000159   12....       LCALL     ?XSTACK_DISP0_8
   \   00015C   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   00015F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000162   E4           CLR       A
   \   000163   F5..         MOV       ?V0,A
   \   000165   F5..         MOV       ?V1,A
   \   000167   78..         MOV       R0,#?V0
   \   000169   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00016C   7422         MOV       A,#0x22
   \   00016E   12....       LCALL     ?XSTACK_DISP0_8
   \   000171   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000174   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000177   7422         MOV       A,#0x22
   \   000179   12....       LCALL     ?XSTACK_DISP0_8
   \   00017C   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00017F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000182   75..00       MOV       ?V0,#0x0
   \   000185   78..         MOV       R0,#?V0
   \   000187   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00018A   75..01       MOV       ?V0,#0x1
   \   00018D   78..         MOV       R0,#?V0
   \   00018F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000192   AC..         MOV       R4,?V6
   \   000194   AD..         MOV       R5,?V7
   \   000196   AA..         MOV       R2,?V12
   \   000198   AB..         MOV       R3,?V13
   \   00019A   A9..         MOV       R1,?V3
   \   00019C   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00019F   740B         MOV       A,#0xb
   \   0001A1   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001A4   E9           MOV       A,R1
   \   0001A5   FE           MOV       R6,A
   1351              zcl_mem_free( buf );
   \   0001A6                ; Setup parameters for call to function osal_mem_free
   \   0001A6   AA..         MOV       R2,?V4
   \   0001A8   AB..         MOV       R3,?V5
   \   0001AA   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001AD   8002         SJMP      ??zcl_SendReadRsp_12
   1352            }
   1353            else
   1354            {
   1355              status = ZMemError;
   \                     ??zcl_SendReadRsp_6:
   \   0001AF   7E10         MOV       R6,#0x10
   1356            }
   1357          
   1358            return ( status );
   \                     ??zcl_SendReadRsp_12:
   \   0001B1   EE           MOV       A,R6
   \   0001B2   F9           MOV       R1,A
   \   0001B3   7402         MOV       A,#0x2
   \   0001B5   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001B8   80..         SJMP      ??Subroutine174_0
   1359          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   12....       LCALL     ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine157:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?V0
   \   000004   85..83       MOV       DPH,?V1
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   85..82       MOV       DPL,?V0
   \   000004   85..83       MOV       DPH,?V1
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL     ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_498:
   \   000003   AA..         MOV       R2,?V6
   \   000005   AB..         MOV       R3,?V7
   \   000007   A9..         MOV       R1,?V3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   7F0E         MOV       R7,#0xe
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   39           ADDC      A,R1
   \   000001   F583         MOV       DPH,A
   \   000003   A3           INC       DPTR
   \   000004   A882         MOV       R0,DPL
   \   000006   A983         MOV       R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   78..         MOV       R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   EA           MOV       A,R2
   \   000001   2402         ADD       A,#0x2
   \   000003   F8           MOV       R0,A
   \   000004   E4           CLR       A
   \   000005   3B           ADDC      A,R3
   \   000006   F9           MOV       R1,A
   \   000007   8882         MOV       DPL,R0
   \   000009   8983         MOV       DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   39           ADDC      A,R1
   \   000001   F583         MOV       DPH,A
   \   000003   A3           INC       DPTR
   \   000004   AA82         MOV       R2,DPL
   \   000006   AB83         MOV       R3,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   85..82       MOV       DPL,?V8
   \   000003   85..83       MOV       DPH,?V9
   \   000006                REQUIRE ??Subroutine190_0
   \   000006                ; // Fall through to label ??Subroutine190_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine190_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   E5..         MOV       A,?V2
   \   000004   C3           CLR       C
   \   000005   98           SUBB      A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine193_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V8,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V9,A
   \   000007   22           RET
   1360          #endif // ZCL_READ
   1361          
   1362          #ifdef ZCL_WRITE
   1363          /*********************************************************************
   1364           * @fn      sendWriteRequest
   1365           *
   1366           * @brief   Send a Write command
   1367           *
   1368           * @param   dstAddr - destination address
   1369           * @param   clusterID - cluster ID
   1370           * @param   writeCmd - write command to be sent
   1371           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1372           * @param   direction - direction of the command
   1373           * @param   seqNum - transaction sequence number
   1374           *
   1375           * @return  ZSuccess if OK
   1376           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1377          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1378                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1379                                          uint8 disableDefaultRsp, uint8 seqNum )
   1380          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V3,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   8C..         MOV       ?V6,R4
   \   00000D   8D..         MOV       ?V7,R5
   1381            uint8 *buf;
   1382            uint16 dataLen = 0;
   \   00000F   7E00         MOV       R6,#0x0
   \   000011   7F00         MOV       R7,#0x0
   1383            ZStatus_t status;
   1384            uint8 i;
   1385          
   1386            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000013   75..00       MOV       ?V2,#0x0
   \   000016   7416         MOV       A,#0x16
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   00001E   8030         SJMP      ??zcl_SendWriteRequest_0
   1387            {
   1388              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   000020   E5..         MOV       A,?V2
   \   000022   75F005       MOV       B,#0x5
   \   000025   A4           MUL       AB
   \   000026   F8           MOV       R0,A
   \   000027   A9F0         MOV       R1,B
   \   000029   E5..         MOV       A,?V4
   \   00002B   28           ADD       A,R0
   \   00002C   F582         MOV       DPL,A
   \   00002E   E5..         MOV       A,?V5
   \   000030   12....       LCALL     ?Subroutine124 & 0xFFFF
   1389          
   1390              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1391          
   1392              // Attribute Data
   1393              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??CrossCallReturnLabel_222:
   \   000033                ; Setup parameters for call to function zclGetAttrDataLength
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   12....       LCALL     ?Subroutine76 & 0xFFFF
   1394            }
   \                     ??CrossCallReturnLabel_125:
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   F9           MOV       R1,A
   \   00003B   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00003E   8B..         MOV       ?V1,R3
   \   000040   EA           MOV       A,R2
   \   000041   2403         ADD       A,#0x3
   \   000043   F8           MOV       R0,A
   \   000044   E4           CLR       A
   \   000045   35..         ADDC      A,?V1
   \   000047   F9           MOV       R1,A
   \   000048   EE           MOV       A,R6
   \   000049   28           ADD       A,R0
   \   00004A   FE           MOV       R6,A
   \   00004B   EF           MOV       A,R7
   \   00004C   39           ADDC      A,R1
   \   00004D   FF           MOV       R7,A
   \   00004E   05..         INC       ?V2
   \                     ??zcl_SendWriteRequest_0:
   \   000050   85..82       MOV       DPL,?V4
   \   000053   85..83       MOV       DPH,?V5
   \   000056   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_414:
   \   000059   40C5         JC        ??zcl_SendWriteRequest_1
   1395          
   1396            buf = zcl_mem_alloc( dataLen );
   \   00005B                ; Setup parameters for call to function osal_mem_alloc
   \   00005B   EE           MOV       A,R6
   \   00005C   FA           MOV       R2,A
   \   00005D   EF           MOV       A,R7
   \   00005E   FB           MOV       R3,A
   \   00005F   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000062   8A..         MOV       ?V0,R2
   \   000064   8B..         MOV       ?V1,R3
   1397            if ( buf != NULL )
   \   000066   EA           MOV       A,R2
   \   000067   45..         ORL       A,?V1
   \   000069   7003         JNZ       $+5
   \   00006B   02....       LJMP      ??zcl_SendWriteRequest_2 & 0xFFFF
   1398            {
   1399              // Load the buffer - serially
   1400              uint8 *pBuf = buf;
   \   00006E   A8..         MOV       R0,?V0
   \   000070   A9..         MOV       R1,?V1
   1401              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000072   75..00       MOV       ?V2,#0x0
   \   000075   804A         SJMP      ??zcl_SendWriteRequest_3
   1402              {
   1403                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_4:
   \   000077   E5..         MOV       A,?V2
   \   000079   75F005       MOV       B,#0x5
   \   00007C   A4           MUL       AB
   \   00007D   FA           MOV       R2,A
   \   00007E   ABF0         MOV       R3,B
   \   000080   12....       LCALL     ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000083   8582..       MOV       ?V12,DPL
   \   000086   8583..       MOV       ?V13,DPH
   1404          
   1405                *pBuf++ = LO_UINT16( statusRec->attrID );
   \   000089   12....       LCALL     ?Subroutine20 & 0xFFFF
   1406                *pBuf++ = HI_UINT16( statusRec->attrID );
   1407                *pBuf++ = statusRec->dataType;
   \                     ??CrossCallReturnLabel_13:
   \   00008C   E5..         MOV       A,?V12
   \   00008E   12....       LCALL     ??Subroutine189_0 & 0xFFFF
   1408          
   1409                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   1410              }
   \                     ??CrossCallReturnLabel_407:
   \   000091   35..         ADDC      A,?V13
   \   000093   FB           MOV       R3,A
   \   000094   8A..         MOV       ?V10,R2
   \   000096   8B..         MOV       ?V11,R3
   \   000098   8A82         MOV       DPL,R2
   \   00009A   F583         MOV       DPH,A
   \   00009C   12....       LCALL     ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   00009F   FC           MOV       R4,A
   \   0000A0   E4           CLR       A
   \   0000A1   39           ADDC      A,R1
   \   0000A2   FD           MOV       R5,A
   \   0000A3   85..82       MOV       DPL,?V12
   \   0000A6   85..83       MOV       DPH,?V13
   \   0000A9   12....       LCALL     ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_450:
   \   0000AC   85..82       MOV       DPL,?V10
   \   0000AF   85..83       MOV       DPH,?V11
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   F9           MOV       R1,A
   \   0000B4   12....       LCALL     `??zclSerializeData::?relay`; Banked call to: zclSerializeData
   \   0000B7   8A..         MOV       ?V10,R2
   \   0000B9   8B..         MOV       ?V11,R3
   \   0000BB   A8..         MOV       R0,?V10
   \   0000BD   A9..         MOV       R1,?V11
   \   0000BF   05..         INC       ?V2
   \                     ??zcl_SendWriteRequest_3:
   \   0000C1   85..82       MOV       DPL,?V4
   \   0000C4   85..83       MOV       DPH,?V5
   \   0000C7   E0           MOVX      A,@DPTR
   \   0000C8   FA           MOV       R2,A
   \   0000C9   E5..         MOV       A,?V2
   \   0000CB   C3           CLR       C
   \   0000CC   9A           SUBB      A,R2
   \   0000CD   40A8         JC        ??zcl_SendWriteRequest_4
   1411          
   1412              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1413                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   0000CF                ; Setup parameters for call to function zcl_SendCommand
   \   0000CF   78..         MOV       R0,#?V0
   \   0000D1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000D4   8E..         MOV       ?V4,R6
   \   0000D6   8F..         MOV       ?V5,R7
   \   0000D8   78..         MOV       R0,#?V4
   \   0000DA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000DD   741F         MOV       A,#0x1f
   \   0000DF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E2   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_479:
   \   0000E5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E8   E4           CLR       A
   \   0000E9   F5..         MOV       ?V4,A
   \   0000EB   F5..         MOV       ?V5,A
   \   0000ED   78..         MOV       R0,#?V4
   \   0000EF   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000F2   7421         MOV       A,#0x21
   \   0000F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F7   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_480:
   \   0000FA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000FD   7421         MOV       A,#0x21
   \   0000FF   12....       LCALL     ?XSTACK_DISP0_8
   \   000102   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_481:
   \   000105   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000108   75..00       MOV       ?V2,#0x0
   \   00010B   78..         MOV       R0,#?V2
   \   00010D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000110   7422         MOV       A,#0x22
   \   000112   12....       LCALL     ?XSTACK_DISP0_8
   \   000115   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_482:
   \   000118   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00011B   AC..         MOV       R4,?V6
   \   00011D   AD..         MOV       R5,?V7
   \   00011F   AA..         MOV       R2,?V8
   \   000121   AB..         MOV       R3,?V9
   \   000123   A9..         MOV       R1,?V3
   \   000125   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000128   740B         MOV       A,#0xb
   \   00012A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00012D   E9           MOV       A,R1
   \   00012E   FE           MOV       R6,A
   1414              zcl_mem_free( buf );
   \   00012F                ; Setup parameters for call to function osal_mem_free
   \   00012F   AA..         MOV       R2,?V0
   \   000131   AB..         MOV       R3,?V1
   \   000133   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000136   8002         SJMP      ??zcl_SendWriteRequest_5
   1415            }
   1416            else
   1417            {
   1418              status = ZMemError;
   \                     ??zcl_SendWriteRequest_2:
   \   000138   7E10         MOV       R6,#0x10
   1419            }
   1420          
   1421            return ( status);
   \                     ??zcl_SendWriteRequest_5:
   \   00013A   EE           MOV       A,R6
   \   00013B   F9           MOV       R1,A
   \   00013C   02....       LJMP      ??Subroutine174_0 & 0xFFFF
   1422          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL     ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000003   A3           INC       DPTR
   \   000004   F0           MOVX      @DPTR,A
   \   000005                ; Setup parameters for call to function zclSerializeData
   \   000005   E8           MOV       A,R0
   \   000006   2403         ADD       A,#0x3
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL     ?Subroutine168 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   000003   12....       LCALL     ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000006   12....       LCALL     ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   12....       LCALL     ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine189_0:
   \   000000   2402         ADD       A,#0x2
   \   000002   FA           MOV       R2,A
   \   000003   E4           CLR       A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine195_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine196_0
   \   000003                ; // Fall through to label ??Subroutine196_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine207_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V2,A
   \   000003   78..         MOV       R0,#?V2
   \   000005   22           RET
   1423          
   1424          /*********************************************************************
   1425           * @fn      zcl_SendWriteRsp
   1426           *
   1427           * @brief   Send a Write Response command
   1428           *
   1429           * @param   dstAddr - destination address
   1430           * @param   clusterID - cluster ID
   1431           * @param   wrtieRspCmd - write response command to be sent
   1432           * @param   direction - direction of the command
   1433           * @param   seqNum - transaction sequence number
   1434           *
   1435           * @return  ZSuccess if OK
   1436           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1437          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1438                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1439                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1440          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7414         MOV       A,#0x14
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   12....       LCALL     ?Subroutine70 & 0xFFFF
   1441            uint16 dataLen;
   1442            uint8 *buf;
   1443            ZStatus_t status;
   1444          
   1445            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \                     ??CrossCallReturnLabel_113:
   \   000017   75F003       MOV       B,#0x3
   \   00001A   A4           MUL       AB
   \   00001B   F5..         MOV       ?V6,A
   \   00001D   E5F0         MOV       A,B
   \   00001F   F5..         MOV       ?V7,A
   1446          
   1447            buf = zcl_mem_alloc( dataLen );
   \   000021                ; Setup parameters for call to function osal_mem_alloc
   \   000021   AA..         MOV       R2,?V6
   \   000023   FB           MOV       R3,A
   \   000024   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000027   8A..         MOV       ?V0,R2
   \   000029   8B..         MOV       ?V1,R3
   1448            if ( buf != NULL )
   \   00002B   EA           MOV       A,R2
   \   00002C   45..         ORL       A,?V1
   \   00002E   7003         JNZ       $+5
   \   000030   02....       LJMP      ??zcl_SendWriteRsp_0 & 0xFFFF
   1449            {
   1450              // Load the buffer - serially
   1451              uint8 i;
   1452              uint8 *pBuf = buf;
   \   000033   A8..         MOV       R0,?V0
   \   000035   A9..         MOV       R1,?V1
   1453              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   000037   7C00         MOV       R4,#0x0
   \   000039   8035         SJMP      ??zcl_SendWriteRsp_1
   1454              {
   1455                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_2:
   \   00003B   EC           MOV       A,R4
   \   00003C   75F003       MOV       B,#0x3
   \   00003F   A4           MUL       AB
   \   000040   FA           MOV       R2,A
   \   000041   ABF0         MOV       R3,B
   \   000043   E5..         MOV       A,?V4
   \   000045   2A           ADD       A,R2
   \   000046   FA           MOV       R2,A
   \   000047   E5..         MOV       A,?V5
   \   000049   3B           ADDC      A,R3
   \   00004A   FB           MOV       R3,A
   \   00004B   8A82         MOV       DPL,R2
   \   00004D   8B83         MOV       DPH,R3
   \   00004F   A3           INC       DPTR
   \   000050   12....       LCALL     ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000053   F0           MOVX      @DPTR,A
   1456                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \   000054   EA           MOV       A,R2
   \   000055   2402         ADD       A,#0x2
   \   000057   FA           MOV       R2,A
   \   000058   5001         JNC       ??zcl_SendWriteRsp_3
   \   00005A   0B           INC       R3
   \                     ??zcl_SendWriteRsp_3:
   \   00005B   8A82         MOV       DPL,R2
   \   00005D   8B83         MOV       DPH,R3
   \   00005F   12....       LCALL     ?Subroutine93 & 0xFFFF
   1457                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1458              }
   \                     ??CrossCallReturnLabel_156:
   \   000062   A3           INC       DPTR
   \   000063   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000066   A3           INC       DPTR
   \   000067   F0           MOVX      @DPTR,A
   \   000068   E8           MOV       A,R0
   \   000069   2403         ADD       A,#0x3
   \   00006B   F8           MOV       R0,A
   \   00006C   5001         JNC       ??zcl_SendWriteRsp_4
   \   00006E   09           INC       R1
   \                     ??zcl_SendWriteRsp_4:
   \   00006F   0C           INC       R4
   \                     ??zcl_SendWriteRsp_1:
   \   000070   85..82       MOV       DPL,?V4
   \   000073   85..83       MOV       DPH,?V5
   \   000076   E0           MOVX      A,@DPTR
   \   000077   FA           MOV       R2,A
   \   000078   EC           MOV       A,R4
   \   000079   C3           CLR       C
   \   00007A   9A           SUBB      A,R2
   \   00007B   40BE         JC        ??zcl_SendWriteRsp_2
   1459          
   1460              // If there's only a single status record and its status field is set to
   1461              // SUCCESS then omit the attribute ID field.
   1462              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   00007D   7401         MOV       A,#0x1
   \   00007F   6A           XRL       A,R2
   \   000080   700A         JNZ       ??zcl_SendWriteRsp_5
   \   000082   A3           INC       DPTR
   \   000083   E0           MOVX      A,@DPTR
   \   000084   7006         JNZ       ??zcl_SendWriteRsp_5
   1463              {
   1464                dataLen = 1;
   \   000086   75..01       MOV       ?V6,#0x1
   \   000089   75..00       MOV       ?V7,#0x0
   1465              }
   1466          
   1467              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1468                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_5:
   \   00008C                ; Setup parameters for call to function zcl_SendCommand
   \   00008C   78..         MOV       R0,#?V0
   \   00008E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000091   78..         MOV       R0,#?V6
   \   000093   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000096   741C         MOV       A,#0x1c
   \   000098   12....       LCALL     ?XSTACK_DISP0_8
   \   00009B   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00009E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A1   E4           CLR       A
   \   0000A2   F5..         MOV       ?V4,A
   \   0000A4   F5..         MOV       ?V5,A
   \   0000A6   78..         MOV       R0,#?V4
   \   0000A8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AB   741E         MOV       A,#0x1e
   \   0000AD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B0   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0000B3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B6   741E         MOV       A,#0x1e
   \   0000B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   0000BE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C1   75..00       MOV       ?V3,#0x0
   \   0000C4   78..         MOV       R0,#?V3
   \   0000C6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C9   75..04       MOV       ?V3,#0x4
   \   0000CC   78..         MOV       R0,#?V3
   \   0000CE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D1   EE           MOV       A,R6
   \   0000D2   FC           MOV       R4,A
   \   0000D3   EF           MOV       A,R7
   \   0000D4   FD           MOV       R5,A
   \   0000D5   AA..         MOV       R2,?V8
   \   0000D7   AB..         MOV       R3,?V9
   \   0000D9   A9..         MOV       R1,?V2
   \   0000DB   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000DE   740B         MOV       A,#0xb
   \   0000E0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000E3   E9           MOV       A,R1
   \   0000E4   FE           MOV       R6,A
   1469              zcl_mem_free( buf );
   \   0000E5                ; Setup parameters for call to function osal_mem_free
   \   0000E5   AA..         MOV       R2,?V0
   \   0000E7   AB..         MOV       R3,?V1
   \   0000E9   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000EC   8002         SJMP      ??zcl_SendWriteRsp_6
   1470            }
   1471            else
   1472            {
   1473              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000EE   7E10         MOV       R6,#0x10
   1474            }
   1475          
   1476            return ( status );
   \                     ??zcl_SendWriteRsp_6:
   \   0000F0   02....       LJMP      ?Subroutine10 & 0xFFFF
   1477          }
   1478          #endif // ZCL_WRITE
   1479          
   1480          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   1481          /*********************************************************************
   1482           * @fn      zcl_SendConfigReportCmd
   1483           *
   1484           * @brief   Send a Configure Reporting command
   1485           *
   1486           * @param   dstAddr - destination address
   1487           * @param   clusterID - cluster ID
   1488           * @param   cfgReportCmd - configure reporting command to be sent
   1489           * @param   direction - direction of the command
   1490           * @param   seqNum - transaction sequence number
   1491           *
   1492           * @return  ZSuccess if OK
   1493           */
   1494          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1495                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1496                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1497          {
   1498            uint8 *buf;
   1499            uint16 dataLen = 0;
   1500            ZStatus_t status;
   1501            uint8 i;
   1502          
   1503            // Find out the data length
   1504            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1505            {
   1506              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1507          
   1508              dataLen += 1 + 2; // Direction + Attribute ID
   1509          
   1510              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1511              {
   1512                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1513          
   1514                // Find out the size of the Reportable Change field (for Analog data types)
   1515                if ( zclAnalogDataType( reportRec->dataType ) )
   1516                {
   1517                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1518                }
   1519              }
   1520              else
   1521              {
   1522                dataLen += 2; // Timeout Period
   1523              }
   1524            }
   1525          
   1526            buf = zcl_mem_alloc( dataLen );
   1527            if ( buf != NULL )
   1528            {
   1529              // Load the buffer - serially
   1530              uint8 *pBuf = buf;
   1531          
   1532              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   1533              {
   1534                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1535          
   1536                *pBuf++ = reportRec->direction;
   1537                *pBuf++ = LO_UINT16( reportRec->attrID );
   1538                *pBuf++ = HI_UINT16( reportRec->attrID );
   1539          
   1540                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1541                {
   1542                  *pBuf++ = reportRec->dataType;
   1543                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1544                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1545                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1546                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1547          
   1548                  if ( zclAnalogDataType( reportRec->dataType ) )
   1549                  {
   1550                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1551                  }
   1552                }
   1553                else
   1554                {
   1555                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   1556                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1557                }
   1558              } // for loop
   1559          
   1560              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1561                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1562              zcl_mem_free( buf );
   1563            }
   1564            else
   1565            {
   1566              status = ZMemError;
   1567            }
   1568          
   1569            return ( status );
   1570          }
   1571          #endif
   1572          
   1573          #ifdef ZCL_REPORTING_DEVICE
   1574          /*********************************************************************
   1575           * @fn      zcl_SendConfigReportRspCmd
   1576           *
   1577           * @brief   Send a Configure Reporting Response command
   1578           *
   1579           * @param   dstAddr - destination address
   1580           * @param   clusterID - cluster ID
   1581           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1582           * @param   direction - direction of the command
   1583           * @param   seqNum - transaction sequence number
   1584           *
   1585           * @return  ZSuccess if OK
   1586           */
   1587          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1588                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1589                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1590          {
   1591            uint16 dataLen;
   1592            uint8 *buf;
   1593            ZStatus_t status;
   1594          
   1595            // Atrribute list (Status, Direction and Attribute ID)
   1596            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   1597          
   1598            buf = zcl_mem_alloc( dataLen );
   1599            if ( buf != NULL )
   1600            {
   1601              // Load the buffer - serially
   1602              uint8 *pBuf = buf;
   1603              uint8 i;
   1604          
   1605              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   1606              {
   1607                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   1608                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   1609                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1610                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1611              }
   1612          
   1613              // If there's only a single status record and its status field is set to
   1614              // SUCCESS then omit the attribute ID field.
   1615              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1616              {
   1617                dataLen = 1;
   1618              }
   1619          
   1620              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1621                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1622                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   1623              zcl_mem_free( buf );
   1624            }
   1625            else
   1626            {
   1627              status = ZMemError;
   1628            }
   1629          
   1630            return ( status );
   1631          }
   1632          #endif
   1633          
   1634          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   1635          /*********************************************************************
   1636           * @fn      zcl_SendReadReportCfgCmd
   1637           *
   1638           * @brief   Send a Read Reporting Configuration command
   1639           *
   1640           * @param   dstAddr - destination address
   1641           * @param   clusterID - cluster ID
   1642           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1643           * @param   direction - direction of the command
   1644           * @param   seqNum - transaction sequence number
   1645           *
   1646           * @return  ZSuccess if OK
   1647           */
   1648          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1649                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1650                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1651          {
   1652            uint16 dataLen;
   1653            uint8 *buf;
   1654            ZStatus_t status;
   1655          
   1656            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1657          
   1658            buf = zcl_mem_alloc( dataLen );
   1659            if ( buf != NULL )
   1660            {
   1661              // Load the buffer - serially
   1662              uint8 *pBuf = buf;
   1663              uint8 i;
   1664          
   1665              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1666              {
   1667                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1668                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1669                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1670              }
   1671          
   1672              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1673                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1674              zcl_mem_free( buf );
   1675            }
   1676            else
   1677            {
   1678              status = ZMemError;
   1679            }
   1680          
   1681            return ( status );
   1682          }
   1683          #endif
   1684          
   1685          #ifdef ZCL_REPORTING_DEVICE
   1686          /*********************************************************************
   1687           * @fn      zcl_SendReadReportCfgRspCmd
   1688           *
   1689           * @brief   Send a Read Reporting Configuration Response command
   1690           *
   1691           * @param   dstAddr - destination address
   1692           * @param   clusterID - cluster ID
   1693           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1694           * @param   direction - direction of the command
   1695           * @param   seqNum - transaction sequence number
   1696           *
   1697           * @return  ZSuccess if OK
   1698           */
   1699          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1700                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1701                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1702          {
   1703            uint8 *buf;
   1704            uint16 dataLen = 0;
   1705            ZStatus_t status;
   1706            uint8 i;
   1707          
   1708            // Find out the data length
   1709            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1710            {
   1711              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1712          
   1713              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1714          
   1715              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1716              {
   1717                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1718                {
   1719                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1720          
   1721                  // Find out the size of the Reportable Change field (for Analog data types)
   1722                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1723                  {
   1724                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1725                  }
   1726                }
   1727                else
   1728                {
   1729                  dataLen += 2; // Timeout Period
   1730                }
   1731              }
   1732            }
   1733          
   1734            buf = zcl_mem_alloc( dataLen );
   1735            if ( buf != NULL )
   1736            {
   1737              // Load the buffer - serially
   1738              uint8 *pBuf = buf;
   1739          
   1740              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1741              {
   1742                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1743          
   1744                *pBuf++ = reportRspRec->status;
   1745                *pBuf++ = reportRspRec->direction;
   1746                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1747                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1748          
   1749                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1750                {
   1751                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1752                  {
   1753                    *pBuf++ = reportRspRec->dataType;
   1754                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1755                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1756                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1757                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1758          
   1759                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1760                    {
   1761                      pBuf = zclSerializeData( reportRspRec->dataType,
   1762                                               reportRspRec->reportableChange, pBuf );
   1763                    }
   1764                  }
   1765                  else
   1766                  {
   1767                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1768                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1769                  }
   1770                }
   1771              }
   1772          
   1773              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1774                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1775                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1776              zcl_mem_free( buf );
   1777            }
   1778            else
   1779            {
   1780              status = ZMemError;
   1781            }
   1782          
   1783            return ( status );
   1784          }
   1785          
   1786          /*********************************************************************
   1787           * @fn      zcl_SendReportCmd
   1788           *
   1789           * @brief   Send a Report command
   1790           *
   1791           * @param   dstAddr - destination address
   1792           * @param   clusterID - cluster ID
   1793           * @param   reportCmd - report command to be sent
   1794           * @param   direction - direction of the command
   1795           * @param   seqNum - transaction sequence number
   1796           *
   1797           * @return  ZSuccess if OK
   1798           */
   1799          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1800                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1801                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1802          {
   1803            uint16 dataLen = 0;
   1804            uint8 *buf;
   1805            ZStatus_t status;
   1806            uint8 i;
   1807          
   1808            // calculate the size of the command
   1809            for ( i = 0; i < reportCmd->numAttr; i++ )
   1810            {
   1811              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1812          
   1813              dataLen += 2 + 1; // Attribute ID + data type
   1814          
   1815              // Attribute Data
   1816              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1817            }
   1818          
   1819            buf = zcl_mem_alloc( dataLen );
   1820            if ( buf != NULL )
   1821            {
   1822              // Load the buffer - serially
   1823              uint8 *pBuf = buf;
   1824          
   1825              for ( i = 0; i < reportCmd->numAttr; i++ )
   1826              {
   1827                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1828          
   1829                *pBuf++ = LO_UINT16( reportRec->attrID );
   1830                *pBuf++ = HI_UINT16( reportRec->attrID );
   1831                *pBuf++ = reportRec->dataType;
   1832          
   1833                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1834              }
   1835          
   1836              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1837                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1838              zcl_mem_free( buf );
   1839            }
   1840            else
   1841            {
   1842              status = ZMemError;
   1843            }
   1844          
   1845            return ( status );
   1846          }
   1847          #endif
   1848          
   1849          /*********************************************************************
   1850           * @fn      zcl_SendDefaultRspCmd
   1851           *
   1852           * @brief   Send a Default Response command
   1853           *
   1854           *          Note: The manufacturer code field should be set if this
   1855           *          command is being sent in response to a manufacturer specific
   1856           *          command.
   1857           *
   1858           * @param   dstAddr - destination address
   1859           * @param   clusterID - cluster ID
   1860           * @param   defaultRspCmd - default response command to be sent
   1861           * @param   direction - direction of the command
   1862           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1863           * @param   seqNum - transaction sequence number
   1864           *
   1865           * @return  ZSuccess if OK
   1866           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1867          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1868                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1869                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1870          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   740C         MOV       A,#0xc
   \   00000E   12....       LCALL     ?XSTACK_DISP0_8
   \   000011   12....       LCALL     ?Subroutine18 & 0xFFFF
   1871            uint8 buf[2]; // Command ID and Status;
   1872          
   1873            // Load the buffer - serially
   1874            buf[0] = defaultRspCmd->commandID;
   1875            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_312:
   \   000014   C0E0         PUSH      A
   \   000016   7401         MOV       A,#0x1
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   D0E0         POP       A
   \   00001D   F0           MOVX      @DPTR,A
   1876          
   1877            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1878                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   00001E                ; Setup parameters for call to function zcl_SendCommand
   \   00001E   A8..         MOV       R0,?XSP + 0
   \   000020   A9..         MOV       R1,?XSP + 1
   \   000022   88..         MOV       ?V0,R0
   \   000024   89..         MOV       ?V1,R1
   \   000026   78..         MOV       R0,#?V0
   \   000028   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002B   75..02       MOV       ?V0,#0x2
   \   00002E   75..00       MOV       ?V1,#0x0
   \   000031   78..         MOV       R0,#?V0
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000036   7416         MOV       A,#0x16
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000041   7415         MOV       A,#0x15
   \   000043   12....       LCALL     ?XSTACK_DISP0_8
   \   000046   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000049   7416         MOV       A,#0x16
   \   00004B   12....       LCALL     ?XSTACK_DISP0_8
   \   00004E   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000051   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000054   7416         MOV       A,#0x16
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   00005C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005F   75..00       MOV       ?V0,#0x0
   \   000062   78..         MOV       R0,#?V0
   \   000064   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000067   75..0B       MOV       ?V0,#0xb
   \   00006A   78..         MOV       R0,#?V0
   \   00006C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006F   EE           MOV       A,R6
   \   000070   F9           MOV       R1,A
   \   000071   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000074   740B         MOV       A,#0xb
   \   000076   12....       LCALL     ?DEALLOC_XSTACK8
   \   000079   7402         MOV       A,#0x2
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007E   02....       LJMP      ?Subroutine2 & 0xFFFF
   1879          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL     ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   000003   12....       LCALL     ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000006                REQUIRE ??Subroutine175_0
   \   000006                ; // Fall through to label ??Subroutine175_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   12....       LCALL     ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET
   1880          
   1881          #ifdef ZCL_DISCOVER
   1882          /*********************************************************************
   1883           * @fn      zcl_SendDiscoverCmdsCmd
   1884           *
   1885           * @brief   Send a Discover Commands command
   1886           *
   1887           * @param   dstAddr - destination address
   1888           * @param   clusterID - cluster ID
   1889           * @param   cmdType - requesting command ID
   1890           * @param   pDiscoverCmd - discover command to be sent
   1891           * @param   direction - direction of the command
   1892           * @param   seqNum - transaction sequence number
   1893           *
   1894           * @return  ZSuccess if OK
   1895           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1896          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDiscoverCmdsCmd:
   1897                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1898                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1899          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   740F         MOV       A,#0xf
   \   00000E   12....       LCALL     ?XSTACK_DISP0_8
   \   000011   12....       LCALL     ?Subroutine18 & 0xFFFF
   1900            uint8 payload[2]; // size of startCmdID and maxCmdID
   1901            ZStatus_t status;
   1902          
   1903            payload[0] = pDiscoverCmd->startCmdID;
   1904            payload[1] = pDiscoverCmd->maxCmdID;
   \                     ??CrossCallReturnLabel_313:
   \   000014   C0E0         PUSH      A
   \   000016   7401         MOV       A,#0x1
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   D0E0         POP       A
   \   00001D   F0           MOVX      @DPTR,A
   \   00001E   7411         MOV       A,#0x11
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   E0           MOVX      A,@DPTR
   \   000024   FF           MOV       R7,A
   \   000025   7412         MOV       A,#0x12
   \   000027   12....       LCALL     ?XSTACK_DISP0_8
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F5..         MOV       ?V0,A
   \   00002D   7413         MOV       A,#0x13
   \   00002F   12....       LCALL     ?XSTACK_DISP0_8
   \   000032   E0           MOVX      A,@DPTR
   \   000033   F5..         MOV       ?V1,A
   1905          
   1906            // Send message for either commands received or generated
   1907            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   \   000035   740E         MOV       A,#0xe
   \   000037   12....       LCALL     ?XSTACK_DISP0_8
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   6411         XRL       A,#0x11
   \   00003D   A8..         MOV       R0,?XSP + 0
   \   00003F   A9..         MOV       R1,?XSP + 1
   \   000041   88..         MOV       ?V2,R0
   \   000043   89..         MOV       ?V3,R1
   \   000045   78..         MOV       R0,#?V2
   \   000047   7035         JNZ       ??zcl_SendDiscoverCmdsCmd_0
   1908            {
   1909              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1910                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   \   000049                ; Setup parameters for call to function zcl_SendCommand
   \   000049   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004C   75..02       MOV       ?V2,#0x2
   \   00004F   75..00       MOV       ?V3,#0x0
   \   000052   78..         MOV       R0,#?V2
   \   000054   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000057   78..         MOV       R0,#?V1
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005C   E4           CLR       A
   \   00005D   F5..         MOV       ?V2,A
   \   00005F   78..         MOV       R0,#?V2
   \   000061   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000064   78..         MOV       R0,#?V0
   \   000066   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000069   EF           MOV       A,R7
   \   00006A   F5..         MOV       ?V0,A
   \   00006C   78..         MOV       R0,#?V0
   \   00006E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000071   75..00       MOV       ?V0,#0x0
   \   000074   78..         MOV       R0,#?V0
   \   000076   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000079   75..11       MOV       ?V0,#0x11
   \   00007C   8033         SJMP      ??zcl_SendDiscoverCmdsCmd_1
   1911            }
   1912            else  // generated
   1913            {
   1914              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1915                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   \                     ??zcl_SendDiscoverCmdsCmd_0:
   \   00007E                ; Setup parameters for call to function zcl_SendCommand
   \   00007E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000081   75..02       MOV       ?V2,#0x2
   \   000084   75..00       MOV       ?V3,#0x0
   \   000087   78..         MOV       R0,#?V2
   \   000089   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008C   78..         MOV       R0,#?V1
   \   00008E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000091   E4           CLR       A
   \   000092   F5..         MOV       ?V2,A
   \   000094   78..         MOV       R0,#?V2
   \   000096   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000099   78..         MOV       R0,#?V0
   \   00009B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00009E   EF           MOV       A,R7
   \   00009F   F5..         MOV       ?V0,A
   \   0000A1   78..         MOV       R0,#?V0
   \   0000A3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A6   75..00       MOV       ?V0,#0x0
   \   0000A9   78..         MOV       R0,#?V0
   \   0000AB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000AE   75..13       MOV       ?V0,#0x13
   \                     ??zcl_SendDiscoverCmdsCmd_1:
   \   0000B1   78..         MOV       R0,#?V0
   \   0000B3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B6   EE           MOV       A,R6
   \   0000B7   F9           MOV       R1,A
   \   0000B8   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000BB   740B         MOV       A,#0xb
   \   0000BD   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C0   E9           MOV       A,R1
   \   0000C1   F9           MOV       R1,A
   1916            }
   1917          
   1918            return ( status );
   \   0000C2   7402         MOV       A,#0x2
   \   0000C4   02....       LJMP      ?Subroutine3 & 0xFFFF
   1919          }
   1920          
   1921          /*********************************************************************
   1922           * @fn      zcl_SendDiscoverCmdsRspCmd
   1923           *
   1924           * @brief   Send a Discover Commands Response command
   1925           *
   1926           * @param   dstAddr - destination address
   1927           * @param   clusterID - cluster ID
   1928           * @param   pDiscoverRspCmd - response command to be sent
   1929           * @param   direction - direction of the command
   1930           * @param   seqNum - transaction sequence number
   1931           *
   1932           * @return  ZSuccess if OK
   1933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1934          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverCmdsRspCmd:
   1935                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1936                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1937          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V11,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7416         MOV       A,#0x16
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   12....       LCALL     ??Subroutine213_0 & 0xFFFF
   1938            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   \                     ??CrossCallReturnLabel_535:
   \   000017   E5..         MOV       A,?V2
   \   000019   2402         ADD       A,#0x2
   \   00001B   F5..         MOV       ?V4,A
   \   00001D   E4           CLR       A
   \   00001E   35..         ADDC      A,?V3
   \   000020   F5..         MOV       ?V5,A
   \   000022   85..82       MOV       DPL,?V4
   \   000025   F583         MOV       DPH,A
   \   000027   E0           MOVX      A,@DPTR
   \   000028   04           INC       A
   1939            uint8 *pCmdBuf;
   1940            uint8 i;
   1941            ZStatus_t status = ZSuccess;
   \   000029   75..00       MOV       ?V10,#0x0
   1942          
   1943            // allocate memory
   1944            pCmdBuf = zcl_mem_alloc( payloadSize );
   \   00002C   F5..         MOV       ?V6,A
   \   00002E   75..00       MOV       ?V7,#0x0
   \   000031                ; Setup parameters for call to function osal_mem_alloc
   \   000031   FA           MOV       R2,A
   \   000032   AB..         MOV       R3,?V7
   \   000034   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000037   8A..         MOV       ?V0,R2
   \   000039   8B..         MOV       ?V1,R3
   1945            if ( pCmdBuf != NULL )
   \   00003B   EA           MOV       A,R2
   \   00003C   45..         ORL       A,?V1
   \   00003E   7003         JNZ       $+5
   \   000040   02....       LJMP      ??zcl_SendDiscoverCmdsRspCmd_0 & 0xFFFF
   1946            {
   1947              uint8 *pBuf = pCmdBuf;
   \   000043   A8..         MOV       R0,?V0
   \   000045   A9..         MOV       R1,?V1
   1948          
   1949              // Load the buffer - serially
   1950              *pBuf++ = pDiscoverRspCmd->discComplete;
   \   000047   85..82       MOV       DPL,?V2
   \   00004A   85..83       MOV       DPH,?V3
   \   00004D   12....       LCALL     ?Subroutine36 & 0xFFFF
   1951              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   \                     ??CrossCallReturnLabel_44:
   \   000050   8020         SJMP      ??zcl_SendDiscoverCmdsRspCmd_1
   1952              {
   1953                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   \                     ??zcl_SendDiscoverCmdsRspCmd_2:
   \   000052   EA           MOV       A,R2
   \   000053   FC           MOV       R4,A
   \   000054   85..82       MOV       DPL,?V2
   \   000057   85..83       MOV       DPH,?V3
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   2C           ADD       A,R4
   \   00005F   FB           MOV       R3,A
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   3400         ADDC      A,#0x0
   \   000064   8B82         MOV       DPL,R3
   \   000066   F583         MOV       DPH,A
   \   000068   12....       LCALL     ?Subroutine93 & 0xFFFF
   1954              }
   \                     ??CrossCallReturnLabel_157:
   \   00006B   F0           MOVX      @DPTR,A
   \   00006C   A3           INC       DPTR
   \   00006D   A882         MOV       R0,DPL
   \   00006F   A983         MOV       R1,DPH
   \   000071   0A           INC       R2
   \                     ??zcl_SendDiscoverCmdsRspCmd_1:
   \   000072   85..82       MOV       DPL,?V4
   \   000075   85..83       MOV       DPH,?V5
   \   000078   E0           MOVX      A,@DPTR
   \   000079   FB           MOV       R3,A
   \   00007A   EA           MOV       A,R2
   \   00007B   C3           CLR       C
   \   00007C   9B           SUBB      A,R3
   \   00007D   40D3         JC        ??zcl_SendDiscoverCmdsRspCmd_2
   1955          
   1956              // Send response message for either commands received or generated
   1957              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   \   00007F   85..82       MOV       DPL,?V2
   \   000082   85..83       MOV       DPH,?V3
   \   000085   A3           INC       DPTR
   \   000086   E0           MOVX      A,@DPTR
   \   000087   F8           MOV       R0,A
   \   000088   7418         MOV       A,#0x18
   \   00008A   12....       LCALL     ?XSTACK_DISP0_8
   \   00008D   E0           MOVX      A,@DPTR
   \   00008E   F9           MOV       R1,A
   \   00008F   7419         MOV       A,#0x19
   \   000091   12....       LCALL     ?XSTACK_DISP0_8
   \   000094   E0           MOVX      A,@DPTR
   \   000095   FA           MOV       R2,A
   \   000096   741A         MOV       A,#0x1a
   \   000098   12....       LCALL     ?XSTACK_DISP0_8
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   FB           MOV       R3,A
   \   00009D   7411         MOV       A,#0x11
   \   00009F   68           XRL       A,R0
   \   0000A0   7039         JNZ       ??zcl_SendDiscoverCmdsRspCmd_3
   1958              {
   1959                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1960                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   \   0000A2                ; Setup parameters for call to function zcl_SendCommand
   \   0000A2   78..         MOV       R0,#?V0
   \   0000A4   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A7   78..         MOV       R0,#?V6
   \   0000A9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AC   EB           MOV       A,R3
   \   0000AD   F5..         MOV       ?V2,A
   \   0000AF   78..         MOV       R0,#?V2
   \   0000B1   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B4   E4           CLR       A
   \   0000B5   F5..         MOV       ?V2,A
   \   0000B7   F5..         MOV       ?V3,A
   \   0000B9   78..         MOV       R0,#?V2
   \   0000BB   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BE   EA           MOV       A,R2
   \   0000BF   F5..         MOV       ?V2,A
   \   0000C1   78..         MOV       R0,#?V2
   \   0000C3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C6   E9           MOV       A,R1
   \   0000C7   F5..         MOV       ?V2,A
   \   0000C9   78..         MOV       R0,#?V2
   \   0000CB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000CE   75..00       MOV       ?V2,#0x0
   \   0000D1   78..         MOV       R0,#?V2
   \   0000D3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D6   75..12       MOV       ?V2,#0x12
   \   0000D9   803C         SJMP      ??zcl_SendDiscoverCmdsRspCmd_4
   1961              }
   1962              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   \                     ??zcl_SendDiscoverCmdsRspCmd_3:
   \   0000DB   7413         MOV       A,#0x13
   \   0000DD   68           XRL       A,R0
   \   0000DE   7051         JNZ       ??zcl_SendDiscoverCmdsRspCmd_5
   1963              {
   1964                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1965                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   \   0000E0                ; Setup parameters for call to function zcl_SendCommand
   \   0000E0   78..         MOV       R0,#?V0
   \   0000E2   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000E5   78..         MOV       R0,#?V6
   \   0000E7   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000EA   EB           MOV       A,R3
   \   0000EB   F5..         MOV       ?V2,A
   \   0000ED   78..         MOV       R0,#?V2
   \   0000EF   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000F2   E4           CLR       A
   \   0000F3   F5..         MOV       ?V2,A
   \   0000F5   F5..         MOV       ?V3,A
   \   0000F7   78..         MOV       R0,#?V2
   \   0000F9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000FC   EA           MOV       A,R2
   \   0000FD   F5..         MOV       ?V2,A
   \   0000FF   78..         MOV       R0,#?V2
   \   000101   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000104   E9           MOV       A,R1
   \   000105   F5..         MOV       ?V2,A
   \   000107   78..         MOV       R0,#?V2
   \   000109   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00010C   75..00       MOV       ?V2,#0x0
   \   00010F   78..         MOV       R0,#?V2
   \   000111   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000114   75..14       MOV       ?V2,#0x14
   \                     ??zcl_SendDiscoverCmdsRspCmd_4:
   \   000117   78..         MOV       R0,#?V2
   \   000119   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00011C   EE           MOV       A,R6
   \   00011D   FC           MOV       R4,A
   \   00011E   EF           MOV       A,R7
   \   00011F   FD           MOV       R5,A
   \   000120   AA..         MOV       R2,?V8
   \   000122   AB..         MOV       R3,?V9
   \   000124   A9..         MOV       R1,?V11
   \   000126   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000129   740B         MOV       A,#0xb
   \   00012B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00012E   E9           MOV       A,R1
   \   00012F   F5..         MOV       ?V10,A
   1966              }
   1967          
   1968              zcl_mem_free( pCmdBuf );
   \                     ??zcl_SendDiscoverCmdsRspCmd_5:
   \   000131                ; Setup parameters for call to function osal_mem_free
   \   000131   AA..         MOV       R2,?V0
   \   000133   AB..         MOV       R3,?V1
   \   000135   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000138   8003         SJMP      ??zcl_SendDiscoverCmdsRspCmd_6
   1969            }
   1970            else
   1971            {
   1972              status = ZMemError;
   \                     ??zcl_SendDiscoverCmdsRspCmd_0:
   \   00013A   75..10       MOV       ?V10,#0x10
   1973            }
   1974          
   1975            return ( status );
   \                     ??zcl_SendDiscoverCmdsRspCmd_6:
   \   00013D   A9..         MOV       R1,?V10
   \   00013F   02....       LJMP      ??Subroutine174_0 & 0xFFFF
   1976          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL     ?Subroutine168 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   000003   F0           MOVX      @DPTR,A
   \   000004   A3           INC       DPTR
   \   000005   A882         MOV       R0,DPL
   \   000007   A983         MOV       R1,DPH
   \   000009   7A00         MOV       R2,#0x0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine213_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V3,A
   \   000007   22           RET
   1977          
   1978          /*********************************************************************
   1979           * @fn      zcl_SendDiscoverAttrsCmd
   1980           *
   1981           * @brief   Send a Discover Attributes command
   1982           *
   1983           * @param   dstAddr - destination address
   1984           * @param   clusterID - cluster ID
   1985           * @param   pDiscoverCmd - discover command to be sent
   1986           * @param   direction - direction of the command
   1987           * @param   seqNum - transaction sequence number
   1988           *
   1989           * @return  ZSuccess if OK
   1990           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1991          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverAttrsCmd:
   1992                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1993                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1994          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V2,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
   \   00000B   8C..         MOV       ?V0,R4
   \   00000D   8D..         MOV       ?V1,R5
   1995            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1996            uint8 *buf;
   1997            ZStatus_t status;
   1998          
   1999            buf = zcl_mem_alloc( dataLen );
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A03         MOV       R2,#0x3
   \   000011   7B00         MOV       R3,#0x0
   \   000013   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000016   8A..         MOV       ?V4,R2
   \   000018   8B..         MOV       ?V5,R3
   2000            if ( buf != NULL )
   \   00001A   EA           MOV       A,R2
   \   00001B   45..         ORL       A,?V5
   \   00001D   7003         JNZ       $+5
   \   00001F   02....       LJMP      ??zcl_SendDiscoverAttrsCmd_0 & 0xFFFF
   \   000022   7410         MOV       A,#0x10
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   12....       LCALL     ?Subroutine84 & 0xFFFF
   2001            {
   2002              // Load the buffer - serially
   2003              uint8 *pBuf = buf;
   2004              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   \                     ??CrossCallReturnLabel_138:
   \   00002A   12....       LCALL     ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   00002D   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   2005              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   \                     ??CrossCallReturnLabel_315:
   \   000030   8A82         MOV       DPL,R2
   \   000032   8B83         MOV       DPH,R3
   \   000034   A3           INC       DPTR
   \   000035   12....       LCALL     ?Subroutine37 & 0xFFFF
   2006              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   \                     ??CrossCallReturnLabel_46:
   \   000038   8A82         MOV       DPL,R2
   \   00003A   8B83         MOV       DPH,R3
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   F0           MOVX      @DPTR,A
   2007          
   2008              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   2009                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00003F                ; Setup parameters for call to function zcl_SendCommand
   \   00003F   78..         MOV       R0,#?V4
   \   000041   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000044   75..03       MOV       ?V6,#0x3
   \   000047   75..00       MOV       ?V7,#0x0
   \   00004A   78..         MOV       R0,#?V6
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004F   7418         MOV       A,#0x18
   \   000051   12....       LCALL     ?XSTACK_DISP0_8
   \   000054   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005A   E4           CLR       A
   \   00005B   F5..         MOV       ?V6,A
   \   00005D   78..         MOV       R0,#?V6
   \   00005F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000062   741A         MOV       A,#0x1a
   \   000064   12....       LCALL     ?XSTACK_DISP0_8
   \   000067   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00006D   741A         MOV       A,#0x1a
   \   00006F   12....       LCALL     ?XSTACK_DISP0_8
   \   000072   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000075   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000078   75..00       MOV       ?V3,#0x0
   \   00007B   78..         MOV       R0,#?V3
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000080   75..0C       MOV       ?V3,#0xc
   \   000083   78..         MOV       R0,#?V3
   \   000085   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000088   AC..         MOV       R4,?V0
   \   00008A   AD..         MOV       R5,?V1
   \   00008C   EE           MOV       A,R6
   \   00008D   FA           MOV       R2,A
   \   00008E   EF           MOV       A,R7
   \   00008F   FB           MOV       R3,A
   \   000090   A9..         MOV       R1,?V2
   \   000092   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000095   740B         MOV       A,#0xb
   \   000097   12....       LCALL     ?DEALLOC_XSTACK8
   \   00009A   E9           MOV       A,R1
   \   00009B   FE           MOV       R6,A
   2010              zcl_mem_free( buf );
   \   00009C                ; Setup parameters for call to function osal_mem_free
   \   00009C   AA..         MOV       R2,?V4
   \   00009E   AB..         MOV       R3,?V5
   \   0000A0   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000A3   8002         SJMP      ??zcl_SendDiscoverAttrsCmd_1
   2011            }
   2012            else
   2013            {
   2014              status = ZMemError;
   \                     ??zcl_SendDiscoverAttrsCmd_0:
   \   0000A5   7E10         MOV       R6,#0x10
   2015            }
   2016          
   2017            return ( status );
   \                     ??zcl_SendDiscoverAttrsCmd_1:
   \   0000A7   EE           MOV       A,R6
   \   0000A8   F9           MOV       R1,A
   \   0000A9   02....       LJMP      ??Subroutine180_0 & 0xFFFF
   2018          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   12....       LCALL     ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL     ??Subroutine187_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_395:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine180_0:
   \   000000   7F08         MOV       R7,#0x8
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine187_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   22           RET
   2019          
   2020          /*********************************************************************
   2021           * @fn      zcl_SendDiscoverAttrsRspCmd
   2022           *
   2023           * @brief   Send a Discover Attributes Response command
   2024           *
   2025           * @param   dstAddr - destination address
   2026           * @param   clusterID - cluster ID
   2027           * @param   reportRspCmd - report response command to be sent
   2028           * @param   direction - direction of the command
   2029           * @param   seqNum - transaction sequence number
   2030           *
   2031           * @return  ZSuccess if OK
   2032           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2033          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverAttrsRspCmd:
   2034                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   2035                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2036          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V8,R1
   \   000007   8A..         MOV       ?V10,R2
   \   000009   8B..         MOV       ?V11,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7418         MOV       A,#0x18
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   12....       LCALL     ?Subroutine54 & 0xFFFF
   2037            uint16 dataLen = 1; // Discovery complete
   2038            uint8 *buf;
   2039            ZStatus_t status;
   2040          
   2041            // calculate the size of the command
   2042            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   \                     ??CrossCallReturnLabel_71:
   \   000017   75F003       MOV       B,#0x3
   \   00001A   A4           MUL       AB
   \   00001B   A9F0         MOV       R1,B
   \   00001D   2401         ADD       A,#0x1
   \   00001F   F5..         MOV       ?V6,A
   \   000021   E4           CLR       A
   \   000022   39           ADDC      A,R1
   \   000023   F5..         MOV       ?V7,A
   2043          
   2044            buf = zcl_mem_alloc( dataLen );
   \   000025                ; Setup parameters for call to function osal_mem_alloc
   \   000025   AA..         MOV       R2,?V6
   \   000027   FB           MOV       R3,A
   \   000028   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002B   8A..         MOV       ?V0,R2
   \   00002D   8B..         MOV       ?V1,R3
   2045            if ( buf != NULL )
   \   00002F   EA           MOV       A,R2
   \   000030   45..         ORL       A,?V1
   \   000032   7003         JNZ       $+5
   \   000034   02....       LJMP      ??zcl_SendDiscoverAttrsRspCmd_0 & 0xFFFF
   2046            {
   2047              // Load the buffer - serially
   2048              uint8 i;
   2049              uint8 *pBuf = buf;
   \   000037   A8..         MOV       R0,?V0
   \   000039   A9..         MOV       R1,?V1
   2050          
   2051              *pBuf++ = pDiscoverRspCmd->discComplete;
   \   00003B   85..82       MOV       DPL,?V4
   \   00003E   85..83       MOV       DPH,?V5
   \   000041   12....       LCALL     ?Subroutine36 & 0xFFFF
   2052          
   2053              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_45:
   \   000044   8025         SJMP      ??zcl_SendDiscoverAttrsRspCmd_1
   2054              {
   2055                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   \                     ??zcl_SendDiscoverAttrsRspCmd_2:
   \   000046   EA           MOV       A,R2
   \   000047   75F003       MOV       B,#0x3
   \   00004A   A4           MUL       AB
   \   00004B   FC           MOV       R4,A
   \   00004C   ADF0         MOV       R5,B
   \   00004E   E5..         MOV       A,?V4
   \   000050   2C           ADD       A,R4
   \   000051   FC           MOV       R4,A
   \   000052   E5..         MOV       A,?V5
   \   000054   3D           ADDC      A,R5
   \   000055   12....       LCALL     ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000058   12....       LCALL     ?Subroutine20 & 0xFFFF
   2056                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   2057                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   \                     ??CrossCallReturnLabel_14:
   \   00005B   8C82         MOV       DPL,R4
   \   00005D   8D83         MOV       DPH,R5
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   A3           INC       DPTR
   \   000062   A3           INC       DPTR
   \   000063   12....       LCALL     ?Subroutine79 & 0xFFFF
   2058              }
   \                     ??CrossCallReturnLabel_129:
   \   000066   F8           MOV       R0,A
   \   000067   5001         JNC       ??zcl_SendDiscoverAttrsRspCmd_3
   \   000069   09           INC       R1
   \                     ??zcl_SendDiscoverAttrsRspCmd_3:
   \   00006A   0A           INC       R2
   \                     ??zcl_SendDiscoverAttrsRspCmd_1:
   \   00006B   85..82       MOV       DPL,?V2
   \   00006E   85..83       MOV       DPH,?V3
   \   000071   E0           MOVX      A,@DPTR
   \   000072   FB           MOV       R3,A
   \   000073   EA           MOV       A,R2
   \   000074   C3           CLR       C
   \   000075   9B           SUBB      A,R3
   \   000076   40CE         JC        ??zcl_SendDiscoverAttrsRspCmd_2
   2059          
   2060              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   2061                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000078                ; Setup parameters for call to function zcl_SendCommand
   \   000078   78..         MOV       R0,#?V0
   \   00007A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007D   78..         MOV       R0,#?V6
   \   00007F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000082   7420         MOV       A,#0x20
   \   000084   12....       LCALL     ?XSTACK_DISP0_8
   \   000087   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_483:
   \   00008A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008D   E4           CLR       A
   \   00008E   F5..         MOV       ?V2,A
   \   000090   F5..         MOV       ?V3,A
   \   000092   78..         MOV       R0,#?V2
   \   000094   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000097   7422         MOV       A,#0x22
   \   000099   12....       LCALL     ?XSTACK_DISP0_8
   \   00009C   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_484:
   \   00009F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000A2   7422         MOV       A,#0x22
   \   0000A4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A7   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_485:
   \   0000AA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000AD   75..00       MOV       ?V2,#0x0
   \   0000B0   78..         MOV       R0,#?V2
   \   0000B2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B5   75..0D       MOV       ?V2,#0xd
   \   0000B8   78..         MOV       R0,#?V2
   \   0000BA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000BD   EE           MOV       A,R6
   \   0000BE   FC           MOV       R4,A
   \   0000BF   EF           MOV       A,R7
   \   0000C0   FD           MOV       R5,A
   \   0000C1   AA..         MOV       R2,?V10
   \   0000C3   AB..         MOV       R3,?V11
   \   0000C5   A9..         MOV       R1,?V8
   \   0000C7   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000CA   740B         MOV       A,#0xb
   \   0000CC   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000CF   E9           MOV       A,R1
   \   0000D0   FE           MOV       R6,A
   2062              zcl_mem_free( buf );
   \   0000D1                ; Setup parameters for call to function osal_mem_free
   \   0000D1   AA..         MOV       R2,?V0
   \   0000D3   AB..         MOV       R3,?V1
   \   0000D5   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000D8   8002         SJMP      ??zcl_SendDiscoverAttrsRspCmd_4
   2063            }
   2064            else
   2065            {
   2066              status = ZMemError;
   \                     ??zcl_SendDiscoverAttrsRspCmd_0:
   \   0000DA   7E10         MOV       R6,#0x10
   2067            }
   2068          
   2069            return ( status );
   \                     ??zcl_SendDiscoverAttrsRspCmd_4:
   \   0000DC                REQUIRE ?Subroutine11
   \   0000DC                ; // Fall through to label ?Subroutine11
   2070          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   EE           MOV       A,R6
   \   000001   F9           MOV       R1,A
   \   000002   02....       LJMP      ??Subroutine200_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   FD           MOV       R5,A
   \   000001   EC           MOV       A,R4
   \   000002   2402         ADD       A,#0x2
   \   000004   F5..         MOV       ?V12,A
   \   000006   E4           CLR       A
   \   000007   3D           ADDC      A,R5
   \   000008   F5..         MOV       ?V13,A
   \   00000A   85..82       MOV       DPL,?V12
   \   00000D   F583         MOV       DPH,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL     ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000003   A3           INC       DPTR
   \   000004   8582..       MOV       ?V2,DPL
   \   000007   8583..       MOV       ?V3,DPH
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   22           RET
   2071          
   2072          /*********************************************************************
   2073           * @fn      zcl_SendDiscoverAttrsExt
   2074           *
   2075           * @brief   Send a Discover Attributes Extended command
   2076           *
   2077           * @param   dstAddr - destination address
   2078           * @param   clusterID - cluster ID
   2079           * @param   pDiscoverAttrsExt:
   2080           *            - startAttrID: the first attribute to be selected
   2081           *            - maxAttrIDs: maximum number of returned attributes
   2082           * @param   direction - direction of the command
   2083           * @param   seqNum - transaction sequence number
   2084           *
   2085           * @return  ZSuccess if OK
   2086           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2087          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverAttrsExt:
   2088                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   2089                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2090          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
   \   00000C   740F         MOV       A,#0xf
   \   00000E   12....       LCALL     ?XSTACK_DISP0_8
   \   000011   12....       LCALL     ?Subroutine18 & 0xFFFF
   2091            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   2092            ZStatus_t status;
   2093          
   2094            // Load the buffer - serially
   2095            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   2096            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   \                     ??CrossCallReturnLabel_314:
   \   000014   C0E0         PUSH      A
   \   000016   7401         MOV       A,#0x1
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   D0E0         POP       A
   \   00001D   12....       LCALL     ?Subroutine37 & 0xFFFF
   2097            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   \                     ??CrossCallReturnLabel_47:
   \   000020   C0E0         PUSH      A
   \   000022   7402         MOV       A,#0x2
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   D0E0         POP       A
   \   000029   F0           MOVX      @DPTR,A
   2098          
   2099            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   2100                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   2101          
   2102            return ( status );
   \   00002A                ; Setup parameters for call to function zcl_SendCommand
   \   00002A   A8..         MOV       R0,?XSP + 0
   \   00002C   A9..         MOV       R1,?XSP + 1
   \   00002E   88..         MOV       ?V2,R0
   \   000030   89..         MOV       ?V3,R1
   \   000032   78..         MOV       R0,#?V2
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000037   75..03       MOV       ?V2,#0x3
   \   00003A   75..00       MOV       ?V3,#0x0
   \   00003D   78..         MOV       R0,#?V2
   \   00003F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000042   7417         MOV       A,#0x17
   \   000044   12....       LCALL     ?XSTACK_DISP0_8
   \   000047   E0           MOVX      A,@DPTR
   \   000048   F5..         MOV       ?V1,A
   \   00004A   78..         MOV       R0,#?V1
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004F   E4           CLR       A
   \   000050   F5..         MOV       ?V2,A
   \   000052   78..         MOV       R0,#?V2
   \   000054   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000057   7419         MOV       A,#0x19
   \   000059   12....       LCALL     ?XSTACK_DISP0_8
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F5..         MOV       ?V1,A
   \   00005F   78..         MOV       R0,#?V1
   \   000061   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000064   7419         MOV       A,#0x19
   \   000066   12....       LCALL     ?XSTACK_DISP0_8
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   F5..         MOV       ?V1,A
   \   00006C   78..         MOV       R0,#?V1
   \   00006E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000071   75..00       MOV       ?V1,#0x0
   \   000074   78..         MOV       R0,#?V1
   \   000076   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000079   75..15       MOV       ?V1,#0x15
   \   00007C   78..         MOV       R0,#?V1
   \   00007E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000081   A9..         MOV       R1,?V0
   \   000083   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000086   740B         MOV       A,#0xb
   \   000088   12....       LCALL     ?DEALLOC_XSTACK8
   \   00008B   7403         MOV       A,#0x3
   \   00008D   02....       LJMP      ?Subroutine3 & 0xFFFF
   2103          }
   2104          
   2105          /*********************************************************************
   2106           * @fn      zcl_SendDiscoverAttrsExtRsp
   2107           *
   2108           * @brief   Send a Discover Attributes Extended Response command
   2109           *
   2110           * @param   dstAddr - destination address
   2111           * @param   clusterID - cluster ID
   2112           * @param   pDiscoverRspCmd:
   2113           *            - discComplete: indicates whether all requested attributes returned
   2114           *            - attrID: attribute ID
   2115           *            - attrDataType: data type of the given attribute
   2116           *            - attrAccessControl: access control of the given attribute
   2117           * @param   direction - direction of the command
   2118           * @param   seqNum - transaction sequence number
   2119           *
   2120           * @return  ZSuccess if OK
   2121           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2122          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendDiscoverAttrsExtRsp:
   2123                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   2124                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   2125          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V10,R1
   \   000007   8A..         MOV       ?V8,R2
   \   000009   8B..         MOV       ?V9,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
   \   00000F   7418         MOV       A,#0x18
   \   000011   12....       LCALL     ?XSTACK_DISP0_8
   \   000014   12....       LCALL     ?Subroutine54 & 0xFFFF
   2126            uint8 *buf;
   2127            uint8 i;
   2128            uint16 dataLen = 1; // Discovery complete
   2129            ZStatus_t status;
   2130          
   2131            // calculate the size of the command
   2132            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   \                     ??CrossCallReturnLabel_72:
   \   000017   F5..         MOV       ?V0,A
   \   000019   75..00       MOV       ?V1,#0x0
   \   00001C   7402         MOV       A,#0x2
   \   00001E   78..         MOV       R0,#?V0
   \   000020   12....       LCALL     ?S_SHL
   \   000023   E5..         MOV       A,?V0
   \   000025   2401         ADD       A,#0x1
   \   000027   F5..         MOV       ?V6,A
   \   000029   E4           CLR       A
   \   00002A   35..         ADDC      A,?V1
   \   00002C   F5..         MOV       ?V7,A
   2133          
   2134            buf = zcl_mem_alloc( dataLen );
   \   00002E                ; Setup parameters for call to function osal_mem_alloc
   \   00002E   AA..         MOV       R2,?V6
   \   000030   FB           MOV       R3,A
   \   000031   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000034   8A..         MOV       ?V0,R2
   \   000036   8B..         MOV       ?V1,R3
   2135            if ( buf != NULL )
   \   000038   EA           MOV       A,R2
   \   000039   45..         ORL       A,?V1
   \   00003B   7003         JNZ       $+5
   \   00003D   02....       LJMP      ??zcl_SendDiscoverAttrsExtRsp_0 & 0xFFFF
   2136            {
   2137              // Load the buffer - serially
   2138              uint8 *pBuf = buf;
   2139              *pBuf++ = pDiscoverRspCmd->discComplete;
   \   000040   85..82       MOV       DPL,?V4
   \   000043   85..83       MOV       DPH,?V5
   \   000046   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000049   A3           INC       DPTR
   \   00004A   AA82         MOV       R2,DPL
   \   00004C   AB83         MOV       R3,DPH
   2140              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   \   00004E   7900         MOV       R1,#0x0
   \   000050   803A         SJMP      ??zcl_SendDiscoverAttrsExtRsp_1
   2141              {
   2142                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   \                     ??zcl_SendDiscoverAttrsExtRsp_2:
   \   000052   E9           MOV       A,R1
   \   000053   F5..         MOV       ?V12,A
   \   000055   75..00       MOV       ?V13,#0x0
   \   000058   7402         MOV       A,#0x2
   \   00005A   78..         MOV       R0,#?V12
   \   00005C   12....       LCALL     ?S_SHL
   \   00005F   E5..         MOV       A,?V4
   \   000061   25..         ADD       A,?V12
   \   000063   FC           MOV       R4,A
   \   000064   E5..         MOV       A,?V5
   \   000066   35..         ADDC      A,?V13
   \   000068   12....       LCALL     ?Subroutine111 & 0xFFFF
   2143                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   2144                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   2145                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   2146              }
   \                     ??CrossCallReturnLabel_193:
   \   00006B   12....       LCALL     ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   00006E   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000071   12....       LCALL     ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000074   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000077   12....       LCALL     ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   00007A   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00007D   A3           INC       DPTR
   \   00007E   12....       LCALL     ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000081   A3           INC       DPTR
   \   000082   A3           INC       DPTR
   \   000083   F0           MOVX      @DPTR,A
   \   000084   EA           MOV       A,R2
   \   000085   2404         ADD       A,#0x4
   \   000087   FA           MOV       R2,A
   \   000088   5001         JNC       ??zcl_SendDiscoverAttrsExtRsp_3
   \   00008A   0B           INC       R3
   \                     ??zcl_SendDiscoverAttrsExtRsp_3:
   \   00008B   09           INC       R1
   \                     ??zcl_SendDiscoverAttrsExtRsp_1:
   \   00008C   85..82       MOV       DPL,?V2
   \   00008F   85..83       MOV       DPH,?V3
   \   000092   E0           MOVX      A,@DPTR
   \   000093   F8           MOV       R0,A
   \   000094   E9           MOV       A,R1
   \   000095   C3           CLR       C
   \   000096   98           SUBB      A,R0
   \   000097   40B9         JC        ??zcl_SendDiscoverAttrsExtRsp_2
   2147          
   2148              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   2149                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000099                ; Setup parameters for call to function zcl_SendCommand
   \   000099   78..         MOV       R0,#?V0
   \   00009B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009E   78..         MOV       R0,#?V6
   \   0000A0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A3   7420         MOV       A,#0x20
   \   0000A5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A8   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_486:
   \   0000AB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000AE   E4           CLR       A
   \   0000AF   F5..         MOV       ?V2,A
   \   0000B1   F5..         MOV       ?V3,A
   \   0000B3   78..         MOV       R0,#?V2
   \   0000B5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B8   7422         MOV       A,#0x22
   \   0000BA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_487:
   \   0000C0   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C3   7422         MOV       A,#0x22
   \   0000C5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C8   12....       LCALL     ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_488:
   \   0000CB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000CE   75..00       MOV       ?V2,#0x0
   \   0000D1   78..         MOV       R0,#?V2
   \   0000D3   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D6   75..16       MOV       ?V2,#0x16
   \   0000D9   78..         MOV       R0,#?V2
   \   0000DB   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000DE   EE           MOV       A,R6
   \   0000DF   FC           MOV       R4,A
   \   0000E0   EF           MOV       A,R7
   \   0000E1   FD           MOV       R5,A
   \   0000E2   AA..         MOV       R2,?V8
   \   0000E4   AB..         MOV       R3,?V9
   \   0000E6   A9..         MOV       R1,?V10
   \   0000E8   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   0000EB   740B         MOV       A,#0xb
   \   0000ED   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000F0   E9           MOV       A,R1
   \   0000F1   FE           MOV       R6,A
   2150              zcl_mem_free( buf );
   \   0000F2                ; Setup parameters for call to function osal_mem_free
   \   0000F2   AA..         MOV       R2,?V0
   \   0000F4   AB..         MOV       R3,?V1
   \   0000F6   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000F9   8002         SJMP      ??zcl_SendDiscoverAttrsExtRsp_4
   2151            }
   2152            else
   2153            {
   2154              status = ZMemError;
   \                     ??zcl_SendDiscoverAttrsExtRsp_0:
   \   0000FB   7E10         MOV       R6,#0x10
   2155            }
   2156          
   2157            return ( status );
   \                     ??zcl_SendDiscoverAttrsExtRsp_4:
   \   0000FD   02....       LJMP      ?Subroutine11 & 0xFFFF
   2158          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   A3           INC       DPTR
   \   000001   F0           MOVX      @DPTR,A
   \   000002   8C82         MOV       DPL,R4
   \   000004   8D83         MOV       DPH,R5
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL     ??Subroutine187_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_393:
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   12....       LCALL     ??Subroutine187_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_394:
   \   000003   A3           INC       DPTR
   \   000004   22           RET
   2159          #endif // ZCL_DISCOVER
   2160          
   2161          /*********************************************************************
   2162           * @fn      zcl_ProcessMessageMSG
   2163           *
   2164           * @brief   Data message processor callback.  This function processes
   2165           *          any incoming data - probably from other devices.  So, based
   2166           *          on cluster ID, perform the intended action.
   2167           *
   2168           * @param   pkt - incoming message
   2169           *
   2170           * @return  zclProcMsgStatus_t
   2171           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2172          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   2173          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV       A,#-0x15
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2174            endPointDesc_t *epDesc;
   2175            zclIncoming_t inMsg;
   2176            zclLibPlugin_t *pInPlugin;
   2177            zclDefaultRspCmd_t defautlRspCmd;
   2178            uint8 options;
   2179            uint8 securityEnable;
   2180            uint8 interPanMsg;
   2181            ZStatus_t status = ZFailure;
   2182            uint8 defaultResponseSent = FALSE;
   \   00000E   C2..         CLR       ?VB.0
   2183          
   2184            if ( pkt->cmd.DataLength < ZCL_VALID_MIN_HEADER_LEN  )
   \   000010   EE           MOV       A,R6
   \   000011   2420         ADD       A,#0x20
   \   000013   F8           MOV       R0,A
   \   000014   E4           CLR       A
   \   000015   3F           ADDC      A,R7
   \   000016   F9           MOV       R1,A
   \   000017   88..         MOV       ?V0,R0
   \   000019   89..         MOV       ?V1,R1
   \   00001B   8882         MOV       DPL,R0
   \   00001D   F583         MOV       DPH,A
   \   00001F   C3           CLR       C
   \   000020   E0           MOVX      A,@DPTR
   \   000021   9403         SUBB      A,#0x3
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   9400         SUBB      A,#0x0
   \   000027   5005         JNC       ??zcl_ProcessMessageMSG_0
   2185            {
   2186              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   000029   7901         MOV       R1,#0x1
   \   00002B   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2187            }
   2188          
   2189            // Initialize
   2190            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   00002E   90....       MOV       DPTR,#rawAFMsg
   \   000031   EE           MOV       A,R6
   \   000032   F0           MOVX      @DPTR,A
   \   000033   A3           INC       DPTR
   \   000034   EF           MOV       A,R7
   \   000035   F0           MOVX      @DPTR,A
   2191            inMsg.msg = pkt;
   \   000036   7402         MOV       A,#0x2
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   EE           MOV       A,R6
   \   00003C   F0           MOVX      @DPTR,A
   \   00003D   A3           INC       DPTR
   \   00003E   EF           MOV       A,R7
   \   00003F   F0           MOVX      @DPTR,A
   2192            inMsg.attrCmd = NULL;
   \   000040   740E         MOV       A,#0xe
   \   000042   12....       LCALL     ?XSTACK_DISP0_8
   \   000045   E4           CLR       A
   \   000046   F0           MOVX      @DPTR,A
   \   000047   A3           INC       DPTR
   \   000048   F0           MOVX      @DPTR,A
   2193            inMsg.pData = NULL;
   \   000049   740A         MOV       A,#0xa
   \   00004B   12....       LCALL     ?XSTACK_DISP0_8
   \   00004E   E4           CLR       A
   \   00004F   F0           MOVX      @DPTR,A
   \   000050   A3           INC       DPTR
   \   000051   F0           MOVX      @DPTR,A
   2194            inMsg.pDataLen = 0;
   \   000052   740C         MOV       A,#0xc
   \   000054   12....       LCALL     ?XSTACK_DISP0_8
   \   000057   E4           CLR       A
   \   000058   F0           MOVX      @DPTR,A
   \   000059   A3           INC       DPTR
   \   00005A   F0           MOVX      @DPTR,A
   2195          
   2196            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   00005B   EE           MOV       A,R6
   \   00005C   2422         ADD       A,#0x22
   \   00005E   F8           MOV       R0,A
   \   00005F   E4           CLR       A
   \   000060   3F           ADDC      A,R7
   \   000061   F9           MOV       R1,A
   \   000062   88..         MOV       ?V2,R0
   \   000064   89..         MOV       ?V3,R1
   \   000066                ; Setup parameters for call to function zclParseHdr
   \   000066   8882         MOV       DPL,R0
   \   000068   F583         MOV       DPH,A
   \   00006A   12....       LCALL     ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_464:
   \   00006D   7404         MOV       A,#0x4
   \   00006F   12....       LCALL     ?XSTACK_DISP0_8
   \   000072   AA82         MOV       R2,DPL
   \   000074   AB83         MOV       R3,DPH
   \   000076   12....       LCALL     `??zclParseHdr::?relay`; Banked call to: zclParseHdr
   \   000079   8A..         MOV       ?V4,R2
   \   00007B   8B..         MOV       ?V5,R3
   \   00007D   A8..         MOV       R0,?V4
   \   00007F   A9..         MOV       R1,?V5
   \   000081   740A         MOV       A,#0xa
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   2197            inMsg.pDataLen = pkt->cmd.DataLength;
   2198            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_420:
   \   000089   85..82       MOV       DPL,?V0
   \   00008C   85..83       MOV       DPH,?V1
   \   00008F   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_439:
   \   000092   EA           MOV       A,R2
   \   000093   C3           CLR       C
   \   000094   98           SUBB      A,R0
   \   000095   F8           MOV       R0,A
   \   000096   EB           MOV       A,R3
   \   000097   99           SUBB      A,R1
   \   000098   F9           MOV       R1,A
   \   000099   85..82       MOV       DPL,?V2
   \   00009C   85..83       MOV       DPH,?V3
   \   00009F   E0           MOVX      A,@DPTR
   \   0000A0   28           ADD       A,R0
   \   0000A1   F8           MOV       R0,A
   \   0000A2   A3           INC       DPTR
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   39           ADDC      A,R1
   \   0000A5   F9           MOV       R1,A
   \   0000A6   740C         MOV       A,#0xc
   \   0000A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AB   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   2199          
   2200            // Temporary workaround to allow callback functions access to the
   2201            // transaction sequence number.  Callback functions will call
   2202            // zcl_getParsedTransSeqNum() to retrieve this number.
   2203            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_421:
   \   0000AE   7408         MOV       A,#0x8
   \   0000B0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   90....       MOV       DPTR,#savedZCLTransSeqNum
   \   0000B7   F0           MOVX      @DPTR,A
   2204          
   2205            // Find the wanted endpoint
   2206            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000B8   EE           MOV       A,R6
   \   0000B9   2414         ADD       A,#0x14
   \   0000BB   12....       LCALL     ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   0000BE   E0           MOVX      A,@DPTR
   \   0000BF   F9           MOV       R1,A
   \   0000C0   12....       LCALL     `??afFindEndPointDesc::?relay`; Banked call to: afFindEndPointDesc
   \   0000C3   8A82         MOV       DPL,R2
   \   0000C5   8B83         MOV       DPH,R3
   2207            if ( epDesc == NULL )
   \   0000C7   E582         MOV       A,DPL
   \   0000C9   4583         ORL       A,DPH
   \   0000CB   700C         JNZ       ??zcl_ProcessMessageMSG_2
   2208            {
   2209              rawAFMsg = NULL;
   \   0000CD   90....       MOV       DPTR,#rawAFMsg
   \   0000D0   E4           CLR       A
   \   0000D1   F0           MOVX      @DPTR,A
   \   0000D2   A3           INC       DPTR
   \   0000D3   F0           MOVX      @DPTR,A
   2210              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000D4   7902         MOV       R1,#0x2
   \   0000D6   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2211            }
   2212          
   2213            if ( ( epDesc->simpleDesc == NULL ) ||
   2214                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   2215                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000D9   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   0000DC   602B         JZ        ??zcl_ProcessMessageMSG_3
   \   0000DE   EE           MOV       A,R6
   \   0000DF   2404         ADD       A,#0x4
   \   0000E1   F5..         MOV       ?V2,A
   \   0000E3   E4           CLR       A
   \   0000E4   3F           ADDC      A,R7
   \   0000E5   F5..         MOV       ?V3,A
   \   0000E7                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000E7   A3           INC       DPTR
   \   0000E8   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0000EB   740B         MOV       A,#0xb
   \   0000ED   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F0   E0           MOVX      A,@DPTR
   \   0000F1   FD           MOV       R5,A
   \   0000F2   7406         MOV       A,#0x6
   \   0000F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F7   E0           MOVX      A,@DPTR
   \   0000F8   5403         ANL       A,#0x3
   \   0000FA   FC           MOV       R4,A
   \   0000FB   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000FE   12....       LCALL     `??zcl_DeviceOperational::?relay`; Banked call to: zcl_DeviceOperational
   \   000101   7402         MOV       A,#0x2
   \   000103   12....       LCALL     ?DEALLOC_XSTACK8
   \   000106   E9           MOV       A,R1
   \   000107   700C         JNZ       ??zcl_ProcessMessageMSG_4
   2216            {
   2217              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   000109   90....       MOV       DPTR,#rawAFMsg
   \   00010C   E4           CLR       A
   \   00010D   F0           MOVX      @DPTR,A
   \   00010E   A3           INC       DPTR
   \   00010F   F0           MOVX      @DPTR,A
   2218              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   000110   7903         MOV       R1,#0x3
   \   000112   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2219            }
   2220          
   2221          #if defined ( INTER_PAN )
   2222            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   2223            {
   2224              // No foundation command is supported thru Inter-PAN communication.
   2225              // But the Light Link cluster uses a different Frame Control format
   2226              // for it's Inter-PAN messages, where the messages could be confused
   2227              // with the foundation commands.
   2228              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   2229              {
   2230                rawAFMsg = NULL;
   2231                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   2232              }
   2233          
   2234              interPanMsg = TRUE;
   2235              options = AF_TX_OPTIONS_NONE;
   2236            }
   2237            else
   2238          #endif
   2239            {
   2240              interPanMsg = FALSE;
   2241              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   000115                ; Setup parameters for call to function zclGetClusterOption
   \   000115   12....       LCALL     ?Subroutine50 & 0xFFFF
   2242            }
   \                     ??CrossCallReturnLabel_61:
   \   000118   12....       LCALL     `??zclGetClusterOption::?relay`; Banked call to: zclGetClusterOption
   \   00011B   E9           MOV       A,R1
   \   00011C   F5..         MOV       ?V6,A
   2243          
   2244            // Find the appropriate plugin
   2245            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   00011E   85..82       MOV       DPL,?V2
   \   000121   85..83       MOV       DPH,?V3
   \   000124   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_440:
   \   000127   EA           MOV       A,R2
   \   000128   FC           MOV       R4,A
   \   000129   EB           MOV       A,R3
   \   00012A   FD           MOV       R5,A
   \   00012B   90....       MOV       DPTR,#plugins
   \   00012E   8004         SJMP      ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   000130   8882         MOV       DPL,R0
   \   000132   8983         MOV       DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   000134   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_343:
   \   000137   7003         JNZ       $+5
   \   000139   02....       LJMP      ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   00013C   8882         MOV       DPL,R0
   \   00013E   8983         MOV       DPH,R1
   \   000140   A3           INC       DPTR
   \   000141   A3           INC       DPTR
   \   000142   12....       LCALL     ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000145   C3           CLR       C
   \   000146   EC           MOV       A,R4
   \   000147   95..         SUBB      A,?V4
   \   000149   ED           MOV       A,R5
   \   00014A   95..         SUBB      A,?V5
   \   00014C   40E2         JC        ??zcl_ProcessMessageMSG_6
   \   00014E   8882         MOV       DPL,R0
   \   000150   8983         MOV       DPH,R1
   \   000152   A3           INC       DPTR
   \   000153   A3           INC       DPTR
   \   000154   A3           INC       DPTR
   \   000155   A3           INC       DPTR
   \   000156   C3           CLR       C
   \   000157   E0           MOVX      A,@DPTR
   \   000158   9C           SUBB      A,R4
   \   000159   A3           INC       DPTR
   \   00015A   E0           MOVX      A,@DPTR
   \   00015B   9D           SUBB      A,R5
   \   00015C   40D2         JC        ??zcl_ProcessMessageMSG_6
   \   00015E   E8           MOV       A,R0
   \   00015F   FC           MOV       R4,A
   \   000160   E9           MOV       A,R1
   \   000161   FD           MOV       R5,A
   \   000162   7404         MOV       A,#0x4
   \   000164   12....       LCALL     ?XSTACK_DISP0_8
   \   000167   E0           MOVX      A,@DPTR
   \   000168   5407         ANL       A,#0x7
   \   00016A   700D         JNZ       ??zcl_ProcessMessageMSG_8
   \   00016C   7409         MOV       A,#0x9
   \   00016E   12....       LCALL     ?XSTACK_DISP0_8
   \   000171   E0           MOVX      A,@DPTR
   \   000172   640B         XRL       A,#0xb
   \   000174   7003         JNZ       $+5
   \   000176   02....       LJMP      ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2246          
   2247            // Local and remote Security options must match except for Default Response command
   2248            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   2249            {
   2250              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   000179   E5..         MOV       A,?V6
   \   00017B   A2E6         MOV       C,0xE0 /* A   */.6
   \   00017D   4003         JC        $+5
   \   00017F   02....       LJMP      ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   000182   EE           MOV       A,R6
   \   000183   2419         ADD       A,#0x19
   \   000185   F582         MOV       DPL,A
   \   000187   E4           CLR       A
   \   000188   3F           ADDC      A,R7
   \   000189   F583         MOV       DPH,A
   \   00018B   E0           MOVX      A,@DPTR
   \   00018C   6003         JZ        $+5
   \   00018E   02....       LJMP      ??zcl_ProcessMessageMSG_9 & 0xFFFF
   2251          
   2252              // Make sure that Clusters specifically defined to use security are received secure,
   2253              // any other cluster that wants to use APS security will be allowed
   2254              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   2255              {
   2256                if ( UNICAST_MSG( inMsg.msg ) )
   \   000191   7402         MOV       A,#0x2
   \   000193   12....       LCALL     ?XSTACK_DISP0_8
   \   000196   12....       LCALL     ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000199   707F         JNZ       ??zcl_ProcessMessageMSG_10
   \   00019B   7402         MOV       A,#0x2
   \   00019D   12....       LCALL     ?XSTACK_DISP0_8
   \   0001A0   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_351:
   \   0001A3   7075         JNZ       ??zcl_ProcessMessageMSG_10
   2257                {
   2258                  // Send a Default Response command back with no Application Link Key security
   2259                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   0001A5                ; Setup parameters for call to function zclSetSecurityOption
   \   0001A5   7C00         MOV       R4,#0x0
   \   0001A7   85..82       MOV       DPL,?V0
   \   0001AA   85..83       MOV       DPH,?V1
   \   0001AD   E0           MOVX      A,@DPTR
   \   0001AE   F9           MOV       R1,A
   \   0001AF   12....       LCALL     `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2260          
   2261                  defautlRspCmd.statusCode = status;
   \   0001B2   7401         MOV       A,#0x1
   \   0001B4   12....       LCALL     ?XSTACK_DISP0_8
   \   0001B7   7401         MOV       A,#0x1
   \   0001B9   F0           MOVX      @DPTR,A
   2262                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001BA   7409         MOV       A,#0x9
   \   0001BC   12....       LCALL     ?XSTACK_DISP0_8
   \   0001BF   12....       LCALL     ?Subroutine82 & 0xFFFF
   2263                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2264                                         inMsg.msg->clusterId, &defautlRspCmd,
   2265                                         !inMsg.hdr.fc.direction, true,
   2266                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_134:
   \   0001C2   12....       LCALL     ?XSTACK_DISP0_8
   \   0001C5   E0           MOVX      A,@DPTR
   \   0001C6   F5..         MOV       ?V4,A
   \   0001C8   78..         MOV       R0,#?V4
   \   0001CA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001CD   7407         MOV       A,#0x7
   \   0001CF   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D2   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0001D5   75..01       MOV       ?V4,#0x1
   \   0001D8   78..         MOV       R0,#?V4
   \   0001DA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001DD   7408         MOV       A,#0x8
   \   0001DF   12....       LCALL     ?XSTACK_DISP0_8
   \   0001E2   12....       LCALL     ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_509:
   \   0001E5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0001E8   7405         MOV       A,#0x5
   \   0001EA   12....       LCALL     ?XSTACK_DISP100_8
   \   0001ED   88..         MOV       ?V4,R0
   \   0001EF   89..         MOV       ?V5,R1
   \   0001F1   78..         MOV       R0,#?V4
   \   0001F3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001F6   7409         MOV       A,#0x9
   \   0001F8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001FB   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0001FE   12....       LCALL     ?XSTACK_DISP0_8
   \   000201   12....       LCALL     ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000204   12....       LCALL     ?XSTACK_DISP0_8
   \   000207   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00020A   12....       LCALL     `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   00020D   7407         MOV       A,#0x7
   \   00020F   12....       LCALL     ?DEALLOC_XSTACK8
   2267          
   2268                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   000212                ; Setup parameters for call to function zclSetSecurityOption
   \   000212   7C01         MOV       R4,#0x1
   \   000214   12....       LCALL     ?Subroutine50 & 0xFFFF
   2269                }
   \                     ??CrossCallReturnLabel_62:
   \   000217   12....       LCALL     `??zclSetSecurityOption::?relay`; Banked call to: zclSetSecurityOption
   2270          
   2271                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   00021A   90....       MOV       DPTR,#rawAFMsg
   \   00021D   E4           CLR       A
   \   00021E   F0           MOVX      @DPTR,A
   \   00021F   A3           INC       DPTR
   \   000220   F0           MOVX      @DPTR,A
   2272                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   000221   7905         MOV       R1,#0x5
   \   000223   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2273              }
   2274            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   000226   7C00         MOV       R4,#0x0
   \   000228   7D00         MOV       R5,#0x0
   2275          
   2276            // Is this a foundation type message
   2277            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   00022A   7404         MOV       A,#0x4
   \   00022C   12....       LCALL     ?XSTACK_DISP0_8
   \   00022F   E0           MOVX      A,@DPTR
   \   000230   F8           MOV       R0,A
   \   000231   5403         ANL       A,#0x3
   \   000233   6003         JZ        $+5
   \   000235   02....       LJMP      ??zcl_ProcessMessageMSG_11 & 0xFFFF
   2278            {
   2279              if ( inMsg.hdr.fc.manuSpecific )
   \   000238   E8           MOV       A,R0
   \   000239   5404         ANL       A,#0x4
   \   00023B   6005         JZ        ??zcl_ProcessMessageMSG_12
   2280              {
   2281                // We don't support any manufacturer specific command
   2282                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   00023D   7E84         MOV       R6,#-0x7c
   \   00023F   02....       LJMP      ??zcl_ProcessMessageMSG_13 & 0xFFFF
   2283              }
   2284              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2285                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   000242   7409         MOV       A,#0x9
   \   000244   12....       LCALL     ?XSTACK_DISP0_8
   \   000247   E0           MOVX      A,@DPTR
   \   000248   F8           MOV       R0,A
   \   000249   C3           CLR       C
   \   00024A   9417         SUBB      A,#0x17
   \   00024C   4003         JC        $+5
   \   00024E   02....       LJMP      ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   000251   E8           MOV       A,R0
   \   000252   F5..         MOV       ?V2,A
   \   000254   75..00       MOV       ?V3,#0x0
   \   000257   7402         MOV       A,#0x2
   \   000259   78..         MOV       R0,#?V2
   \   00025B   12....       LCALL     ?S_SHL
   \   00025E   74..         MOV       A,#zclCmdTable & 0xff
   \   000260   25..         ADD       A,?V2
   \   000262   F582         MOV       DPL,A
   \   000264   74..         MOV       A,#(zclCmdTable >> 8) & 0xff
   \   000266   35..         ADDC      A,?V3
   \   000268   12....       LCALL     ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   00026B   E8           MOV       A,R0
   \   00026C   49           ORL       A,R1
   \   00026D   7003         JNZ       $+5
   \   00026F   02....       LJMP      ??zcl_ProcessMessageMSG_14 & 0xFFFF
   2286              {
   2287                zclParseCmd_t parseCmd;
   2288          
   2289                parseCmd.endpoint = pkt->endPoint;
   \   000272   85..82       MOV       DPL,?V0
   \   000275   85..83       MOV       DPH,?V1
   \   000278   E0           MOVX      A,@DPTR
   \   000279   C0E0         PUSH      A
   \   00027B   7410         MOV       A,#0x10
   \   00027D   12....       LCALL     ?XSTACK_DISP0_8
   \   000280   D0E0         POP       A
   \   000282   F0           MOVX      @DPTR,A
   2290                parseCmd.dataLen = inMsg.pDataLen;
   \   000283   740C         MOV       A,#0xc
   \   000285   12....       LCALL     ?XSTACK_DISP0_8
   \   000288   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_441:
   \   00028B   7411         MOV       A,#0x11
   \   00028D   12....       LCALL     ?XSTACK_DISP0_8
   \   000290   12....       LCALL     ??Subroutine171_0 & 0xFFFF
   2291                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_292:
   \   000293   740A         MOV       A,#0xa
   \   000295   12....       LCALL     ?XSTACK_DISP0_8
   \   000298   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_442:
   \   00029B   7413         MOV       A,#0x13
   \   00029D   12....       LCALL     ?XSTACK_DISP0_8
   \   0002A0   12....       LCALL     ??Subroutine171_0 & 0xFFFF
   2292          
   2293                // Parse the command, remember that the return value is a pointer to allocated memory
   2294                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_293:
   \   0002A3                ; Setup parameters for indirect call
   \   0002A3   7410         MOV       A,#0x10
   \   0002A5   12....       LCALL     ?XSTACK_DISP101_8
   \   0002A8   8882         MOV       DPL,R0
   \   0002AA   8983         MOV       DPH,R1
   \   0002AC   12....       LCALL     ?CALL_IND
   \   0002AF   8A..         MOV       ?V0,R2
   \   0002B1   8B..         MOV       ?V1,R3
   \   0002B3   A8..         MOV       R0,?V0
   \   0002B5   A9..         MOV       R1,?V1
   \   0002B7   740E         MOV       A,#0xe
   \   0002B9   12....       LCALL     ?XSTACK_DISP0_8
   \   0002BC   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   2295                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_422:
   \   0002BF   E8           MOV       A,R0
   \   0002C0   49           ORL       A,R1
   \   0002C1   6046         JZ        ??zcl_ProcessMessageMSG_15
   \   0002C3   7409         MOV       A,#0x9
   \   0002C5   12....       LCALL     ?XSTACK_DISP0_8
   \   0002C8   E0           MOVX      A,@DPTR
   \   0002C9   F5..         MOV       ?V0,A
   \   0002CB   75..00       MOV       ?V1,#0x0
   \   0002CE   7402         MOV       A,#0x2
   \   0002D0   78..         MOV       R0,#?V0
   \   0002D2   12....       LCALL     ?S_SHL
   \   0002D5   74..         MOV       A,#(zclCmdTable + 2) & 0xff
   \   0002D7   25..         ADD       A,?V0
   \   0002D9   F582         MOV       DPL,A
   \   0002DB   74..         MOV       A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002DD   35..         ADDC      A,?V1
   \   0002DF   12....       LCALL     ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   0002E2   8882         MOV       DPL,R0
   \   0002E4   8983         MOV       DPH,R1
   \   0002E6   E582         MOV       A,DPL
   \   0002E8   4583         ORL       A,DPH
   \   0002EA   6012         JZ        ??zcl_ProcessMessageMSG_16
   2296                {
   2297                  // Process the command
   2298                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0002EC                ; Setup parameters for indirect call
   \   0002EC   7402         MOV       A,#0x2
   \   0002EE   12....       LCALL     ?XSTACK_DISP101_8
   \   0002F1   12....       LCALL     ?CALL_IND
   2299                  {
   2300                    // Couldn't find attribute in the table.
   2301                  }
   2302                }
   2303          
   2304                // Free the buffer
   2305                if ( inMsg.attrCmd )
   \   0002F4   740E         MOV       A,#0xe
   \   0002F6   12....       LCALL     ?XSTACK_DISP0_8
   \   0002F9   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   0002FC   600B         JZ        ??zcl_ProcessMessageMSG_15
   2306                {
   2307                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   0002FE                ; Setup parameters for call to function osal_mem_free
   \   0002FE   740E         MOV       A,#0xe
   \   000300   12....       LCALL     ?XSTACK_DISP0_8
   \   000303   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   2308                }
   \                     ??CrossCallReturnLabel_443:
   \   000306   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2309          
   2310                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_15:
   \   000309   7409         MOV       A,#0x9
   \   00030B   12....       LCALL     ?XSTACK_DISP0_8
   \   00030E   E0           MOVX      A,@DPTR
   \   00030F   F8           MOV       R0,A
   \   000310   6058         JZ        ??zcl_ProcessMessageMSG_17
   \   000312   7402         MOV       A,#0x2
   \   000314   68           XRL       A,R0
   \   000315   6053         JZ        ??zcl_ProcessMessageMSG_17
   \   000317   7403         MOV       A,#0x3
   \   000319   68           XRL       A,R0
   \   00031A   604E         JZ        ??zcl_ProcessMessageMSG_17
   \   00031C   7405         MOV       A,#0x5
   \   00031E   68           XRL       A,R0
   \   00031F   6049         JZ        ??zcl_ProcessMessageMSG_17
   \   000321   7406         MOV       A,#0x6
   \   000323   68           XRL       A,R0
   \   000324   6044         JZ        ??zcl_ProcessMessageMSG_17
   \   000326   7408         MOV       A,#0x8
   \   000328   68           XRL       A,R0
   \   000329   603F         JZ        ??zcl_ProcessMessageMSG_17
   \   00032B   740C         MOV       A,#0xc
   \   00032D   68           XRL       A,R0
   \   00032E   603A         JZ        ??zcl_ProcessMessageMSG_17
   \   000330   7411         MOV       A,#0x11
   \   000332   68           XRL       A,R0
   \   000333   6035         JZ        ??zcl_ProcessMessageMSG_17
   \   000335   7413         MOV       A,#0x13
   \   000337   68           XRL       A,R0
   \   000338   6030         JZ        ??zcl_ProcessMessageMSG_17
   \   00033A   7415         MOV       A,#0x15
   \   00033C   68           XRL       A,R0
   \   00033D   602B         JZ        ??zcl_ProcessMessageMSG_17
   \   00033F   740B         MOV       A,#0xb
   \   000341   68           XRL       A,R0
   \   000342   6026         JZ        ??zcl_ProcessMessageMSG_17
   2311                {
   2312                  rawAFMsg = NULL;
   2313                  return ( ZCL_PROC_SUCCESS ); // We're done
   2314                }
   2315          
   2316                status = ZSuccess;
   \   000344   7E00         MOV       R6,#0x0
   \   000346   8042         SJMP      ??zcl_ProcessMessageMSG_13
   2317              }
   2318              else
   2319              {
   2320                // Unsupported message
   2321                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   000348   7E82         MOV       R6,#-0x7e
   \   00034A   803E         SJMP      ??zcl_ProcessMessageMSG_13
   2322              }
   2323            }
   2324            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2325            {
   2326              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_11:
   \   00034C   EC           MOV       A,R4
   \   00034D   4D           ORL       A,R5
   \   00034E   602A         JZ        ??zcl_ProcessMessageMSG_18
   \   000350   8C82         MOV       DPL,R4
   \   000352   8D83         MOV       DPH,R5
   \   000354   A3           INC       DPTR
   \   000355   A3           INC       DPTR
   \   000356   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000359   601F         JZ        ??zcl_ProcessMessageMSG_18
   2327              {
   2328                // The return value of the plugin function will be
   2329                //  ZSuccess - Supported and need default response
   2330                //  ZFailure - Unsupported
   2331                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2332                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2333                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2334                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2335                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   00035B                ; Setup parameters for indirect call
   \   00035B   7402         MOV       A,#0x2
   \   00035D   12....       LCALL     ?XSTACK_DISP101_8
   \   000360   12....       LCALL     ?CALL_IND
   \   000363   E9           MOV       A,R1
   \   000364   FE           MOV       R6,A
   2336                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000365   74FF         MOV       A,#-0x1
   \   000367   6E           XRL       A,R6
   \   000368   700B         JNZ       ??zcl_ProcessMessageMSG_19
   2337                {
   2338                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   00036A   90....       MOV       DPTR,#rawAFMsg
   \   00036D   E4           CLR       A
   \   00036E   F0           MOVX      @DPTR,A
   \   00036F   A3           INC       DPTR
   \   000370   F0           MOVX      @DPTR,A
   2339                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   000371   F9           MOV       R1,A
   \   000372   02....       LJMP      ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2340                }
   2341              }
   2342          
   2343              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   000375   7401         MOV       A,#0x1
   \   000377   6E           XRL       A,R6
   \   000378   7010         JNZ       ??zcl_ProcessMessageMSG_13
   2344              {
   2345                // Unsupported message
   2346                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   00037A   7404         MOV       A,#0x4
   \   00037C   12....       LCALL     ?XSTACK_DISP0_8
   \   00037F   E0           MOVX      A,@DPTR
   \   000380   5404         ANL       A,#0x4
   \   000382   6004         JZ        ??zcl_ProcessMessageMSG_20
   2347                {
   2348                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000384   7E83         MOV       R6,#-0x7d
   \   000386   8002         SJMP      ??zcl_ProcessMessageMSG_13
   2349                }
   2350                else
   2351                {
   2352                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   000388   7E81         MOV       R6,#-0x7f
   2353                }
   2354              }
   2355            }
   2356          
   2357            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   00038A   7402         MOV       A,#0x2
   \   00038C   12....       LCALL     ?XSTACK_DISP0_8
   \   00038F   12....       LCALL     ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000392   7070         JNZ       ??zcl_ProcessMessageMSG_21
   \   000394   7402         MOV       A,#0x2
   \   000396   12....       LCALL     ?XSTACK_DISP0_8
   \   000399   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_352:
   \   00039C   7066         JNZ       ??zcl_ProcessMessageMSG_21
   \   00039E   7404         MOV       A,#0x4
   \   0003A0   12....       LCALL     ?XSTACK_DISP0_8
   \   0003A3   E0           MOVX      A,@DPTR
   \   0003A4   FA           MOV       R2,A
   \   0003A5   5410         ANL       A,#0x10
   \   0003A7   705B         JNZ       ??zcl_ProcessMessageMSG_21
   2358            {
   2359              // Send a Default Response command back
   2360              defautlRspCmd.statusCode = status;
   \   0003A9   7401         MOV       A,#0x1
   \   0003AB   12....       LCALL     ?XSTACK_DISP0_8
   \   0003AE   EE           MOV       A,R6
   \   0003AF   F0           MOVX      @DPTR,A
   2361              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003B0   7409         MOV       A,#0x9
   \   0003B2   12....       LCALL     ?XSTACK_DISP0_8
   \   0003B5   12....       LCALL     ?Subroutine82 & 0xFFFF
   2362              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2363                                     inMsg.msg->clusterId, &defautlRspCmd,
   2364                                     !inMsg.hdr.fc.direction, true,
   2365                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_135:
   \   0003B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0003BB   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   0003BE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0003C1   7407         MOV       A,#0x7
   \   0003C3   12....       LCALL     ?XSTACK_DISP0_8
   \   0003C6   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   0003C9   75..01       MOV       ?V0,#0x1
   \   0003CC   78..         MOV       R0,#?V0
   \   0003CE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0003D1   EA           MOV       A,R2
   \   0003D2   12....       LCALL     ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   0003D5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0003D8   7405         MOV       A,#0x5
   \   0003DA   12....       LCALL     ?XSTACK_DISP100_8
   \   0003DD   88..         MOV       ?V0,R0
   \   0003DF   89..         MOV       ?V1,R1
   \   0003E1   78..         MOV       R0,#?V0
   \   0003E3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0003E6   7409         MOV       A,#0x9
   \   0003E8   12....       LCALL     ?XSTACK_DISP0_8
   \   0003EB   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   0003EE   12....       LCALL     ?XSTACK_DISP0_8
   \   0003F1   12....       LCALL     ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   0003F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0003F7   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0003FA   12....       LCALL     `??zcl_SendDefaultRspCmd::?relay`; Banked call to: zcl_SendDefaultRspCmd
   \   0003FD   7407         MOV       A,#0x7
   \   0003FF   12....       LCALL     ?DEALLOC_XSTACK8
   2366              defaultResponseSent = TRUE;
   \   000402   D2..         SETB      ?VB.0
   2367            }
   2368          
   2369            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   000404   90....       MOV       DPTR,#rawAFMsg
   \   000407   E4           CLR       A
   \   000408   F0           MOVX      @DPTR,A
   \   000409   A3           INC       DPTR
   \   00040A   F0           MOVX      @DPTR,A
   2370            if ( status == ZSuccess )
   \   00040B   EE           MOV       A,R6
   \   00040C   7004         JNZ       ??zcl_ProcessMessageMSG_22
   2371            {
   2372              return ( ZCL_PROC_SUCCESS );
   \   00040E   7900         MOV       R1,#0x0
   \   000410   8019         SJMP      ??zcl_ProcessMessageMSG_1
   2373            }
   2374            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   000412   7484         MOV       A,#-0x7c
   \   000414   6E           XRL       A,R6
   \   000415   A2..         MOV       C,?VB.0
   \   000417   700A         JNZ       ??zcl_ProcessMessageMSG_23
   2375            {
   2376              if ( defaultResponseSent )
   \   000419   5004         JNC       ??zcl_ProcessMessageMSG_24
   2377              {
   2378                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   00041B   7907         MOV       R1,#0x7
   \   00041D   800C         SJMP      ??zcl_ProcessMessageMSG_1
   2379              }
   2380              else
   2381              {
   2382                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   00041F   7906         MOV       R1,#0x6
   \   000421   8008         SJMP      ??zcl_ProcessMessageMSG_1
   2383              }
   2384            }
   2385            else
   2386            {
   2387              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   000423   5004         JNC       ??zcl_ProcessMessageMSG_25
   2388              {
   2389                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000425   7909         MOV       R1,#0x9
   \   000427   8002         SJMP      ??zcl_ProcessMessageMSG_1
   2390              }
   2391              else
   2392              {
   2393                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   000429   7908         MOV       R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   00042B   7415         MOV       A,#0x15
   \   00042D   12....       LCALL     ?DEALLOC_XSTACK8
   2394              }
   2395            }
   \   000430   02....       LJMP      ?Subroutine9 & 0xFFFF
   2396          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine162:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine176_0
   \   000002                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   E4           CLR       A
   \   000001   93           MOVC      A,@A+DPTR
   \   000002   F8           MOV       R0,A
   \   000003   7401         MOV       A,#0x1
   \   000005   93           MOVC      A,@A+DPTR
   \   000006   F9           MOV       R1,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL     ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000003                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000003                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000003   7408         MOV       A,#0x8
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2406         ADD       A,#0x6
   \   000003   FA           MOV       R2,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   3400         ADDC      A,#0x0
   \   000008   FB           MOV       R3,A
   \   000009   7409         MOV       A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   12....       LCALL     ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_373:
   \   000003   C8           XCH       A,R0
   \   000004   2415         ADD       A,#0x15
   \   000006   F582         MOV       DPL,A
   \   000008   E4           CLR       A
   \   000009   38           ADDC      A,R0
   \   00000A   F583         MOV       DPH,A
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   12....       LCALL     ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000003   12....       LCALL     ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_502:
   \   000006   7409         MOV       A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006   12....       LCALL     ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_530:
   \   000009   85..82       MOV       DPL,?V0
   \   00000C   85..83       MOV       DPH,?V1
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   F9           MOV       R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004                REQUIRE ??Subroutine177_0
   \   000004                ; // Fall through to label ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine177_0:
   \   000000   12....       LCALL     ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   000003   E582         MOV       A,DPL
   \   000005   4583         ORL       A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL     ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   000003                REQUIRE ??Subroutine181_0
   \   000003                ; // Fall through to label ??Subroutine181_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7F07         MOV       R7,#0x7
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   13           RRC       A
   \   000001   13           RRC       A
   \   000002   13           RRC       A
   \   000003   541F         ANL       A,#0x1f
   \   000005   6401         XRL       A,#0x1
   \   000007   5401         ANL       A,#0x1
   \   000009   F5..         MOV       ?V0,A
   \   00000B   78..         MOV       R0,#?V0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   A3           INC       DPTR
   \   000001   E0           MOVX      A,@DPTR
   \   000002   C8           XCH       A,R0
   \   000003   12....       LCALL     ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_522:
   \   000006   38           ADDC      A,R0
   \   000007   F583         MOV       DPH,A
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   F9           MOV       R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004                REQUIRE ??Subroutine209_0
   \   000004                ; // Fall through to label ??Subroutine209_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine211_0:
   \   000000   12....       LCALL     ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_513:
   \   000003   F5..         MOV       ?V4,A
   \   000005   78..         MOV       R0,#?V4
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine150:
   \   000000   12....       LCALL     ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_528:
   \   000003   6401         XRL       A,#0x1
   \   000005   5401         ANL       A,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine169:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   13           RRC       A
   \   000002   13           RRC       A
   \   000003   13           RRC       A
   \   000004   541F         ANL       A,#0x1f
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine156:
   \   000000   12....       LCALL     ?Subroutine166 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET
   2397          
   2398          /*********************************************************************
   2399           * PRIVATE FUNCTIONS
   2400           *********************************************************************/
   2401          
   2402          /*********************************************************************
   2403           * @fn      zclParseHdr
   2404           *
   2405           * @brief   Parse header of the ZCL format
   2406           *
   2407           * @param   hdr - place to put the frame control information
   2408           * @param   pData - incoming buffer to parse
   2409           *
   2410           * @return  pointer past the header
   2411           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2412          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2413          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   2414            // Clear the header
   2415            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV       R4,#0x6
   \   00000F   7D00         MOV       R5,#0x0
   \   000011   7900         MOV       R1,#0x0
   \   000013   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2416          
   2417            // Parse the Frame Control
   2418            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV       DPL,?V0
   \   000019   85..83       MOV       DPH,?V1
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   54FC         ANL       A,#0xfc
   \   00001F   F8           MOV       R0,A
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   F9           MOV       R1,A
   \   000023   8E82         MOV       DPL,R6
   \   000025   8F83         MOV       DPH,R7
   \   000027   E0           MOVX      A,@DPTR
   \   000028   5403         ANL       A,#0x3
   \   00002A   FA           MOV       R2,A
   \   00002B   E8           MOV       A,R0
   \   00002C   4A           ORL       A,R2
   \   00002D   85..82       MOV       DPL,?V0
   \   000030   85..83       MOV       DPH,?V1
   \   000033   F0           MOVX      @DPTR,A
   \   000034   A3           INC       DPTR
   \   000035   E9           MOV       A,R1
   \   000036   12....       LCALL     ?Subroutine25 & 0xFFFF
   2419            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_25:
   \   000039   A2E2         MOV       C,0xE0 /* A   */.2
   \   00003B   5004         JNC       ??zclParseHdr_0
   \   00003D   D2F0         SETB      B.0
   \   00003F   8002         SJMP      ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000041   C2F0         CLR       B.0
   \                     ??zclParseHdr_1:
   \   000043   85..82       MOV       DPL,?V0
   \   000046   85..83       MOV       DPH,?V1
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   54FB         ANL       A,#0xfb
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A2F0         MOV       C,B.0
   \   00004F   E4           CLR       A
   \   000050   33           RLC       A
   \   000051   F5..         MOV       ?V2,A
   \   000053   75..00       MOV       ?V3,#0x0
   \   000056   7402         MOV       A,#0x2
   \   000058   78..         MOV       R0,#?V2
   \   00005A   12....       LCALL     ?S_SHL
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   45..         ORL       A,?V2
   \   000060   12....       LCALL     ?Subroutine25 & 0xFFFF
   2420            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_26:
   \   000063   A2E3         MOV       C,0xE0 /* A   */.3
   \   000065   85..82       MOV       DPL,?V0
   \   000068   85..83       MOV       DPH,?V1
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   5004         JNC       ??zclParseHdr_2
   2421            {
   2422              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00006E   4408         ORL       A,#0x8
   \   000070   8002         SJMP      ??zclParseHdr_3
   2423            }
   2424            else
   2425            {
   2426              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000072   54F7         ANL       A,#0xf7
   2427            }
   \                     ??zclParseHdr_3:
   \   000074   12....       LCALL     ?Subroutine25 & 0xFFFF
   2428          
   2429            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_27:
   \   000077   A2E4         MOV       C,0xE0 /* A   */.4
   \   000079   5004         JNC       ??zclParseHdr_4
   \   00007B   D2F0         SETB      B.0
   \   00007D   8002         SJMP      ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   00007F   C2F0         CLR       B.0
   \                     ??zclParseHdr_5:
   \   000081   85..82       MOV       DPL,?V0
   \   000084   85..83       MOV       DPH,?V1
   \   000087   E0           MOVX      A,@DPTR
   \   000088   54EF         ANL       A,#0xef
   \   00008A   F0           MOVX      @DPTR,A
   \   00008B   A2F0         MOV       C,B.0
   \   00008D   E4           CLR       A
   \   00008E   33           RLC       A
   \   00008F   F5..         MOV       ?V2,A
   \   000091   7404         MOV       A,#0x4
   \   000093   78..         MOV       R0,#?V2
   \   000095   12....       LCALL     ?S_SHL
   \   000098   E0           MOVX      A,@DPTR
   \   000099   45..         ORL       A,?V2
   \   00009B   12....       LCALL     ??Subroutine185_0 & 0xFFFF
   2430            pData++;  // move past the frame control field
   2431          
   2432            // parse the manfacturer code
   2433            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_382:
   \   00009E   85..82       MOV       DPL,?V0
   \   0000A1   85..83       MOV       DPH,?V1
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   5404         ANL       A,#0x4
   \   0000A7   601C         JZ        ??zclParseHdr_6
   2434            {
   2435              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000A9   8E82         MOV       DPL,R6
   \   0000AB   8F83         MOV       DPH,R7
   \   0000AD   E0           MOVX      A,@DPTR
   \   0000AE   FA           MOV       R2,A
   \   0000AF   A3           INC       DPTR
   \   0000B0   E0           MOVX      A,@DPTR
   \   0000B1   F9           MOV       R1,A
   \   0000B2   EA           MOV       A,R2
   \   0000B3   85..82       MOV       DPL,?V0
   \   0000B6   85..83       MOV       DPH,?V1
   \   0000B9   A3           INC       DPTR
   \   0000BA   A3           INC       DPTR
   \   0000BB   12....       LCALL     ??Subroutine192_0 & 0xFFFF
   2436              pData += 2;
   \                     ??CrossCallReturnLabel_418:
   \   0000BE   EE           MOV       A,R6
   \   0000BF   2402         ADD       A,#0x2
   \   0000C1   FE           MOV       R6,A
   \   0000C2   5001         JNC       ??zclParseHdr_6
   \   0000C4   0F           INC       R7
   2437            }
   2438          
   2439            // parse the Transaction Sequence Number
   2440            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000C5   8E82         MOV       DPL,R6
   \   0000C7   8F83         MOV       DPH,R7
   \   0000C9   12....       LCALL     ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   0000CC   12....       LCALL     ?Subroutine32 & 0xFFFF
   2441          
   2442            // parse the Cluster's command ID
   2443            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_38:
   \   0000CF   12....       LCALL     ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   0000D2   A3           INC       DPTR
   \   0000D3   F0           MOVX      @DPTR,A
   2444          
   2445            // Should point to the frame payload
   2446            return ( pData );
   \   0000D4   EE           MOV       A,R6
   \   0000D5   12....       LCALL     ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_408:
   \   0000D8   3F           ADDC      A,R7
   \   0000D9   FB           MOV       R3,A
   \   0000DA   02....       LJMP      ??Subroutine172_0 & 0xFFFF
   2447          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL     ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine185_0:
   \   000000   12....       LCALL     ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_386:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   A3           INC       DPTR
   \   000006   AE82         MOV       R6,DPL
   \   000008   AF83         MOV       R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET
   2448          
   2449          /*********************************************************************
   2450           * @fn      zclBuildHdr
   2451           *
   2452           * @brief   Build header of the ZCL format
   2453           *
   2454           * @param   hdr - outgoing header information
   2455           * @param   pData - outgoing header space
   2456           *
   2457           * @return  pointer past the header
   2458           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2459          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2460          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2461            // Build the Frame Control byte
   2462            *pData = hdr->fc.type;
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   5403         ANL       A,#0x3
   \   00000C   8C82         MOV       DPL,R4
   \   00000E   8D83         MOV       DPH,R5
   \   000010   12....       LCALL     ??Subroutine178_0 & 0xFFFF
   2463            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_331:
   \   000013   5404         ANL       A,#0x4
   \   000015   12....       LCALL     ?Subroutine31 & 0xFFFF
   2464            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_329:
   \   000018   5408         ANL       A,#0x8
   \   00001A   12....       LCALL     ?Subroutine31 & 0xFFFF
   2465            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_330:
   \   00001D   5410         ANL       A,#0x10
   \   00001F   F8           MOV       R0,A
   \   000020   8C82         MOV       DPL,R4
   \   000022   8D83         MOV       DPH,R5
   \   000024   E0           MOVX      A,@DPTR
   \   000025   48           ORL       A,R0
   \   000026   F0           MOVX      @DPTR,A
   2466            pData++;  // move past the frame control field
   \   000027   A3           INC       DPTR
   \   000028   AC82         MOV       R4,DPL
   \   00002A   AD83         MOV       R5,DPH
   2467          
   2468            // Add the manfacturer code
   2469            if ( hdr->fc.manuSpecific )
   \   00002C   8A82         MOV       DPL,R2
   \   00002E   8B83         MOV       DPH,R3
   \   000030   E0           MOVX      A,@DPTR
   \   000031   5404         ANL       A,#0x4
   \   000033   6016         JZ        ??zclBuildHdr_0
   2470            {
   2471              *pData++ = LO_UINT16( hdr->manuCode );
   \   000035   12....       LCALL     ?Subroutine112 & 0xFFFF
   2472              *pData++ = HI_UINT16( hdr->manuCode );
   2473            }
   \                     ??CrossCallReturnLabel_195:
   \   000038   12....       LCALL     ??Subroutine184_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_378:
   \   00003B   12....       LCALL     ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   00003E   8C82         MOV       DPL,R4
   \   000040   8D83         MOV       DPH,R5
   \   000042   A3           INC       DPTR
   \   000043   F0           MOVX      @DPTR,A
   \   000044   EC           MOV       A,R4
   \   000045   2402         ADD       A,#0x2
   \   000047   FC           MOV       R4,A
   \   000048   5001         JNC       ??zclBuildHdr_0
   \   00004A   0D           INC       R5
   2474          
   2475            // Add the Transaction Sequence Number
   2476            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   00004B   8A82         MOV       DPL,R2
   \   00004D   8B83         MOV       DPH,R3
   \   00004F   12....       LCALL     ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   000052   12....       LCALL     ?Subroutine132 & 0xFFFF
   2477          
   2478            // Add the Cluster's command ID
   2479            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_335:
   \   000055   A3           INC       DPTR
   \   000056   12....       LCALL     ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   000059   A3           INC       DPTR
   \   00005A   F0           MOVX      @DPTR,A
   2480          
   2481            // Should point to the frame payload
   2482            return ( pData );
   \   00005B   EC           MOV       A,R4
   \   00005C   12....       LCALL     ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_409:
   \   00005F   3D           ADDC      A,R5
   \   000060   FB           MOV       R3,A
   \   000061   80..         SJMP      ??Subroutine179_0
   2483          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   F8           MOV       R0,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005   E0           MOVX      A,@DPTR
   \   000006   48           ORL       A,R0
   \   000007                REQUIRE ??Subroutine178_0
   \   000007                ; // Fall through to label ??Subroutine178_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine178_0:
   \   000000   12....       LCALL     ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004                REQUIRE ??Subroutine184_0
   \   000004                ; // Fall through to label ??Subroutine184_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine184_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005   22           RET
   2484          
   2485          /*********************************************************************
   2486           * @fn      zclCalcHdrSize
   2487           *
   2488           * @brief   Calculate the number of bytes needed for an outgoing
   2489           *          ZCL header.
   2490           *
   2491           * @param   hdr - outgoing header information
   2492           *
   2493           * @return  returns the number of bytes needed
   2494           */
   2495          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2496          {
   2497            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2498          
   2499            // Add the manfacturer code
   2500            if ( hdr->fc.manuSpecific )
   2501            {
   2502              needed += 2;
   2503            }
   2504          
   2505            return ( needed );
   2506          }
   2507          
   2508          /*********************************************************************
   2509           * @fn      zclFindPlugin
   2510           *
   2511           * @brief   Find the right plugin for a cluster ID
   2512           *
   2513           * @param   clusterID - cluster ID to look for
   2514           * @param   profileID - profile ID
   2515           *
   2516           * @return  pointer to plugin, NULL if not found
   2517           */
   2518          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2519          {
   2520            zclLibPlugin_t *pLoop = plugins;
   2521          
   2522            (void)profileID;  // Intentionally unreferenced parameter
   2523          
   2524            while ( pLoop != NULL )
   2525            {
   2526              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2527              {
   2528                return ( pLoop );
   2529              }
   2530          
   2531              pLoop = pLoop->next;
   2532            }
   2533          
   2534            return ( (zclLibPlugin_t *)NULL );
   2535          }
   2536          
   2537          #ifdef ZCL_DISCOVER
   2538          /*********************************************************************
   2539           * @fn      zclFindCmdRecsList
   2540           *
   2541           * @brief   Find the right command record list for an endpoint
   2542           *
   2543           * @param   endpoint - endpoint to look for
   2544           *
   2545           * @return  pointer to record list, NULL if not found
   2546           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2547          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   \                     zclFindCmdRecsList:
   2548          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2549            zclCmdRecsList_t *pLoop = gpCmdList;
   \   000004   90....       MOV       DPTR,#gpCmdList
   \   000007   8004         SJMP      ??zclFindCmdRecsList_0
   2550          
   2551            while ( pLoop != NULL )
   2552            {
   2553              if ( pLoop->endpoint == endpoint )
   2554              {
   2555                return ( pLoop );
   2556              }
   2557          
   2558              pLoop = pLoop->pNext;
   \                     ??zclFindCmdRecsList_1:
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \                     ??zclFindCmdRecsList_0:
   \   00000D   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   000010   600C         JZ        ??zclFindCmdRecsList_2
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   69           XRL       A,R1
   \   00001A   70ED         JNZ       ??zclFindCmdRecsList_1
   \   00001C   8004         SJMP      ??zclFindCmdRecsList_3
   2559            }
   2560          
   2561            return ( NULL );
   \                     ??zclFindCmdRecsList_2:
   \   00001E   7A00         MOV       R2,#0x0
   \   000020   7B00         MOV       R3,#0x0
   \                     ??zclFindCmdRecsList_3:
   \   000022   02....       LJMP      ?Subroutine0 & 0xFFFF
   2562          }
   2563          
   2564          /*********************************************************************
   2565           * @fn      zclFindCmdRec
   2566           *
   2567           * @brief   Find the command record that matchs the parameters
   2568           *
   2569           * @param   endpoint - Application's endpoint
   2570           * @param   clusterID - cluster ID
   2571           * @param   attrId - attribute looking for
   2572           * @param   pAttr - attribute record to be returned
   2573           *
   2574           * @return  TRUE if record found. FALSE, otherwise.
   2575           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2576          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   \                     zclFindCmdRec:
   2577          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V1,R4
   2578            uint8 i;
   2579            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   \   00000B                ; Setup parameters for call to function zclFindCmdRecsList
   \   00000B   12....       LCALL     `??zclFindCmdRecsList::?relay`; Banked call to: zclFindCmdRecsList
   \   00000E   8A..         MOV       ?V2,R2
   \   000010   8B..         MOV       ?V3,R3
   2580          
   2581            if ( pRec != NULL )
   \   000012   EA           MOV       A,R2
   \   000013   45..         ORL       A,?V3
   \   000015   6051         JZ        ??zclFindCmdRec_0
   2582            {
   2583              for ( i = 0; i < pRec->numCommands; i++ )
   \   000017   7C00         MOV       R4,#0x0
   \   000019   8001         SJMP      ??zclFindCmdRec_1
   \                     ??zclFindCmdRec_2:
   \   00001B   0C           INC       R4
   \                     ??zclFindCmdRec_1:
   \   00001C   85..82       MOV       DPL,?V2
   \   00001F   85..83       MOV       DPH,?V3
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   F8           MOV       R0,A
   \   000027   EC           MOV       A,R4
   \   000028   C3           CLR       C
   \   000029   98           SUBB      A,R0
   \   00002A   503C         JNC       ??zclFindCmdRec_0
   2584              {
   2585                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   \   00002C   EC           MOV       A,R4
   \   00002D   F5..         MOV       ?V4,A
   \   00002F   75..00       MOV       ?V5,#0x0
   \   000032   7402         MOV       A,#0x2
   \   000034   78..         MOV       R0,#?V4
   \   000036   12....       LCALL     ?S_SHL
   \   000039   85..82       MOV       DPL,?V2
   \   00003C   85..83       MOV       DPH,?V3
   \   00003F   12....       LCALL     ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000042   8882         MOV       DPL,R0
   \   000044   8983         MOV       DPH,R1
   \   000046   12....       LCALL     ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000049   7002         JNZ       ??zclFindCmdRec_3
   \   00004B   EF           MOV       A,R7
   \   00004C   6B           XRL       A,R3
   \                     ??zclFindCmdRec_3:
   \   00004D   70CC         JNZ       ??zclFindCmdRec_2
   \   00004F   A3           INC       DPTR
   \   000050   A3           INC       DPTR
   \   000051   E4           CLR       A
   \   000052   93           MOVC      A,@A+DPTR
   \   000053   65..         XRL       A,?V1
   \   000055   70C4         JNZ       ??zclFindCmdRec_2
   2586                {
   2587                  *pCmd = pRec->pCmdRecs[i];
   \   000057   740E         MOV       A,#0xe
   \   000059   12....       LCALL     ?XSTACK_DISP0_8
   \   00005C   12....       LCALL     ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   00005F   7404         MOV       A,#0x4
   \   000061   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2588          
   2589                  return ( TRUE ); // EMBEDDED RETURN
   \   000064   7901         MOV       R1,#0x1
   \   000066   8002         SJMP      ??zclFindCmdRec_4
   2590                }
   2591              }
   2592            }
   2593          
   2594            return ( FALSE );
   \                     ??zclFindCmdRec_0:
   \   000068   7900         MOV       R1,#0x0
   \                     ??zclFindCmdRec_4:
   \   00006A   02....       LJMP      ?Subroutine4 & 0xFFFF
   2595          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   E4           CLR       A
   \   000001   93           MOVC      A,@A+DPTR
   \   000002   FA           MOV       R2,A
   \   000003   7401         MOV       A,#0x1
   \   000005   93           MOVC      A,@A+DPTR
   \   000006   FB           MOV       R3,A
   \   000007   EE           MOV       A,R6
   \   000008   6A           XRL       A,R2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   12....       LCALL     ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_499:
   \   000003   8983         MOV       DPH,R1
   \   000005   8882         MOV       DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   25..         ADD       A,?V4
   \   000007   F8           MOV       R0,A
   \   000008   A3           INC       DPTR
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   35..         ADDC      A,?V5
   \   00000C   F9           MOV       R1,A
   \   00000D   22           RET
   2596          #endif // ZCL_DISCOVER
   2597          
   2598          /*********************************************************************
   2599           * @fn      zclFindAttrRecsList
   2600           *
   2601           * @brief   Find the right attribute record list for an endpoint
   2602           *
   2603           * @param   clusterID - endpointto look for
   2604           *
   2605           * @return  pointer to record list, NULL if not found
   2606           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2607          zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2608          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2609            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV       DPTR,#attrList
   \   000007   8004         SJMP      ??zclFindAttrRecsList_0
   2610          
   2611            while ( pLoop != NULL )
   2612            {
   2613              if ( pLoop->endpoint == endpoint )
   2614              {
   2615                return ( pLoop );
   2616              }
   2617          
   2618              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000010   600C         JZ        ??zclFindAttrRecsList_2
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   69           XRL       A,R1
   \   00001A   70ED         JNZ       ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP      ??zclFindAttrRecsList_3
   2619            }
   2620          
   2621            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV       R2,#0x0
   \   000020   7B00         MOV       R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP      ?Subroutine0 & 0xFFFF
   2622          }
   2623          
   2624          /*********************************************************************
   2625           * @fn      zclFindAttrRec
   2626           *
   2627           * @brief   Find the attribute record that matchs the parameters
   2628           *
   2629           * @param   endpoint - Application's endpoint
   2630           * @param   clusterID - cluster ID
   2631           * @param   attrId - attribute looking for
   2632           * @param   pAttr - attribute record to be returned
   2633           *
   2634           * @return  TRUE if record found. FALSE, otherwise.
   2635           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2636          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2637          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   2638            uint8 x;
   2639            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV       ?V4,R2
   \   000012   8B..         MOV       ?V5,R3
   2640          
   2641            if ( pRec != NULL )
   \   000014   EA           MOV       A,R2
   \   000015   45..         ORL       A,?V5
   \   000017   6064         JZ        ??zclFindAttrRec_0
   2642            {
   2643              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000019   7C00         MOV       R4,#0x0
   \   00001B   8001         SJMP      ??zclFindAttrRec_1
   \                     ??zclFindAttrRec_2:
   \   00001D   0C           INC       R4
   \                     ??zclFindAttrRec_1:
   \   00001E   85..82       MOV       DPL,?V4
   \   000021   85..83       MOV       DPH,?V5
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   F8           MOV       R0,A
   \   00002D   EC           MOV       A,R4
   \   00002E   C3           CLR       C
   \   00002F   98           SUBB      A,R0
   \   000030   504B         JNC       ??zclFindAttrRec_0
   2644              {
   2645                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000032   EC           MOV       A,R4
   \   000033   F5..         MOV       ?V6,A
   \   000035   75..00       MOV       ?V7,#0x0
   \   000038   7403         MOV       A,#0x3
   \   00003A   78..         MOV       R0,#?V6
   \   00003C   12....       LCALL     ?S_SHL
   \   00003F   85..82       MOV       DPL,?V4
   \   000042   85..83       MOV       DPH,?V5
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   A3           INC       DPTR
   \   000049   12....       LCALL     ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   00004C   8882         MOV       DPL,R0
   \   00004E   8983         MOV       DPH,R1
   \   000050   E4           CLR       A
   \   000051   93           MOVC      A,@A+DPTR
   \   000052   FA           MOV       R2,A
   \   000053   7401         MOV       A,#0x1
   \   000055   93           MOVC      A,@A+DPTR
   \   000056   FB           MOV       R3,A
   \   000057   E5..         MOV       A,?V0
   \   000059   6A           XRL       A,R2
   \   00005A   7003         JNZ       ??zclFindAttrRec_3
   \   00005C   E5..         MOV       A,?V1
   \   00005E   6B           XRL       A,R3
   \                     ??zclFindAttrRec_3:
   \   00005F   70BC         JNZ       ??zclFindAttrRec_2
   \   000061   A3           INC       DPTR
   \   000062   A3           INC       DPTR
   \   000063   12....       LCALL     ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000066   7002         JNZ       ??zclFindAttrRec_4
   \   000068   EF           MOV       A,R7
   \   000069   6B           XRL       A,R3
   \                     ??zclFindAttrRec_4:
   \   00006A   70B1         JNZ       ??zclFindAttrRec_2
   2646                {
   2647                  *pAttr = pRec->attrs[x];
   \   00006C   7410         MOV       A,#0x10
   \   00006E   12....       LCALL     ?XSTACK_DISP0_8
   \   000071   12....       LCALL     ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000074   7408         MOV       A,#0x8
   \   000076   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2648          
   2649                  return ( TRUE ); // EMBEDDED RETURN
   \   000079   7901         MOV       R1,#0x1
   \   00007B   8002         SJMP      ??zclFindAttrRec_5
   2650                }
   2651              }
   2652            }
   2653          
   2654            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   00007D   7900         MOV       R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   00007F   80..         SJMP      ??Subroutine180_0
   2655          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   25..         ADD       A,?V6
   \   000007   F8           MOV       R0,A
   \   000008   A3           INC       DPTR
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   35..         ADDC      A,?V7
   \   00000C   F9           MOV       R1,A
   \   00000D   22           RET
   2656          
   2657          #if defined ( ZCL_STANDALONE )
   2658          /*********************************************************************
   2659           * @fn      zclSetAttrRecList
   2660           *
   2661           * @brief   Set attribute record list for end point
   2662           *
   2663           * @param   endpoint - endpoint the attribute list belongs to
   2664           * @param   numAttr - number of attributes in list
   2665           * @param   attrList - array of attribute records.
   2666           *                     NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE
   2667           *                     IN ASCENDING ORDER. OTHERWISE, THE DISCOVERY
   2668           *                     RESPONSE COMMAND WILL NOT HAVE THE RIGHT
   2669           *                     ATTRIBUTE INFO
   2670           *
   2671           * @return  TRUE if successful, FALSE otherwise.
   2672           */
   2673          uint8 zclSetAttrRecList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t attrList[] )
   2674          {
   2675            zclAttrRecsList *pRecsList = zclFindAttrRecsList( endpoint );
   2676          
   2677            if ( pRecsList != NULL )
   2678            {
   2679              pRecsList->numAttributes = numAttr;
   2680              pRecsList->attrs = attrList;
   2681              return ( TRUE );
   2682            }
   2683          
   2684            return ( FALSE );
   2685          }
   2686          
   2687          #endif // ZCL_STANDALONE
   2688          
   2689          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2690          /*********************************************************************
   2691           * @fn      zclGetReadWriteCB
   2692           *
   2693           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2694           *
   2695           * @param   endpoint - Application's endpoint
   2696           *
   2697           * @return  Read/Write CB, NULL if not found
   2698           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2699          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2700          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2701            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   2702          
   2703            if ( pRec != NULL )
   \   00000C   E582         MOV       A,DPL
   \   00000E   4583         ORL       A,DPH
   \   000010   6005         JZ        ??zclGetReadWriteCB_0
   2704            {
   2705              return ( pRec->pfnReadWriteCB );
   \   000012   12....       LCALL     ??Subroutine195_0 & 0xFFFF
   2706            }
   \                     ??CrossCallReturnLabel_451:
   \   000015   8004         SJMP      ??zclGetReadWriteCB_1
   2707          
   2708            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000017   7A00         MOV       R2,#0x0
   \   000019   7B00         MOV       R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   00001B   02....       LJMP      ?Subroutine2 & 0xFFFF
   2709          }
   2710          
   2711          /*********************************************************************
   2712           * @fn      zclGetAuthorizeCB
   2713           *
   2714           * @brief   Get the Read/Write Authorization callback function pointer
   2715           *          for a given endpoint.
   2716           *
   2717           * @param   endpoint - Application's endpoint
   2718           *
   2719           * @return  Authorization CB, NULL if not found
   2720           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2721          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2722          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2723            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   2724          
   2725            if ( pRec != NULL )
   \   00000C   E582         MOV       A,DPL
   \   00000E   4583         ORL       A,DPH
   \   000010   6005         JZ        ??zclGetAuthorizeCB_0
   2726            {
   2727              return ( pRec->pfnAuthorizeCB );
   \   000012   12....       LCALL     ?Subroutine77 & 0xFFFF
   2728            }
   \                     ??CrossCallReturnLabel_455:
   \   000015   8004         SJMP      ??zclGetAuthorizeCB_1
   2729          
   2730            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000017   7A00         MOV       R2,#0x0
   \   000019   7B00         MOV       R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00001B   02....       LJMP      ?Subroutine2 & 0xFFFF
   2731          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine194_0
   \   000001                ; // Fall through to label ??Subroutine194_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine194_0:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine195_0
   \   000001                ; // Fall through to label ??Subroutine195_0
   2732          #endif // ZCL_READ || ZCL_WRITE
   2733          
   2734          /*********************************************************************
   2735           * @fn      zclFindClusterOption
   2736           *
   2737           * @brief   Find the option record that matchs the cluster id
   2738           *
   2739           * @param   endpoint - Application's endpoint
   2740           * @param   clusterID - cluster ID looking for
   2741           *
   2742           * @return  pointer to clutser option, NULL if not found
   2743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2744          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2745          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FF           MOV       R7,A
   \   000007   EA           MOV       A,R2
   \   000008   FC           MOV       R4,A
   \   000009   EB           MOV       A,R3
   \   00000A   FD           MOV       R5,A
   2746            zclClusterOptionList *pLoop;
   2747          
   2748            pLoop = clusterOptionList;
   \   00000B   90....       MOV       DPTR,#clusterOptionList
   \   00000E   8004         SJMP      ??zclFindClusterOption_0
   2749            while ( pLoop != NULL )
   2750            {
   2751              if ( pLoop->endpoint == endpoint )
   2752              {
   2753                uint8 x;
   2754                for ( x = 0; x < pLoop->numOptions; x++ )
   2755                {
   2756                  if ( pLoop->options[x].clusterID == clusterID )
   2757                  {
   2758                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2759                  }
   2760                }
   2761              }
   2762          
   2763              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000010   8882         MOV       DPL,R0
   \   000012   8983         MOV       DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000014   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   000017   6046         JZ        ??zclFindClusterOption_2
   \   000019   8882         MOV       DPL,R0
   \   00001B   8983         MOV       DPH,R1
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   6F           XRL       A,R7
   \   000021   70ED         JNZ       ??zclFindClusterOption_1
   \   000023   7E00         MOV       R6,#0x0
   \   000025   8001         SJMP      ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000027   0E           INC       R6
   \                     ??zclFindClusterOption_3:
   \   000028   8882         MOV       DPL,R0
   \   00002A   8983         MOV       DPH,R1
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   FA           MOV       R2,A
   \   000031   EE           MOV       A,R6
   \   000032   C3           CLR       C
   \   000033   9A           SUBB      A,R2
   \   000034   50DA         JNC       ??zclFindClusterOption_1
   \   000036   EE           MOV       A,R6
   \   000037   75F003       MOV       B,#0x3
   \   00003A   A4           MUL       AB
   \   00003B   FA           MOV       R2,A
   \   00003C   85F0..       MOV       ?V0,B
   \   00003F   AB..         MOV       R3,?V0
   \   000041   8882         MOV       DPL,R0
   \   000043   8983         MOV       DPH,R1
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   2A           ADD       A,R2
   \   00004B   FA           MOV       R2,A
   \   00004C   A3           INC       DPTR
   \   00004D   E0           MOVX      A,@DPTR
   \   00004E   3B           ADDC      A,R3
   \   00004F   FB           MOV       R3,A
   \   000050   8A82         MOV       DPL,R2
   \   000052   8B83         MOV       DPH,R3
   \   000054   E0           MOVX      A,@DPTR
   \   000055   6C           XRL       A,R4
   \   000056   7003         JNZ       ??zclFindClusterOption_5
   \   000058   A3           INC       DPTR
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   6D           XRL       A,R5
   \                     ??zclFindClusterOption_5:
   \   00005B   70CA         JNZ       ??zclFindClusterOption_4
   \   00005D   8004         SJMP      ??zclFindClusterOption_6
   2764            }
   2765          
   2766            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   00005F   7A00         MOV       R2,#0x0
   \   000061   7B00         MOV       R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   000063   02....       LJMP      ??Subroutine179_0 & 0xFFFF
   2767          }
   2768          
   2769          /*********************************************************************
   2770           * @fn      zclGetClusterOption
   2771           *
   2772           * @brief   Get the option record that matchs the cluster id
   2773           *
   2774           * @param   endpoint - Application's endpoint
   2775           * @param   clusterID - cluster ID looking for
   2776           *
   2777           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2778           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2779          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2780          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2781            uint8 option;
   2782            zclOptionRec_t *pOption;
   2783          
   2784            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL     `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   2785            if ( pOption != NULL )
   \   00000C   E582         MOV       A,DPL
   \   00000E   4583         ORL       A,DPH
   \   000010   6006         JZ        ??zclGetClusterOption_0
   2786            {
   2787              option = pOption->option;
   2788              if ( !ZG_SECURE_ENABLED )
   2789              {
   2790                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2791              }
   2792          
   2793              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F9           MOV       R1,A
   \   000016   8002         SJMP      ??zclGetClusterOption_1
   2794            }
   2795          
   2796            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000018   7900         MOV       R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001A                REQUIRE ?Subroutine2
   \   00001A                ; // Fall through to label ?Subroutine2
   2797          }
   2798          
   2799          /*********************************************************************
   2800           * @fn      zclSetSecurityOption
   2801           *
   2802           * @brief   Set the security option for the cluster id
   2803           *
   2804           * @param   endpoint - Application's endpoint
   2805           * @param   clusterID - cluster ID looking for
   2806           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2807           *
   2808           * @return  none
   2809           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2810          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2811          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV       A,R4
   \   000006   FF           MOV       R7,A
   2812            zclOptionRec_t *pOption;
   2813          
   2814            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL     `??zclFindClusterOption::?relay`; Banked call to: zclFindClusterOption
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   A8..         MOV       R0,?V0
   \   000010   A9..         MOV       R1,?V1
   2815            if ( pOption != NULL )
   \   000012   E8           MOV       A,R0
   \   000013   49           ORL       A,R1
   \   000014   6015         JZ        ??zclSetSecurityOption_0
   2816            {
   2817              if ( enable )
   \   000016   E8           MOV       A,R0
   \   000017   2402         ADD       A,#0x2
   \   000019   F582         MOV       DPL,A
   \   00001B   E4           CLR       A
   \   00001C   39           ADDC      A,R1
   \   00001D   F583         MOV       DPH,A
   \   00001F   EF           MOV       A,R7
   \   000020   6005         JZ        ??zclSetSecurityOption_1
   2818              {
   2819                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX      A,@DPTR
   \   000023   D2E6         SETB      0xE0 /* A   */.6
   \   000025   8003         SJMP      ??zclSetSecurityOption_2
   2820              }
   2821              else
   2822              {
   2823                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000027   E0           MOVX      A,@DPTR
   \   000028   C2E6         CLR       0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   00002A   F0           MOVX      @DPTR,A
   2824              }
   2825            }
   2826          }
   \                     ??zclSetSecurityOption_0:
   \   00002B   80..         SJMP      ?Subroutine2
   2827          
   2828          #ifdef ZCL_DISCOVER
   2829          /*********************************************************************
   2830           * @fn      zclFindNextCmdRec
   2831           *
   2832           * @brief   Find the command (or next) record that matchs the parameters
   2833           *
   2834           * @param   endpoint - Application's endpoint
   2835           * @param   clusterID - cluster ID
   2836           * @param   commandID - command ID from requesting command
   2837           * @param   direction- direction of received command
   2838           * @param   pCmdID - command looking for
   2839           * @param   pCmd - command information within command record list
   2840           *
   2841           * @return  pointer to command record, NULL no more records of this cluster
   2842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2843          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   \                     zclFindNextCmdRec:
   2844                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2845          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V1,R4
   \   00000B   8D..         MOV       ?V2,R5
   2846            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindCmdRecsList
   \   00000D   12....       LCALL     `??zclFindCmdRecsList::?relay`; Banked call to: zclFindCmdRecsList
   \   000010   8A..         MOV       ?V4,R2
   \   000012   8B..         MOV       ?V5,R3
   2847            uint8 i;
   2848          
   2849            if ( pRec != NULL )
   \   000014   EA           MOV       A,R2
   \   000015   45..         ORL       A,?V5
   \   000017   7003         JNZ       $+5
   \   000019   02....       LJMP      ??zclFindNextCmdRec_0 & 0xFFFF
   2850            {
   2851              for ( i = 0; i < pRec->numCommands; i++ )
   \   00001C   75..00       MOV       ?V3,#0x0
   \   00001F   7410         MOV       A,#0x10
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   000027   E8           MOV       A,R0
   \   000028   FA           MOV       R2,A
   \   000029   E9           MOV       A,R1
   \   00002A   FB           MOV       R3,A
   \   00002B   8012         SJMP      ??zclFindNextCmdRec_1
   2852              {
   2853                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2854                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2855                {
   2856                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2857                  {
   2858                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   \                     ??zclFindNextCmdRec_2:
   \   00002D   8C82         MOV       DPL,R4
   \   00002F   8D83         MOV       DPH,R5
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   E4           CLR       A
   \   000035   93           MOVC      A,@A+DPTR
   \   000036   A2E3         MOV       C,0xE0 /* A   */.3
   \   000038   5003         JNC       $+5
   \   00003A   02....       LJMP      ??zclFindNextCmdRec_3 & 0xFFFF
   \                     ??zclFindNextCmdRec_4:
   \   00003D   05..         INC       ?V3
   \                     ??zclFindNextCmdRec_1:
   \   00003F   85..82       MOV       DPL,?V4
   \   000042   85..83       MOV       DPH,?V5
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   F8           MOV       R0,A
   \   00004A   E5..         MOV       A,?V3
   \   00004C   C3           CLR       C
   \   00004D   98           SUBB      A,R0
   \   00004E   4003         JC        $+5
   \   000050   02....       LJMP      ??zclFindNextCmdRec_0 & 0xFFFF
   \   000053   E5..         MOV       A,?V3
   \   000055   F5..         MOV       ?V6,A
   \   000057   75..00       MOV       ?V7,#0x0
   \   00005A   7402         MOV       A,#0x2
   \   00005C   78..         MOV       R0,#?V6
   \   00005E   12....       LCALL     ?S_SHL
   \   000061   85..82       MOV       DPL,?V4
   \   000064   85..83       MOV       DPH,?V5
   \   000067   12....       LCALL     ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00006A   12....       LCALL     ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   00006D   7002         JNZ       ??zclFindNextCmdRec_5
   \   00006F   EF           MOV       A,R7
   \   000070   69           XRL       A,R1
   \                     ??zclFindNextCmdRec_5:
   \   000071   70CA         JNZ       ??zclFindNextCmdRec_4
   \   000073   8A82         MOV       DPL,R2
   \   000075   8B83         MOV       DPH,R3
   \   000077   E0           MOVX      A,@DPTR
   \   000078   F8           MOV       R0,A
   \   000079   8C82         MOV       DPL,R4
   \   00007B   8D83         MOV       DPH,R5
   \   00007D   A3           INC       DPTR
   \   00007E   A3           INC       DPTR
   \   00007F   E4           CLR       A
   \   000080   93           MOVC      A,@A+DPTR
   \   000081   C3           CLR       C
   \   000082   98           SUBB      A,R0
   \   000083   40B8         JC        ??zclFindNextCmdRec_4
   \   000085   7411         MOV       A,#0x11
   \   000087   65..         XRL       A,?V1
   \   000089   7019         JNZ       ??zclFindNextCmdRec_6
   \   00008B   7401         MOV       A,#0x1
   \   00008D   65..         XRL       A,?V2
   \   00008F   609C         JZ        ??zclFindNextCmdRec_2
   2859                    {
   2860                      *pCmd = pRec->pCmdRecs[i];
   2861          
   2862                      // Update command ID
   2863                      *pCmdID = pCmd->cmdID;
   2864          
   2865                      return ( TRUE ); // EMBEDDED RETURN
   2866                    }
   2867                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   \   000091   E5..         MOV       A,?V2
   \   000093   70A8         JNZ       ??zclFindNextCmdRec_4
   \   000095   8C82         MOV       DPL,R4
   \   000097   8D83         MOV       DPH,R5
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   E4           CLR       A
   \   00009D   93           MOVC      A,@A+DPTR
   \   00009E   A2E2         MOV       C,0xE0 /* A   */.2
   \                     ??zclFindNextCmdRec_7:
   \   0000A0   4032         JC        ??zclFindNextCmdRec_3
   \   0000A2   8099         SJMP      ??zclFindNextCmdRec_4
   2868                    {
   2869                      *pCmd = pRec->pCmdRecs[i];
   2870          
   2871                      // Update command ID
   2872                      *pCmdID = pCmd->cmdID;
   2873          
   2874                      return ( TRUE ); // EMBEDDED RETURN
   2875                    }
   2876                  }
   2877                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   \                     ??zclFindNextCmdRec_6:
   \   0000A4   7413         MOV       A,#0x13
   \   0000A6   65..         XRL       A,?V1
   \   0000A8   7044         JNZ       ??zclFindNextCmdRec_0
   2878                  {
   2879                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   \   0000AA   E5..         MOV       A,?V2
   \   0000AC   700D         JNZ       ??zclFindNextCmdRec_8
   \   0000AE   8C82         MOV       DPL,R4
   \   0000B0   8D83         MOV       DPH,R5
   \   0000B2   A3           INC       DPTR
   \   0000B3   A3           INC       DPTR
   \   0000B4   A3           INC       DPTR
   \   0000B5   E4           CLR       A
   \   0000B6   93           MOVC      A,@A+DPTR
   \   0000B7   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000B9   80E5         SJMP      ??zclFindNextCmdRec_7
   2880                    {
   2881                      *pCmd = pRec->pCmdRecs[i];
   2882          
   2883                      // Update command ID
   2884                      *pCmdID = pCmd->cmdID;
   2885          
   2886                      return ( TRUE ); // EMBEDDED RETURN
   2887                    }
   2888                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   \                     ??zclFindNextCmdRec_8:
   \   0000BB   7401         MOV       A,#0x1
   \   0000BD   65..         XRL       A,?V2
   \   0000BF   6003         JZ        $+5
   \   0000C1   02....       LJMP      ??zclFindNextCmdRec_4 & 0xFFFF
   \   0000C4   8C82         MOV       DPL,R4
   \   0000C6   8D83         MOV       DPH,R5
   \   0000C8   A3           INC       DPTR
   \   0000C9   A3           INC       DPTR
   \   0000CA   A3           INC       DPTR
   \   0000CB   E4           CLR       A
   \   0000CC   93           MOVC      A,@A+DPTR
   \   0000CD   A2E1         MOV       C,0xE0 /* A   */.1
   \   0000CF   4003         JC        $+5
   \   0000D1   02....       LJMP      ??zclFindNextCmdRec_4 & 0xFFFF
   \                     ??zclFindNextCmdRec_3:
   \   0000D4   7412         MOV       A,#0x12
   \   0000D6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D9   12....       LCALL     ?Subroutine69 & 0xFFFF
   2889                    {
   2890                      *pCmd = pRec->pCmdRecs[i];
   \                     ??CrossCallReturnLabel_110:
   \   0000DC   7404         MOV       A,#0x4
   \   0000DE   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2891          
   2892                      // Update command ID
   2893                      *pCmdID = pCmd->cmdID;
   \   0000E1   8882         MOV       DPL,R0
   \   0000E3   8983         MOV       DPH,R1
   \   0000E5   A3           INC       DPTR
   \   0000E6   A3           INC       DPTR
   \   0000E7   12....       LCALL     ?Subroutine74 & 0xFFFF
   2894          
   2895                      return ( TRUE ); // EMBEDDED RETURN
   \                     ??CrossCallReturnLabel_119:
   \   0000EA   7901         MOV       R1,#0x1
   \   0000EC   8002         SJMP      ??zclFindNextCmdRec_9
   2896                    }
   2897                  }
   2898                  else
   2899                  {
   2900                    return ( FALSE ); // Incorrect Command ID
   2901                  }
   2902                }
   2903              }
   2904            }
   2905          
   2906            return ( FALSE );
   \                     ??zclFindNextCmdRec_0:
   \   0000EE   7900         MOV       R1,#0x0
   \                     ??zclFindNextCmdRec_9:
   \   0000F0   02....       LJMP      ??Subroutine180_0 & 0xFFFF
   2907          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   E8           MOV       A,R0
   \   000001   FC           MOV       R4,A
   \   000002   E9           MOV       A,R1
   \   000003   FD           MOV       R5,A
   \   000004   8C82         MOV       DPL,R4
   \   000006   8D83         MOV       DPH,R5
   \   000008   12....       LCALL     ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   00000B   EE           MOV       A,R6
   \   00000C   68           XRL       A,R0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_367:
   \   000003   8C82         MOV       DPL,R4
   \   000005   8D83         MOV       DPH,R5
   \   000007   E8           MOV       A,R0
   \   000008   FC           MOV       R4,A
   \   000009   E9           MOV       A,R1
   \   00000A   FD           MOV       R5,A
   \   00000B   22           RET
   2908          
   2909          /*********************************************************************
   2910           * @fn      zclFindNextAttrRec
   2911           *
   2912           * @brief   Find the attribute (or next) record that matchs the parameters
   2913           *
   2914           * @param   endpoint - Application's endpoint
   2915           * @param   clusterID - cluster ID
   2916           * @param   attr - attribute looking for
   2917           *
   2918           * @return  pointer to attribute record, NULL if not found
   2919           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2920          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   \                     zclFindNextAttrRec:
   2921                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2922          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V1,R4
   2923            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000B                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000B   12....       LCALL     `??zclFindAttrRecsList::?relay`; Banked call to: zclFindAttrRecsList
   \   00000E   8A..         MOV       ?V6,R2
   \   000010   8B..         MOV       ?V7,R3
   2924            uint8 attrDir;
   2925          
   2926            if ( pRec != NULL )
   \   000012   EA           MOV       A,R2
   \   000013   45..         ORL       A,?V7
   \   000015   7003         JNZ       $+5
   \   000017   02....       LJMP      ??zclFindNextAttrRec_0 & 0xFFFF
   2927            {
   2928              uint16 x;
   2929          
   2930              for ( x = 0; x < pRec->numAttributes; x++ )
   \   00001A   7A00         MOV       R2,#0x0
   \   00001C   7B00         MOV       R3,#0x0
   \   00001E   7410         MOV       A,#0x10
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   000026   88..         MOV       ?V2,R0
   \   000028   89..         MOV       ?V3,R1
   \   00002A   8005         SJMP      ??zclFindNextAttrRec_1
   \                     ??zclFindNextAttrRec_2:
   \   00002C   0A           INC       R2
   \   00002D   EA           MOV       A,R2
   \   00002E   7001         JNZ       ??zclFindNextAttrRec_1
   \   000030   0B           INC       R3
   \                     ??zclFindNextAttrRec_1:
   \   000031   85..82       MOV       DPL,?V6
   \   000034   85..83       MOV       DPH,?V7
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   F8           MOV       R0,A
   \   000040   C3           CLR       C
   \   000041   EA           MOV       A,R2
   \   000042   98           SUBB      A,R0
   \   000043   EB           MOV       A,R3
   \   000044   9400         SUBB      A,#0x0
   \   000046   506E         JNC       ??zclFindNextAttrRec_0
   2931              {
   2932                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2933                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   \   000048   8A..         MOV       ?V4,R2
   \   00004A   8B..         MOV       ?V5,R3
   \   00004C   7403         MOV       A,#0x3
   \   00004E   78..         MOV       R0,#?V4
   \   000050   12....       LCALL     ?S_SHL
   \   000053   85..82       MOV       DPL,?V6
   \   000056   85..83       MOV       DPH,?V7
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   12....       LCALL     ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000060   12....       LCALL     ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000063   7002         JNZ       ??zclFindNextAttrRec_3
   \   000065   EF           MOV       A,R7
   \   000066   69           XRL       A,R1
   \                     ??zclFindNextAttrRec_3:
   \   000067   70C3         JNZ       ??zclFindNextAttrRec_2
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   E4           CLR       A
   \   00006C   93           MOVC      A,@A+DPTR
   \   00006D   F5..         MOV       ?V4,A
   \   00006F   7401         MOV       A,#0x1
   \   000071   93           MOVC      A,@A+DPTR
   \   000072   F5..         MOV       ?V5,A
   \   000074   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_361:
   \   000077   C3           CLR       C
   \   000078   E5..         MOV       A,?V4
   \   00007A   98           SUBB      A,R0
   \   00007B   E5..         MOV       A,?V5
   \   00007D   99           SUBB      A,R1
   \   00007E   40AC         JC        ??zclFindNextAttrRec_2
   2934                {
   2935                  // also make sure direction is right
   2936                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2937                  if ( (attrDir == direction) || (pRec->attrs[x].attr.accessControl & ACCESS_GLOBAL))
   \   000080   EC           MOV       A,R4
   \   000081   2405         ADD       A,#0x5
   \   000083   F582         MOV       DPL,A
   \   000085   E4           CLR       A
   \   000086   3D           ADDC      A,R5
   \   000087   F583         MOV       DPH,A
   \   000089   E4           CLR       A
   \   00008A   93           MOVC      A,@A+DPTR
   \   00008B   A2E7         MOV       C,0xE0 /* A   */.7
   \   00008D   E4           CLR       A
   \   00008E   33           RLC       A
   \   00008F   65..         XRL       A,?V1
   \   000091   6006         JZ        ??zclFindNextAttrRec_4
   \   000093   E4           CLR       A
   \   000094   93           MOVC      A,@A+DPTR
   \   000095   A2E6         MOV       C,0xE0 /* A   */.6
   \   000097   5093         JNC       ??zclFindNextAttrRec_2
   \                     ??zclFindNextAttrRec_4:
   \   000099   7412         MOV       A,#0x12
   \   00009B   12....       LCALL     ?XSTACK_DISP0_8
   \   00009E   12....       LCALL     ?Subroutine69 & 0xFFFF
   2938                  {
   2939                    // return attribute and found attribute ID
   2940                    *pAttr = pRec->attrs[x];
   \                     ??CrossCallReturnLabel_111:
   \   0000A1   7408         MOV       A,#0x8
   \   0000A3   12....       LCALL     ?MOVE_LONG8_XDATA_CODE
   2941                    *attrId = pAttr->attr.attrId;
   \   0000A6   8882         MOV       DPL,R0
   \   0000A8   8983         MOV       DPH,R1
   \   0000AA   A3           INC       DPTR
   \   0000AB   A3           INC       DPTR
   \   0000AC   12....       LCALL     ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_473:
   \   0000AF   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   2942          
   2943                    return ( TRUE ); // EMBEDDED RETURN
   \                     ??CrossCallReturnLabel_423:
   \   0000B2   7901         MOV       R1,#0x1
   \   0000B4   8002         SJMP      ??zclFindNextAttrRec_5
   2944                  }
   2945                }
   2946              }
   2947            }
   2948          
   2949            return ( FALSE );
   \                     ??zclFindNextAttrRec_0:
   \   0000B6   7900         MOV       R1,#0x0
   \                     ??zclFindNextAttrRec_5:
   \   0000B8   02....       LJMP      ??Subroutine180_0 & 0xFFFF
   2950          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006                REQUIRE ??Subroutine183_0
   \   000006                ; // Fall through to label ??Subroutine183_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine204_0:
   \   000000   12....       LCALL     ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_478:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine144:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine205_0
   \   000003                ; // Fall through to label ??Subroutine205_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine205_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F9           MOV       R1,A
   \   000002                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000002                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000002   85..82       MOV       DPL,?V2
   \   000005   85..83       MOV       DPH,?V3
   \   000008   22           RET
   2951          #endif // ZCL_DISCOVER
   2952          
   2953          /*********************************************************************
   2954           * @fn      zclSerializeData
   2955           *
   2956           * @brief   Builds a buffer from the attribute data to sent out over
   2957           *          the air.
   2958           *          NOTE - Not compatible with application's attributes callbacks.
   2959           *
   2960           * @param   dataType - data types defined in zcl.h
   2961           * @param   attrData - pointer to the attribute data
   2962           * @param   buf - where to put the serialized data
   2963           *
   2964           * @return  pointer to end of destination buffer
   2965           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2966          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2967          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   EC           MOV       A,R4
   \   00000A   FA           MOV       R2,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FB           MOV       R3,A
   2968            uint8 *pStr;
   2969            uint16 len;
   2970          
   2971            if ( attrData == NULL )
   \   00000D   EE           MOV       A,R6
   \   00000E   4F           ORL       A,R7
   \   00000F   7003         JNZ       $+5
   \   000011   02....       LJMP      ??zclSerializeData_0 & 0xFFFF
   2972            {
   2973              return ( buf );
   2974            }
   2975          
   2976            switch ( dataType )
   \   000014   EA           MOV       A,R2
   \   000015   2402         ADD       A,#0x2
   \   000017   F5..         MOV       ?V4,A
   \   000019   E4           CLR       A
   \   00001A   3B           ADDC      A,R3
   \   00001B   F5..         MOV       ?V5,A
   \   00001D   8A82         MOV       DPL,R2
   \   00001F   8B83         MOV       DPH,R3
   \   000021   A3           INC       DPTR
   \   000022   AC82         MOV       R4,DPL
   \   000024   AD83         MOV       R5,DPH
   \   000026   8E..         MOV       ?V0,R6
   \   000028   8F..         MOV       ?V1,R7
   \   00002A   75..00       MOV       ?V2,#0x0
   \   00002D   E9           MOV       A,R1
   \   00002E   12....       LCALL     ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000031   04           DB        4
   \   000032   41           DB        65
   \   000033   42           DB        66
   \   000034   ....         DW        ??zclSerializeData_1
   \   000036   43           DB        67
   \   000037   44           DB        68
   \   000038   ....         DW        ??zclSerializeData_2
   \   00003A   E0           DB        224
   \   00003B   E2           DB        226
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   E8           DB        232
   \   00003F   E9           DB        233
   \   000040   ....         DW        ??zclSerializeData_4
   \   000042   25           DB        37
   \   000043   08           DB        8
   \   000044   ....         DW        ??zclSerializeData_5
   \   000046   09           DB        9
   \   000047   ....         DW        ??zclSerializeData_4
   \   000049   0A           DB        10
   \   00004A   ....         DW        ??zclSerializeData_6
   \   00004C   0B           DB        11
   \   00004D   ....         DW        ??zclSerializeData_3
   \   00004F   10           DB        16
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   18           DB        24
   \   000053   ....         DW        ??zclSerializeData_5
   \   000055   19           DB        25
   \   000056   ....         DW        ??zclSerializeData_4
   \   000058   1A           DB        26
   \   000059   ....         DW        ??zclSerializeData_6
   \   00005B   1B           DB        27
   \   00005C   ....         DW        ??zclSerializeData_3
   \   00005E   1C           DB        28
   \   00005F   ....         DW        ??zclSerializeData_7
   \   000061   1D           DB        29
   \   000062   ....         DW        ??zclSerializeData_8
   \   000064   1E           DB        30
   \   000065   ....         DW        ??zclSerializeData_9
   \   000067   1F           DB        31
   \   000068   ....         DW        ??zclSerializeData_10
   \   00006A   20           DB        32
   \   00006B   ....         DW        ??zclSerializeData_5
   \   00006D   21           DB        33
   \   00006E   ....         DW        ??zclSerializeData_4
   \   000070   22           DB        34
   \   000071   ....         DW        ??zclSerializeData_6
   \   000073   23           DB        35
   \   000074   ....         DW        ??zclSerializeData_3
   \   000076   24           DB        36
   \   000077   ....         DW        ??zclSerializeData_7
   \   000079   25           DB        37
   \   00007A   ....         DW        ??zclSerializeData_8
   \   00007C   26           DB        38
   \   00007D   ....         DW        ??zclSerializeData_9
   \   00007F   27           DB        39
   \   000080   ....         DW        ??zclSerializeData_10
   \   000082   28           DB        40
   \   000083   ....         DW        ??zclSerializeData_5
   \   000085   29           DB        41
   \   000086   ....         DW        ??zclSerializeData_4
   \   000088   2A           DB        42
   \   000089   ....         DW        ??zclSerializeData_6
   \   00008B   2B           DB        43
   \   00008C   ....         DW        ??zclSerializeData_3
   \   00008E   2C           DB        44
   \   00008F   ....         DW        ??zclSerializeData_7
   \   000091   2D           DB        45
   \   000092   ....         DW        ??zclSerializeData_8
   \   000094   2E           DB        46
   \   000095   ....         DW        ??zclSerializeData_9
   \   000097   2F           DB        47
   \   000098   ....         DW        ??zclSerializeData_10
   \   00009A   30           DB        48
   \   00009B   ....         DW        ??zclSerializeData_5
   \   00009D   31           DB        49
   \   00009E   ....         DW        ??zclSerializeData_4
   \   0000A0   38           DB        56
   \   0000A1   ....         DW        ??zclSerializeData_4
   \   0000A3   39           DB        57
   \   0000A4   ....         DW        ??zclSerializeData_3
   \   0000A6   3A           DB        58
   \   0000A7   ....         DW        ??zclSerializeData_10
   \   0000A9   EA           DB        234
   \   0000AA   ....         DW        ??zclSerializeData_3
   \   0000AC   F0           DB        240
   \   0000AD   ....         DW        ??zclSerializeData_10
   \   0000AF   F1           DB        241
   \   0000B0   ....         DW        ??zclSerializeData_11
   \   0000B2   ....         DW        ??zclSerializeData_0
   2977            {
   2978              case ZCL_DATATYPE_DATA8:
   2979              case ZCL_DATATYPE_BOOLEAN:
   2980              case ZCL_DATATYPE_BITMAP8:
   2981              case ZCL_DATATYPE_INT8:
   2982              case ZCL_DATATYPE_UINT8:
   2983              case ZCL_DATATYPE_ENUM8:
   2984                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   0000B4   8E82         MOV       DPL,R6
   \   0000B6   8F83         MOV       DPH,R7
   \   0000B8   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   0000BB   EC           MOV       A,R4
   \   0000BC   FA           MOV       R2,A
   \   0000BD   ED           MOV       A,R5
   \   0000BE   FB           MOV       R3,A
   2985                 break;
   \   0000BF   02....       LJMP      ??zclSerializeData_0 & 0xFFFF
   2986          
   2987              case ZCL_DATATYPE_DATA16:
   2988              case ZCL_DATATYPE_BITMAP16:
   2989              case ZCL_DATATYPE_UINT16:
   2990              case ZCL_DATATYPE_INT16:
   2991              case ZCL_DATATYPE_ENUM16:
   2992              case ZCL_DATATYPE_SEMI_PREC:
   2993              case ZCL_DATATYPE_CLUSTER_ID:
   2994              case ZCL_DATATYPE_ATTR_ID:
   2995                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000C2   8E82         MOV       DPL,R6
   \   0000C4   8F83         MOV       DPH,R7
   \   0000C6   12....       LCALL     ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   0000C9   12....       LCALL     ?Subroutine32 & 0xFFFF
   2996                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_39:
   \   0000CC   12....       LCALL     ??Subroutine184_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_379:
   \   0000CF   F0           MOVX      @DPTR,A
   \   0000D0   0A           INC       R2
   \   0000D1   0A           INC       R2
   \   0000D2   AB..         MOV       R3,?V5
   2997                break;
   \   0000D4   02....       LJMP      ??zclSerializeData_0 & 0xFFFF
   2998          
   2999              case ZCL_DATATYPE_DATA24:
   3000              case ZCL_DATATYPE_BITMAP24:
   3001              case ZCL_DATATYPE_UINT24:
   3002              case ZCL_DATATYPE_INT24:
   3003                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000D7   8E82         MOV       DPL,R6
   \   0000D9   8F83         MOV       DPH,R7
   \   0000DB   78..         MOV       R0,#?V0
   \   0000DD   12....       LCALL     ?L_MOV_X
   \   0000E0   8A82         MOV       DPL,R2
   \   0000E2   8B83         MOV       DPH,R3
   \   0000E4   E5..         MOV       A,?V0
   \   0000E6   12....       LCALL     ?Subroutine138 & 0xFFFF
   3004                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_247:
   \   0000E9   78..         MOV       R0,#?V0
   \   0000EB   12....       LCALL     ?L_MOV_X
   \   0000EE   E5..         MOV       A,?V1
   \   0000F0   8C82         MOV       DPL,R4
   \   0000F2   8D83         MOV       DPH,R5
   \   0000F4   12....       LCALL     ?Subroutine138 & 0xFFFF
   3005                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_248:
   \   0000F7   78..         MOV       R0,#?V0
   \   0000F9   12....       LCALL     ?L_MOV_X
   \   0000FC   7410         MOV       A,#0x10
   \   0000FE   78..         MOV       R0,#?V0
   \   000100   12....       LCALL     ?UL_SHR
   \   000103   85..82       MOV       DPL,?V4
   \   000106   85..83       MOV       DPH,?V5
   \   000109   E5..         MOV       A,?V0
   \   00010B   F0           MOVX      @DPTR,A
   \   00010C   EA           MOV       A,R2
   \   00010D   2403         ADD       A,#0x3
   \   00010F   FA           MOV       R2,A
   \   000110   506D         JNC       ??zclSerializeData_0
   \   000112   0B           INC       R3
   3006                break;
   \   000113   806A         SJMP      ??zclSerializeData_0
   3007          
   3008              case ZCL_DATATYPE_DATA32:
   3009              case ZCL_DATATYPE_BITMAP32:
   3010              case ZCL_DATATYPE_UINT32:
   3011              case ZCL_DATATYPE_INT32:
   3012              case ZCL_DATATYPE_SINGLE_PREC:
   3013              case ZCL_DATATYPE_TOD:
   3014              case ZCL_DATATYPE_DATE:
   3015              case ZCL_DATATYPE_UTC:
   3016              case ZCL_DATATYPE_BAC_OID:
   3017                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   000115                ; Setup parameters for call to function osal_buffer_uint32
   \   000115   8E82         MOV       DPL,R6
   \   000117   8F83         MOV       DPH,R7
   \   000119   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00011C   12....       LCALL     `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   00011F   7404         MOV       A,#0x4
   \   000121   12....       LCALL     ?DEALLOC_XSTACK8
   3018                break;
   \   000124   8059         SJMP      ??zclSerializeData_0
   3019          
   3020              case ZCL_DATATYPE_BITMAP40:
   3021              case ZCL_DATATYPE_UINT40:
   3022              case ZCL_DATATYPE_INT40:
   3023                pStr = (uint8*)attrData;
   3024                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   000126                ; Setup parameters for call to function osal_memcpy
   \   000126   78..         MOV       R0,#?V0
   \   000128   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00012B   7C05         MOV       R4,#0x5
   \   00012D   8046         SJMP      ??zclSerializeData_12
   3025                break;
   3026          
   3027              case ZCL_DATATYPE_BITMAP48:
   3028              case ZCL_DATATYPE_UINT48:
   3029              case ZCL_DATATYPE_INT48:
   3030                pStr = (uint8*)attrData;
   3031                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   00012F                ; Setup parameters for call to function osal_memcpy
   \   00012F   78..         MOV       R0,#?V0
   \   000131   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000134   7C06         MOV       R4,#0x6
   \   000136   803D         SJMP      ??zclSerializeData_12
   3032                break;
   3033          
   3034              case ZCL_DATATYPE_BITMAP56:
   3035              case ZCL_DATATYPE_UINT56:
   3036              case ZCL_DATATYPE_INT56:
   3037                pStr = (uint8*)attrData;
   3038                buf = zcl_memcpy( buf, pStr, 7 );
   \                     ??zclSerializeData_9:
   \   000138                ; Setup parameters for call to function osal_memcpy
   \   000138   78..         MOV       R0,#?V0
   \   00013A   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00013D   7C07         MOV       R4,#0x7
   \   00013F   8034         SJMP      ??zclSerializeData_12
   3039                break;
   3040          
   3041              case ZCL_DATATYPE_BITMAP64:
   3042              case ZCL_DATATYPE_DOUBLE_PREC:
   3043              case ZCL_DATATYPE_IEEE_ADDR:
   3044              case ZCL_DATATYPE_UINT64:
   3045              case ZCL_DATATYPE_INT64:
   3046                pStr = (uint8*)attrData;
   3047                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_10:
   \   000141                ; Setup parameters for call to function osal_memcpy
   \   000141   78..         MOV       R0,#?V0
   \   000143   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000146   7C08         MOV       R4,#0x8
   \   000148   802B         SJMP      ??zclSerializeData_12
   3048                break;
   3049          
   3050              case ZCL_DATATYPE_CHAR_STR:
   3051              case ZCL_DATATYPE_OCTET_STR:
   3052                pStr = (uint8*)attrData;
   3053                len = *pStr;
   3054                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   00014A                ; Setup parameters for call to function osal_memcpy
   \   00014A   78..         MOV       R0,#?V0
   \   00014C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00014F   8E82         MOV       DPL,R6
   \   000151   8F83         MOV       DPH,R7
   \   000153   E0           MOVX      A,@DPTR
   \   000154   2401         ADD       A,#0x1
   \   000156   FC           MOV       R4,A
   \   000157   E4           CLR       A
   \   000158   3400         ADDC      A,#0x0
   \   00015A   800F         SJMP      ??zclSerializeData_13
   3055                break;
   3056          
   3057              case ZCL_DATATYPE_LONG_CHAR_STR:
   3058              case ZCL_DATATYPE_LONG_OCTET_STR:
   3059                pStr = (uint8*)attrData;
   3060                len = BUILD_UINT16( pStr[0], pStr[1] );
   3061                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   00015C                ; Setup parameters for call to function osal_memcpy
   \   00015C   78..         MOV       R0,#?V0
   \   00015E   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000161   8E82         MOV       DPL,R6
   \   000163   8F83         MOV       DPH,R7
   \   000165   12....       LCALL     ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   000168   FC           MOV       R4,A
   \   000169   E4           CLR       A
   \   00016A   39           ADDC      A,R1
   \                     ??zclSerializeData_13:
   \   00016B   FD           MOV       R5,A
   \   00016C   8009         SJMP      ??zclSerializeData_14
   3062                break;
   3063          
   3064              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3065                pStr = (uint8*)attrData;
   3066                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_11:
   \   00016E                ; Setup parameters for call to function osal_memcpy
   \   00016E   78..         MOV       R0,#?V0
   \   000170   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000173   7C10         MOV       R4,#0x10
   \                     ??zclSerializeData_12:
   \   000175   7D00         MOV       R5,#0x0
   \                     ??zclSerializeData_14:
   \   000177   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00017A   7403         MOV       A,#0x3
   \   00017C   12....       LCALL     ?DEALLOC_XSTACK8
   3067                break;
   3068          
   3069              case ZCL_DATATYPE_NO_DATA:
   3070              case ZCL_DATATYPE_UNKNOWN:
   3071                // Fall through
   3072          
   3073              default:
   3074                break;
   3075            }
   3076          
   3077            return ( buf );
   \                     ??zclSerializeData_0:
   \   00017F   02....       LJMP      ?Subroutine9 & 0xFFFF
   3078          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   12....       LCALL     ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000003   F9           MOV       R1,A
   \   000004   EC           MOV       A,R4
   \   000005   2402         ADD       A,#0x2
   \   000007   22           RET
   3079          
   3080          #if defined ZCL_REPORTING_DEVICE || defined ZCL_REPORT_CONFIGURING_DEVICE
   3081          /*********************************************************************
   3082           * @fn      zclAnalogDataType
   3083           *
   3084           * @brief   Checks to see if Data Type is Analog
   3085           *
   3086           * @param   dataType - data type
   3087           *
   3088           * @return  TRUE if data type is analog
   3089           */
   3090          uint8 zclAnalogDataType( uint8 dataType )
   3091          {
   3092            uint8 analog;
   3093          
   3094            switch ( dataType )
   3095            {
   3096              case ZCL_DATATYPE_UINT8:
   3097              case ZCL_DATATYPE_UINT16:
   3098              case ZCL_DATATYPE_UINT24:
   3099              case ZCL_DATATYPE_UINT32:
   3100              case ZCL_DATATYPE_UINT40:
   3101              case ZCL_DATATYPE_UINT48:
   3102              case ZCL_DATATYPE_UINT56:
   3103              case ZCL_DATATYPE_UINT64:
   3104              case ZCL_DATATYPE_INT8:
   3105              case ZCL_DATATYPE_INT16:
   3106              case ZCL_DATATYPE_INT24:
   3107              case ZCL_DATATYPE_INT32:
   3108              case ZCL_DATATYPE_INT40:
   3109              case ZCL_DATATYPE_INT48:
   3110              case ZCL_DATATYPE_INT56:
   3111              case ZCL_DATATYPE_INT64:
   3112              case ZCL_DATATYPE_SEMI_PREC:
   3113              case ZCL_DATATYPE_SINGLE_PREC:
   3114              case ZCL_DATATYPE_DOUBLE_PREC:
   3115              case ZCL_DATATYPE_TOD:
   3116              case ZCL_DATATYPE_DATE:
   3117              case ZCL_DATATYPE_UTC:
   3118                analog = TRUE;
   3119                break;
   3120          
   3121              default:
   3122                analog = FALSE;
   3123                break;
   3124            }
   3125          
   3126            return ( analog );
   3127          }
   3128          
   3129          /*********************************************************************
   3130           * @fn      zclIsLittleEndianMachine
   3131           *
   3132           * @brief   Verifies endianness in system.
   3133           *
   3134           * @param   none
   3135           *
   3136           * @return  MSB-00 or LSB-01 depending on endianness in the system
   3137           */
   3138          static int zclIsLittleEndianMachine(void)
   3139          {
   3140            uint16 test = 0x0001;
   3141          
   3142            return (*((uint8 *)(&test)));
   3143          }
   3144          
   3145          /*********************************************************************
   3146           * @fn      zcl_BuildAnalogData
   3147           *
   3148           * @brief   Build an analog arribute out of sequential bytes.
   3149           *
   3150           * @param   dataType - type of data
   3151           * @param   pData - pointer to data
   3152           * @param   pBuf - where to put the data
   3153           *
   3154           * @return  none
   3155           */
   3156          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   3157          {
   3158            int current_byte_index;
   3159            int remaining_bytes;
   3160            int step;
   3161          
   3162            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   3163          
   3164            // decide if move forward or backwards to copy data
   3165            if ( zclIsLittleEndianMachine() )
   3166            {
   3167              step = 1;
   3168              current_byte_index = 0;
   3169            }
   3170            else
   3171            {
   3172              step = -1;
   3173              current_byte_index = remaining_bytes - 1;
   3174            }
   3175          
   3176            while ( remaining_bytes-- )
   3177            {
   3178              pData[current_byte_index] = *(pBuf++);
   3179              current_byte_index += step;
   3180            }
   3181          }
   3182          #endif
   3183          
   3184          /*********************************************************************
   3185           * @fn      zclGetDataTypeLength
   3186           *
   3187           * @brief   Return the length of the datatype in octet.
   3188           *
   3189           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   3190           *                ZCL_DATATYPE_CHAR_STR data types.
   3191           *
   3192           * @param   dataType - data type
   3193           *
   3194           * @return  length of data
   3195           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3196          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   3197          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV       A,R1
   3198            uint8 len;
   3199          
   3200            switch ( dataType )
   \   000001   24F8         ADD       A,#-0x8
   \   000003   6078         JZ        ??zclGetDataTypeLength_0
   \   000005   14           DEC       A
   \   000006   6079         JZ        ??zclGetDataTypeLength_1
   \   000008   14           DEC       A
   \   000009   607A         JZ        ??zclGetDataTypeLength_2
   \   00000B   14           DEC       A
   \   00000C   607B         JZ        ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD       A,#-0x5
   \   000010   606B         JZ        ??zclGetDataTypeLength_0
   \   000012   24F8         ADD       A,#-0x8
   \   000014   6067         JZ        ??zclGetDataTypeLength_0
   \   000016   14           DEC       A
   \   000017   6068         JZ        ??zclGetDataTypeLength_1
   \   000019   14           DEC       A
   \   00001A   6069         JZ        ??zclGetDataTypeLength_2
   \   00001C   14           DEC       A
   \   00001D   606A         JZ        ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD       A,#-0x5
   \   000021   605A         JZ        ??zclGetDataTypeLength_0
   \   000023   14           DEC       A
   \   000024   605B         JZ        ??zclGetDataTypeLength_1
   \   000026   14           DEC       A
   \   000027   605C         JZ        ??zclGetDataTypeLength_2
   \   000029   14           DEC       A
   \   00002A   605D         JZ        ??zclGetDataTypeLength_3
   \   00002C   14           DEC       A
   \   00002D   605E         JZ        ??zclGetDataTypeLength_4
   \   00002F   14           DEC       A
   \   000030   605F         JZ        ??zclGetDataTypeLength_5
   \   000032   14           DEC       A
   \   000033   6060         JZ        ??zclGetDataTypeLength_6
   \   000035   14           DEC       A
   \   000036   6061         JZ        ??zclGetDataTypeLength_7
   \   000038   14           DEC       A
   \   000039   6042         JZ        ??zclGetDataTypeLength_0
   \   00003B   14           DEC       A
   \   00003C   6043         JZ        ??zclGetDataTypeLength_1
   \   00003E   14           DEC       A
   \   00003F   6044         JZ        ??zclGetDataTypeLength_2
   \   000041   14           DEC       A
   \   000042   6045         JZ        ??zclGetDataTypeLength_3
   \   000044   14           DEC       A
   \   000045   6046         JZ        ??zclGetDataTypeLength_4
   \   000047   14           DEC       A
   \   000048   6047         JZ        ??zclGetDataTypeLength_5
   \   00004A   14           DEC       A
   \   00004B   6048         JZ        ??zclGetDataTypeLength_6
   \   00004D   14           DEC       A
   \   00004E   6049         JZ        ??zclGetDataTypeLength_7
   \   000050   14           DEC       A
   \   000051   602A         JZ        ??zclGetDataTypeLength_0
   \   000053   14           DEC       A
   \   000054   602B         JZ        ??zclGetDataTypeLength_1
   \   000056   24F9         ADD       A,#-0x7
   \   000058   6027         JZ        ??zclGetDataTypeLength_1
   \   00005A   14           DEC       A
   \   00005B   602C         JZ        ??zclGetDataTypeLength_3
   \   00005D   14           DEC       A
   \   00005E   6039         JZ        ??zclGetDataTypeLength_7
   \   000060   245A         ADD       A,#0x5a
   \   000062   6025         JZ        ??zclGetDataTypeLength_3
   \   000064   14           DEC       A
   \   000065   6022         JZ        ??zclGetDataTypeLength_3
   \   000067   14           DEC       A
   \   000068   601F         JZ        ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD       A,#-0x6
   \   00006C   6013         JZ        ??zclGetDataTypeLength_1
   \   00006E   14           DEC       A
   \   00006F   6010         JZ        ??zclGetDataTypeLength_1
   \   000071   14           DEC       A
   \   000072   6015         JZ        ??zclGetDataTypeLength_3
   \   000074   24FA         ADD       A,#-0x6
   \   000076   6021         JZ        ??zclGetDataTypeLength_7
   \   000078   14           DEC       A
   \   000079   6022         JZ        ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP      ??zclGetDataTypeLength_9
   3201            {
   3202              case ZCL_DATATYPE_DATA8:
   3203              case ZCL_DATATYPE_BOOLEAN:
   3204              case ZCL_DATATYPE_BITMAP8:
   3205              case ZCL_DATATYPE_INT8:
   3206              case ZCL_DATATYPE_UINT8:
   3207              case ZCL_DATATYPE_ENUM8:
   3208                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV       R1,#0x1
   3209                break;
   \   00007F   8022         SJMP      ??zclGetDataTypeLength_10
   3210          
   3211              case ZCL_DATATYPE_DATA16:
   3212              case ZCL_DATATYPE_BITMAP16:
   3213              case ZCL_DATATYPE_UINT16:
   3214              case ZCL_DATATYPE_INT16:
   3215              case ZCL_DATATYPE_ENUM16:
   3216              case ZCL_DATATYPE_SEMI_PREC:
   3217              case ZCL_DATATYPE_CLUSTER_ID:
   3218              case ZCL_DATATYPE_ATTR_ID:
   3219                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV       R1,#0x2
   3220                break;
   \   000083   801E         SJMP      ??zclGetDataTypeLength_10
   3221          
   3222              case ZCL_DATATYPE_DATA24:
   3223              case ZCL_DATATYPE_BITMAP24:
   3224              case ZCL_DATATYPE_UINT24:
   3225              case ZCL_DATATYPE_INT24:
   3226                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV       R1,#0x3
   3227                break;
   \   000087   801A         SJMP      ??zclGetDataTypeLength_10
   3228          
   3229              case ZCL_DATATYPE_DATA32:
   3230              case ZCL_DATATYPE_BITMAP32:
   3231              case ZCL_DATATYPE_UINT32:
   3232              case ZCL_DATATYPE_INT32:
   3233              case ZCL_DATATYPE_SINGLE_PREC:
   3234              case ZCL_DATATYPE_TOD:
   3235              case ZCL_DATATYPE_DATE:
   3236              case ZCL_DATATYPE_UTC:
   3237              case ZCL_DATATYPE_BAC_OID:
   3238                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV       R1,#0x4
   3239                break;
   \   00008B   8016         SJMP      ??zclGetDataTypeLength_10
   3240          
   3241             case ZCL_DATATYPE_UINT40:
   3242             case ZCL_DATATYPE_INT40:
   3243                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV       R1,#0x5
   3244                 break;
   \   00008F   8012         SJMP      ??zclGetDataTypeLength_10
   3245          
   3246             case ZCL_DATATYPE_UINT48:
   3247             case ZCL_DATATYPE_INT48:
   3248                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV       R1,#0x6
   3249                 break;
   \   000093   800E         SJMP      ??zclGetDataTypeLength_10
   3250          
   3251             case ZCL_DATATYPE_UINT56:
   3252             case ZCL_DATATYPE_INT56:
   3253                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV       R1,#0x7
   3254                 break;
   \   000097   800A         SJMP      ??zclGetDataTypeLength_10
   3255          
   3256             case ZCL_DATATYPE_DOUBLE_PREC:
   3257             case ZCL_DATATYPE_IEEE_ADDR:
   3258             case ZCL_DATATYPE_UINT64:
   3259             case ZCL_DATATYPE_INT64:
   3260               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV       R1,#0x8
   3261               break;
   \   00009B   8006         SJMP      ??zclGetDataTypeLength_10
   3262          
   3263              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   3264               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV       R1,#0x10
   3265               break;
   \   00009F   8002         SJMP      ??zclGetDataTypeLength_10
   3266          
   3267              case ZCL_DATATYPE_NO_DATA:
   3268              case ZCL_DATATYPE_UNKNOWN:
   3269                // Fall through
   3270          
   3271              default:
   3272                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV       R1,#0x0
   3273                break;
   3274            }
   3275          
   3276            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP      ?BRET
   3277          }
   3278          
   3279          /*********************************************************************
   3280           * @fn      zclGetAttrDataLength
   3281           *
   3282           * @brief   Return the length of the attribute.
   3283           *
   3284           * @param   dataType - data type
   3285           * @param   pData - pointer to data
   3286           *
   3287           * @return  returns atrribute length
   3288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3289          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   3290          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   3291            uint16 dataLen = 0;
   3292          
   3293            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV       A,#0x44
   \   000009   6E           XRL       A,R6
   \   00000A   6005         JZ        ??zclGetAttrDataLength_0
   \   00000C   7443         MOV       A,#0x43
   \   00000E   6E           XRL       A,R6
   \   00000F   700C         JNZ       ??zclGetAttrDataLength_1
   3294            {
   3295              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV       DPL,R2
   \   000013   8B83         MOV       DPH,R3
   \   000015   12....       LCALL     ?Subroutine106 & 0xFFFF
   3296            }
   \                     ??CrossCallReturnLabel_182:
   \   000018   FA           MOV       R2,A
   \   000019   E4           CLR       A
   \   00001A   39           ADDC      A,R1
   \   00001B   8015         SJMP      ??zclGetAttrDataLength_2
   3297            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV       A,#0x42
   \   00001F   6E           XRL       A,R6
   \   000020   6005         JZ        ??zclGetAttrDataLength_3
   \   000022   7441         MOV       A,#0x41
   \   000024   6E           XRL       A,R6
   \   000025   700E         JNZ       ??zclGetAttrDataLength_4
   3298            {
   3299              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV       DPL,R2
   \   000029   8B83         MOV       DPH,R3
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   2401         ADD       A,#0x1
   \   00002E   FA           MOV       R2,A
   \   00002F   E4           CLR       A
   \   000030   3400         ADDC      A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV       R3,A
   \   000033   8007         SJMP      ??zclGetAttrDataLength_5
   3300            }
   3301            else
   3302            {
   3303              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL     `??zclGetDataTypeLength::?relay`; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV       A,R1
   \   000039   FA           MOV       R2,A
   \   00003A   7B00         MOV       R3,#0x0
   3304            }
   3305          
   3306            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP      ??Subroutine179_0 & 0xFFFF
   3307          }
   3308          
   3309          #ifdef ZCL_READ
   3310          /*********************************************************************
   3311           * @fn      zclReadAttrData
   3312           *
   3313           * @brief   Read the attribute's current value into pAttrData.
   3314           *          NOTE - Not compatible with application's attributes callbacks.
   3315           *
   3316           * @param   pAttrData - where to put attribute data
   3317           * @param   pAttr - pointer to attribute
   3318           * @param   pDataLen - where to put attribute data length
   3319           *
   3320           * @return Success
   3321           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3322          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   3323          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   3324            uint16 dataLen;
   3325          
   3326            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV       A,R4
   \   00000A   2406         ADD       A,#0x6
   \   00000C   F8           MOV       R0,A
   \   00000D   E4           CLR       A
   \   00000E   3D           ADDC      A,R5
   \   00000F   F9           MOV       R1,A
   \   000010   88..         MOV       ?V0,R0
   \   000012   89..         MOV       ?V1,R1
   \   000014   8882         MOV       DPL,R0
   \   000016   F583         MOV       DPH,A
   \   000018   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   00001B   7004         JNZ       ??zclReadAttrData_0
   3327            {
   3328              return ( ZCL_STATUS_FAILURE );
   \   00001D   7901         MOV       R1,#0x1
   \   00001F   804C         SJMP      ??zclReadAttrData_1
   3329            }
   3330          
   3331            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000021                ; Setup parameters for call to function zclGetAttrDataLength
   \   000021   8C82         MOV       DPL,R4
   \   000023   8D83         MOV       DPH,R5
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   F9           MOV       R1,A
   \   00002B   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00002E   8A..         MOV       ?V2,R2
   \   000030   8B..         MOV       ?V3,R3
   3332            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   85..82       MOV       DPL,?V0
   \   000035   85..83       MOV       DPH,?V1
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F5..         MOV       ?V0,A
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   85....       MOV       ?V4,?V0
   \   000040   F5..         MOV       ?V5,A
   \   000042   75..00       MOV       ?V6,#0x0
   \   000045   78..         MOV       R0,#?V4
   \   000047   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00004A   AC..         MOV       R4,?V2
   \   00004C   AD..         MOV       R5,?V3
   \   00004E   EE           MOV       A,R6
   \   00004F   FA           MOV       R2,A
   \   000050   EF           MOV       A,R7
   \   000051   FB           MOV       R3,A
   \   000052   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000055   7403         MOV       A,#0x3
   \   000057   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005A   740F         MOV       A,#0xf
   \   00005C   12....       LCALL     ?XSTACK_DISP0_8
   \   00005F   12....       LCALL     ??Subroutine177_0 & 0xFFFF
   3333          
   3334            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_323:
   \   000062   6007         JZ        ??zclReadAttrData_2
   3335            {
   3336              *pDataLen = dataLen;
   \   000064   E5..         MOV       A,?V2
   \   000066   F0           MOVX      @DPTR,A
   \   000067   A3           INC       DPTR
   \   000068   E5..         MOV       A,?V3
   \   00006A   F0           MOVX      @DPTR,A
   3337            }
   3338          
   3339            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   00006B   7900         MOV       R1,#0x0
   \                     ??zclReadAttrData_1:
   \   00006D                REQUIRE ?Subroutine9
   \   00006D                ; // Fall through to label ?Subroutine9
   3340          }
   3341          
   3342          /*********************************************************************
   3343           * @fn      zcl_ReadAttrData
   3344           *
   3345           * @brief   Read the attribute's current value into pAttrData.
   3346           *          Use application's callback function if assigned to this attribute.
   3347           *
   3348           * @param   endpoint - application's endpoint
   3349           * @param   clusterId - cluster that attribute belongs to
   3350           * @param   attrId - attribute id
   3351           * @param   pAttrData - where to put attribute data
   3352           * @param   pDataLen - where to put attribute data length
   3353           *
   3354           * @return  Successful if data was read
   3355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine180_0
   \   000003                ; // Fall through to label ??Subroutine180_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3356          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   3357                                                   uint8 *pAttrData, uint16 *pDataLen )
   3358          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V2,R1
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   EC           MOV       A,R4
   \   000011   FE           MOV       R6,A
   \   000012   ED           MOV       A,R5
   \   000013   FF           MOV       R7,A
   3359            zclAttrRec_t attrRec;
   3360          
   3361            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   000014                ; Setup parameters for call to function zclFindAttrRec
   \   000014   A8..         MOV       R0,?XSP + 0
   \   000016   A9..         MOV       R1,?XSP + 1
   \   000018   88..         MOV       ?V4,R0
   \   00001A   89..         MOV       ?V5,R1
   \   00001C   78..         MOV       R0,#?V4
   \   00001E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000021   A9..         MOV       R1,?V2
   \   000023   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   000026   7402         MOV       A,#0x2
   \   000028   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002B   E9           MOV       A,R1
   \   00002C   7004         JNZ       ??zcl_ReadAttrData_0
   3362            {
   3363              return ( ZCL_STATUS_FAILURE );
   \   00002E   7901         MOV       R1,#0x1
   \   000030   804C         SJMP      ??zcl_ReadAttrData_1
   3364            }
   \                     ??zcl_ReadAttrData_0:
   \   000032   7418         MOV       A,#0x18
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   12....       LCALL     ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_457:
   \   00003A   741A         MOV       A,#0x1a
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   12....       LCALL     ?Subroutine89 & 0xFFFF
   3365          
   3366            if ( attrRec.attr.dataPtr != NULL )
   \                     ??CrossCallReturnLabel_148:
   \   000042   7406         MOV       A,#0x6
   \   000044   12....       LCALL     ?XSTACK_DISP0_8
   \   000047   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   00004A   78..         MOV       R0,#?V4
   \   00004C   6016         JZ        ??zcl_ReadAttrData_2
   3367            {
   3368              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   00004E                ; Setup parameters for call to function zclReadAttrData
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   7402         MOV       A,#0x2
   \   000053   12....       LCALL     ?XSTACK_DISP102_8
   \   000056   AA..         MOV       R2,?V6
   \   000058   AB..         MOV       R3,?V7
   \   00005A   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   00005D   7402         MOV       A,#0x2
   \   00005F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000062   801A         SJMP      ??zcl_ReadAttrData_1
   3369            }
   3370            else
   3371            {
   3372              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000064                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000064   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000067   78..         MOV       R0,#?V6
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006C   EE           MOV       A,R6
   \   00006D   FC           MOV       R4,A
   \   00006E   EF           MOV       A,R7
   \   00006F   FD           MOV       R5,A
   \   000070   AA..         MOV       R2,?V0
   \   000072   AB..         MOV       R3,?V1
   \   000074   A9..         MOV       R1,?V2
   \   000076   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   000079   7404         MOV       A,#0x4
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   00007E   7408         MOV       A,#0x8
   3373            }
   \   000080   02....       LJMP      ?Subroutine8 & 0xFFFF
   3374          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine201_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V6,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V7,A
   \   000007   22           RET
   3375          
   3376          /*********************************************************************
   3377           * @fn      zclGetAttrDataLengthUsingCB
   3378           *
   3379           * @brief   Use application's callback to get the length of the attribute's
   3380           *          current value stored in the database.
   3381           *
   3382           * @param   endpoint - application's endpoint
   3383           * @param   clusterId - cluster that attribute belongs to
   3384           * @param   attrId - attribute id
   3385           *
   3386           * @return  returns attribute length
   3387           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3388          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3389          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V4,R2
   \   00000C   8B..         MOV       ?V5,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   3390            uint16 dataLen = 0;
   \   000012   85..82       MOV       DPL,?XSP + 0
   \   000015   85..83       MOV       DPH,?XSP + 1
   \   000018   E4           CLR       A
   \   000019   F0           MOVX      @DPTR,A
   \   00001A   A3           INC       DPTR
   \   00001B   F0           MOVX      @DPTR,A
   3391            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001C                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001C   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   00001F   8A..         MOV       ?V0,R2
   \   000021   8B..         MOV       ?V1,R3
   3392          
   3393            if ( pfnReadWriteCB != NULL )
   \   000023   EA           MOV       A,R2
   \   000024   45..         ORL       A,?V1
   \   000026   602F         JZ        ??zclGetAttrDataLengthUsingCB_0
   3394            {
   3395              // Only get the attribute length
   3396              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000028                ; Setup parameters for indirect call
   \   000028   A8..         MOV       R0,?XSP + 0
   \   00002A   A9..         MOV       R1,?XSP + 1
   \   00002C   88..         MOV       ?V6,R0
   \   00002E   89..         MOV       ?V7,R1
   \   000030   78..         MOV       R0,#?V6
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000035   E4           CLR       A
   \   000036   F5..         MOV       ?V6,A
   \   000038   F5..         MOV       ?V7,A
   \   00003A   78..         MOV       R0,#?V6
   \   00003C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003F   7900         MOV       R1,#0x0
   \   000041   EE           MOV       A,R6
   \   000042   FC           MOV       R4,A
   \   000043   EF           MOV       A,R7
   \   000044   FD           MOV       R5,A
   \   000045   AA..         MOV       R2,?V4
   \   000047   AB..         MOV       R3,?V5
   \   000049   85..82       MOV       DPL,?V0
   \   00004C   85..83       MOV       DPH,?V1
   \   00004F   12....       LCALL     ?CALL_IND
   \   000052   7404         MOV       A,#0x4
   \   000054   12....       LCALL     ?DEALLOC_XSTACK8
   3397            }
   3398          
   3399            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000057   85..82       MOV       DPL,?XSP + 0
   \   00005A   85..83       MOV       DPH,?XSP + 1
   \   00005D   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_444:
   \   000060   7402         MOV       A,#0x2
   \   000062   02....       LJMP      ?Subroutine8 & 0xFFFF
   3400          }
   3401          
   3402          /*********************************************************************
   3403           * @fn      zclReadAttrDataUsingCB
   3404           *
   3405           * @brief   Use application's callback to read the attribute's current
   3406           *          value stored in the database.
   3407           *
   3408           * @param   endpoint - application's endpoint
   3409           * @param   clusterId - cluster that attribute belongs to
   3410           * @param   attrId - attribute id
   3411           * @param   pAttrData - where to put attribute data
   3412           * @param   pDataLen - where to put attribute data length
   3413           *
   3414           * @return  Successful if data was read
   3415           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3416          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3417                                                   uint8 *pAttrData, uint16 *pDataLen )
   3418          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   3419            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00000D   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000010   8A..         MOV       ?V2,R2
   \   000012   8B..         MOV       ?V3,R3
   \   000014   7412         MOV       A,#0x12
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ??Subroutine201_0 & 0xFFFF
   3420          
   3421            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_458:
   \   00001C   E5..         MOV       A,?V6
   \   00001E   45..         ORL       A,?V7
   \   000020   600A         JZ        ??zclReadAttrDataUsingCB_0
   3422            {
   3423              *pDataLen = 0; // Always initialize it to 0
   \   000022   85..82       MOV       DPL,?V6
   \   000025   85..83       MOV       DPH,?V7
   \   000028   E4           CLR       A
   \   000029   F0           MOVX      @DPTR,A
   \   00002A   A3           INC       DPTR
   \   00002B   F0           MOVX      @DPTR,A
   3424            }
   3425          
   3426            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00002C   EA           MOV       A,R2
   \   00002D   45..         ORL       A,?V3
   \   00002F   6027         JZ        ??zclReadAttrDataUsingCB_1
   3427            {
   3428              // Read the attribute value and its length
   3429              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000031                ; Setup parameters for indirect call
   \   000031   78..         MOV       R0,#?V6
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000036   7412         MOV       A,#0x12
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00003E   7901         MOV       R1,#0x1
   \   000040   EE           MOV       A,R6
   \   000041   FC           MOV       R4,A
   \   000042   EF           MOV       A,R7
   \   000043   FD           MOV       R5,A
   \   000044   AA..         MOV       R2,?V0
   \   000046   AB..         MOV       R3,?V1
   \   000048   85..82       MOV       DPL,?V2
   \   00004B   85..83       MOV       DPH,?V3
   \   00004E   12....       LCALL     ?CALL_IND
   \   000051   7404         MOV       A,#0x4
   \   000053   12....       LCALL     ?DEALLOC_XSTACK8
   \   000056   8002         SJMP      ??zclReadAttrDataUsingCB_2
   3430            }
   3431          
   3432            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000058   79C1         MOV       R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00005A   02....       LJMP      ??Subroutine180_0 & 0xFFFF
   3433          }
   3434          
   3435          /*********************************************************************
   3436           * @fn      zclAuthorizeRead
   3437           *
   3438           * @brief   Use application's callback to authorize a Read operation
   3439           *          on a given attribute.
   3440           *
   3441           * @param   endpoint - application's endpoint
   3442           * @param   srcAddr - source Address
   3443           * @param   pAttr - pointer to attribute
   3444           *
   3445           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3446           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3447           */
   3448          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3449          {
   3450            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3451            {
   3452              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3453          
   3454              if ( pfnAuthorizeCB != NULL )
   3455              {
   3456                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3457              }
   3458            }
   3459          
   3460            return ( ZCL_STATUS_SUCCESS );
   3461          }
   3462          #endif // ZCL_READ
   3463          
   3464          #ifdef ZCL_WRITE
   3465          /*********************************************************************
   3466           * @fn      zclWriteAttrData
   3467           *
   3468           * @brief   Write the received data.
   3469           *
   3470           * @param   endpoint - application's endpoint
   3471           * @param   pAttr - where to write data to
   3472           * @param   pWriteRec - data to be written
   3473           *
   3474           * @return  Successful if data was written
   3475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3476          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3477                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3478          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV       A,R4
   \   000006   FE           MOV       R6,A
   \   000007   ED           MOV       A,R5
   \   000008   FF           MOV       R7,A
   3479            uint8 status;
   3480          
   3481            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000009   8E82         MOV       DPL,R6
   \   00000B   8F83         MOV       DPH,R7
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   A2E1         MOV       C,0xE0 /* A   */.1
   \   000015   5077         JNC       ??zclWriteAttrData_0
   3482            {
   3483              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017                ; Setup parameters for call to function zclAuthorizeWrite
   \   000017   12....       LCALL     `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001A   E9           MOV       A,R1
   \   00001B   F5..         MOV       ?V2,A
   3484              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7072         JNZ       ??zclWriteAttrData_1
   \   00001F   740F         MOV       A,#0xf
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ??Subroutine186_0 & 0xFFFF
   3485              {
   3486                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \                     ??CrossCallReturnLabel_388:
   \   000027   90....       MOV       DPTR,#zcl_ValidateAttrDataCB
   \   00002A   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_346:
   \   00002D   6013         JZ        ??zclWriteAttrData_2
   \   00002F                ; Setup parameters for indirect call
   \   00002F   AC..         MOV       R4,?V0
   \   000031   AD..         MOV       R5,?V1
   \   000033   EE           MOV       A,R6
   \   000034   FA           MOV       R2,A
   \   000035   EF           MOV       A,R7
   \   000036   FB           MOV       R3,A
   \   000037   E0           MOVX      A,@DPTR
   \   000038   F583         MOV       DPH,A
   \   00003A   8882         MOV       DPL,R0
   \   00003C   12....       LCALL     ?CALL_IND
   \   00003F   E9           MOV       A,R1
   \   000040   6047         JZ        ??zclWriteAttrData_3
   3487                {
   3488                  // Write the attribute value
   3489                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000042   E5..         MOV       A,?V0
   \   000044   2403         ADD       A,#0x3
   \   000046   F8           MOV       R0,A
   \   000047   E4           CLR       A
   \   000048   35..         ADDC      A,?V1
   \   00004A   F9           MOV       R1,A
   \   00004B   88..         MOV       ?V0,R0
   \   00004D   89..         MOV       ?V1,R1
   \   00004F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00004F   8882         MOV       DPL,R0
   \   000051   F583         MOV       DPH,A
   \   000053   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_445:
   \   000056   8E82         MOV       DPL,R6
   \   000058   8F83         MOV       DPH,R7
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   A3           INC       DPTR
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F9           MOV       R1,A
   \   000060   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000063   8A..         MOV       ?V4,R2
   \   000065   8B..         MOV       ?V5,R3
   \   000067   AC..         MOV       R4,?V4
   \   000069   AD..         MOV       R5,?V5
   3490                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00006B                ; Setup parameters for call to function osal_memcpy
   \   00006B   85..82       MOV       DPL,?V0
   \   00006E   85..83       MOV       DPH,?V1
   \   000071   12....       LCALL     ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000074   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000077   8E82         MOV       DPL,R6
   \   000079   8F83         MOV       DPH,R7
   \   00007B   A3           INC       DPTR
   \   00007C   12....       LCALL     ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_456:
   \   00007F   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000082   7403         MOV       A,#0x3
   \   000084   12....       LCALL     ?DEALLOC_XSTACK8
   3491          
   3492                  status = ZCL_STATUS_SUCCESS;
   \   000087   8008         SJMP      ??zclWriteAttrData_1
   3493                }
   3494                else
   3495                {
   3496                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   000089   75..87       MOV       ?V2,#-0x79
   \   00008C   8003         SJMP      ??zclWriteAttrData_1
   3497                }
   3498              }
   3499            }
   3500            else
   3501            {
   3502              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   00008E   75..88       MOV       ?V2,#-0x78
   3503            }
   3504          
   3505            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000091   A9..         MOV       R1,?V2
   \   000093   02....       LJMP      ?Subroutine9 & 0xFFFF
   3506          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine186_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V1,A
   \   000007   22           RET
   3507          
   3508          /*********************************************************************
   3509           * @fn      zclWriteAttrDataUsingCB
   3510           *
   3511           * @brief   Use application's callback to write the attribute's current
   3512           *          value stored in the database.
   3513           *
   3514           * @param   endpoint - application's endpoint
   3515           * @param   pAttr - where to write data to
   3516           * @param   pAttrData - data to be written
   3517           *
   3518           * @return  Successful if data was written
   3519           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3520          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3521                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3522          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   EC           MOV       A,R4
   \   000008   FE           MOV       R6,A
   \   000009   ED           MOV       A,R5
   \   00000A   FF           MOV       R7,A
   3523            uint8 status;
   3524          
   3525            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000B   8E82         MOV       DPL,R6
   \   00000D   8F83         MOV       DPH,R7
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   A2E1         MOV       C,0xE0 /* A   */.1
   \   000017   504D         JNC       ??zclWriteAttrDataUsingCB_0
   3526            {
   3527              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000019                ; Setup parameters for call to function zclAuthorizeWrite
   \   000019   12....       LCALL     `??zclAuthorizeWrite::?relay`; Banked call to: zclAuthorizeWrite
   \   00001C   E9           MOV       A,R1
   \   00001D   F9           MOV       R1,A
   3528              if ( status == ZCL_STATUS_SUCCESS )
   \   00001E   7048         JNZ       ??zclWriteAttrDataUsingCB_1
   3529              {
   3530                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000020                ; Setup parameters for call to function zclGetReadWriteCB
   \   000020   A9..         MOV       R1,?V0
   \   000022   12....       LCALL     `??zclGetReadWriteCB::?relay`; Banked call to: zclGetReadWriteCB
   \   000025   8A..         MOV       ?V2,R2
   \   000027   8B..         MOV       ?V3,R3
   3531                if ( pfnReadWriteCB != NULL )
   \   000029   EA           MOV       A,R2
   \   00002A   45..         ORL       A,?V3
   \   00002C   6034         JZ        ??zclWriteAttrDataUsingCB_2
   3532                {
   3533                  // Write the attribute value
   3534                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3535                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   00002E                ; Setup parameters for indirect call
   \   00002E   E4           CLR       A
   \   00002F   F5..         MOV       ?V4,A
   \   000031   F5..         MOV       ?V5,A
   \   000033   78..         MOV       R0,#?V4
   \   000035   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000038   7410         MOV       A,#0x10
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000040   7902         MOV       R1,#0x2
   \   000042   8E82         MOV       DPL,R6
   \   000044   8F83         MOV       DPH,R7
   \   000046   12....       LCALL     ??Subroutine202_0 & 0xFFFF
   3536                }
   \                     ??CrossCallReturnLabel_468:
   \   000049   8E82         MOV       DPL,R6
   \   00004B   8F83         MOV       DPH,R7
   \   00004D   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_446:
   \   000050   85..82       MOV       DPL,?V2
   \   000053   85..83       MOV       DPH,?V3
   \   000056   12....       LCALL     ?CALL_IND
   \   000059   7404         MOV       A,#0x4
   \   00005B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005E   E9           MOV       A,R1
   \   00005F   F9           MOV       R1,A
   \   000060   8006         SJMP      ??zclWriteAttrDataUsingCB_1
   3537                else
   3538                {
   3539                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000062   79C1         MOV       R1,#-0x3f
   \   000064   8002         SJMP      ??zclWriteAttrDataUsingCB_1
   3540                }
   3541              }
   3542            }
   3543            else
   3544            {
   3545              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   000066   7988         MOV       R1,#-0x78
   3546            }
   3547          
   3548            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000068                REQUIRE ?Subroutine4
   \   000068                ; // Fall through to label ?Subroutine4
   3549          }
   3550          
   3551          /*********************************************************************
   3552           * @fn      zclAuthorizeWrite
   3553           *
   3554           * @brief   Use application's callback to authorize a Write operation
   3555           *          on a given attribute.
   3556           *
   3557           * @param   endpoint - application's endpoint
   3558           * @param   srcAddr - source Address
   3559           * @param   pAttr - pointer to attribute
   3560           *
   3561           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3562           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3563           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3564          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3565          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   3566            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000D   8C82         MOV       DPL,R4
   \   00000F   8D83         MOV       DPH,R5
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   A2E5         MOV       C,0xE0 /* A   */.5
   \   000019   501C         JNC       ??zclAuthorizeWrite_0
   3567            {
   3568              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001B                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001B   12....       LCALL     `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   00001E   8A82         MOV       DPL,R2
   \   000020   8B83         MOV       DPH,R3
   3569          
   3570              if ( pfnAuthorizeCB != NULL )
   \   000022   E582         MOV       A,DPL
   \   000024   4583         ORL       A,DPH
   \   000026   600F         JZ        ??zclAuthorizeWrite_0
   3571              {
   3572                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000028                ; Setup parameters for indirect call
   \   000028   7902         MOV       R1,#0x2
   \   00002A   AC..         MOV       R4,?V0
   \   00002C   AD..         MOV       R5,?V1
   \   00002E   EE           MOV       A,R6
   \   00002F   FA           MOV       R2,A
   \   000030   EF           MOV       A,R7
   \   000031   FB           MOV       R3,A
   \   000032   12....       LCALL     ?CALL_IND
   \   000035   8002         SJMP      ??zclAuthorizeWrite_1
   3573              }
   3574            }
   3575          
   3576            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000037   7900         MOV       R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000039   80..         SJMP      ?Subroutine4
   3577          }
   3578          #endif // ZCL_WRITE
   3579          
   3580          #ifdef ZCL_READ
   3581          /*********************************************************************
   3582           * @fn      zclParseInReadCmd
   3583           *
   3584           * @brief   Parse the "Profile" Read Commands
   3585           *
   3586           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3587           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3588           *
   3589           * @param   pCmd - pointer to incoming data to parse
   3590           *
   3591           * @return  pointer to the parsed command structure
   3592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3593          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3594          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3595            zclReadCmd_t *readCmd;
   3596            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL     ?Subroutine85 & 0xFFFF
   3597          
   3598            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_140:
   \   000008   12....       LCALL     ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   00000B   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3599            if ( readCmd != NULL )
   \   00000E   EA           MOV       A,R2
   \   00000F   4B           ORL       A,R3
   \   000010   6054         JZ        ??zclParseInReadCmd_0
   3600            {
   3601              uint8 i;
   3602              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000012   85..82       MOV       DPL,?V0
   \   000015   85..83       MOV       DPH,?V1
   \   000018   12....       LCALL     ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   00001B   C3           CLR       C
   \   00001C   13           RRC       A
   \   00001D   E8           MOV       A,R0
   \   00001E   13           RRC       A
   \   00001F   8A82         MOV       DPL,R2
   \   000021   8B83         MOV       DPH,R3
   \   000023   F0           MOVX      @DPTR,A
   3603              for ( i = 0; i < readCmd->numAttr; i++ )
   \   000024   7C00         MOV       R4,#0x0
   \   000026   8033         SJMP      ??zclParseInReadCmd_1
   3604              {
   3605                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   000028   8E82         MOV       DPL,R6
   \   00002A   8F83         MOV       DPH,R7
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F5..         MOV       ?V0,A
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F8           MOV       R0,A
   \   000032   E4           CLR       A
   \   000033   C8           XCH       A,R0
   \   000034   F9           MOV       R1,A
   \   000035   E5..         MOV       A,?V0
   \   000037   28           ADD       A,R0
   \   000038   E4           CLR       A
   \   000039   39           ADDC      A,R1
   \   00003A   F5..         MOV       ?V1,A
   \   00003C   EC           MOV       A,R4
   \   00003D   25E0         ADD       A,0xE0 /* A   */
   \   00003F   F8           MOV       R0,A
   \   000040   E4           CLR       A
   \   000041   33           RLC       A
   \   000042   F9           MOV       R1,A
   \   000043   EA           MOV       A,R2
   \   000044   28           ADD       A,R0
   \   000045   F582         MOV       DPL,A
   \   000047   EB           MOV       A,R3
   \   000048   39           ADDC      A,R1
   \   000049   F583         MOV       DPH,A
   \   00004B   A3           INC       DPTR
   \   00004C   E5..         MOV       A,?V0
   \   00004E   F0           MOVX      @DPTR,A
   \   00004F   A3           INC       DPTR
   \   000050   E5..         MOV       A,?V1
   \   000052   F0           MOVX      @DPTR,A
   3606                pBuf += 2;
   \   000053   EE           MOV       A,R6
   \   000054   2402         ADD       A,#0x2
   \   000056   FE           MOV       R6,A
   \   000057   5001         JNC       ??zclParseInReadCmd_3
   \   000059   0F           INC       R7
   3607              }
   \                     ??zclParseInReadCmd_3:
   \   00005A   0C           INC       R4
   \                     ??zclParseInReadCmd_1:
   \   00005B   8A82         MOV       DPL,R2
   \   00005D   8B83         MOV       DPH,R3
   \   00005F   E0           MOVX      A,@DPTR
   \   000060   F8           MOV       R0,A
   \   000061   EC           MOV       A,R4
   \   000062   C3           CLR       C
   \   000063   98           SUBB      A,R0
   \   000064   40C2         JC        ??zclParseInReadCmd_2
   3608            }
   3609          
   3610            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   000066   02....       LJMP      ??Subroutine172_0 & 0xFFFF
   3611          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   8582..       MOV       ?V0,DPL
   \   000008   8583..       MOV       ?V1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   2401         ADD       A,#0x1
   \   00000E   FA           MOV       R2,A
   \   00000F   A3           INC       DPTR
   \   000010   E0           MOVX      A,@DPTR
   \   000011   3400         ADDC      A,#0x0
   \   000013   FB           MOV       R3,A
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   12....       LCALL     ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine151:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   12....       LCALL     ?Subroutine167 & 0xFFFF
   \                     ??CrossCallReturnLabel_375:
   \   00000A   F9           MOV       R1,A
   \   00000B   E8           MOV       A,R0
   \   00000C   FE           MOV       R6,A
   \   00000D   E9           MOV       A,R1
   \   00000E   FF           MOV       R7,A
   \   00000F   22           RET
   3612          
   3613          /*********************************************************************
   3614           * @fn      zclParseInReadRspCmd
   3615           *
   3616           * @brief   Parse the "Profile" Read Response Commands
   3617           *
   3618           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3619           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3620           *
   3621           * @param   pCmd - pointer to incoming data to parse
   3622           *
   3623           * @return  pointer to the parsed command structure
   3624           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   AA..         MOV       R2,?V10
   \   000002   AB..         MOV       R3,?V11
   \   000004                REQUIRE ??Subroutine174_0
   \   000004                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3625          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3626          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V8,R2
   \   000007   8B..         MOV       ?V9,R3
   3627            zclReadRspCmd_t *readRspCmd;
   3628            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV       A,R2
   \   00000A   2403         ADD       A,#0x3
   \   00000C   F5..         MOV       ?V4,A
   \   00000E   E4           CLR       A
   \   00000F   35..         ADDC      A,?V9
   \   000011   F5..         MOV       ?V5,A
   \   000013   85..82       MOV       DPL,?V4
   \   000016   F583         MOV       DPH,A
   \   000018   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   3629            uint8 *dataPtr;
   3630            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_399:
   \   00001B   75..00       MOV       ?V2,#0x0
   3631            uint8 hdrLen;
   3632            uint16 dataLen = 0;
   \   00001E   75..00       MOV       ?V6,#0x0
   \   000021   75..00       MOV       ?V7,#0x0
   \   000024   8049         SJMP      ??zclParseInReadRspCmd_0
   3633            uint16 attrDataLen;
   3634          
   3635            // find out the number of attributes and the length of attribute data
   3636            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3637            {
   3638              uint8 status;
   3639          
   3640              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   000026   05..         INC       ?V2
   3641              pBuf += 2; // move pass attribute id
   3642          
   3643              status = *pBuf++;
   \   000028   8E82         MOV       DPL,R6
   \   00002A   8F83         MOV       DPH,R7
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   F8           MOV       R0,A
   \   000030   EE           MOV       A,R6
   \   000031   2403         ADD       A,#0x3
   \   000033   FE           MOV       R6,A
   \   000034   5001         JNC       ??zclParseInReadRspCmd_2
   \   000036   0F           INC       R7
   3644              if ( status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_2:
   \   000037   E8           MOV       A,R0
   \   000038   7035         JNZ       ??zclParseInReadRspCmd_0
   3645              {
   3646                uint8 dataType = *pBuf++;
   \   00003A   8E82         MOV       DPL,R6
   \   00003C   8F83         MOV       DPH,R7
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   F9           MOV       R1,A
   \   000040   A3           INC       DPTR
   \   000041   AE82         MOV       R6,DPL
   \   000043   AF83         MOV       R7,DPH
   3647          
   3648                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000045                ; Setup parameters for call to function zclGetAttrDataLength
   \   000045   EE           MOV       A,R6
   \   000046   FA           MOV       R2,A
   \   000047   EF           MOV       A,R7
   \   000048   FB           MOV       R3,A
   \   000049   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   00004C   8A..         MOV       ?V0,R2
   \   00004E   8B..         MOV       ?V1,R3
   3649                pBuf += attrDataLen; // move pass attribute data
   \   000050   EE           MOV       A,R6
   \   000051   2A           ADD       A,R2
   \   000052   FE           MOV       R6,A
   \   000053   EF           MOV       A,R7
   \   000054   35..         ADDC      A,?V1
   \   000056   FF           MOV       R7,A
   3650          
   3651                // add padding if needed
   3652                if ( PADDING_NEEDED( attrDataLen ) )
   \   000057   EA           MOV       A,R2
   \   000058   A2E0         MOV       C,0xE0 /* A   */.0
   \   00005A   5007         JNC       ??zclParseInReadRspCmd_3
   3653                {
   3654                  attrDataLen++;
   \   00005C   05..         INC       ?V0
   \   00005E   04           INC       A
   \   00005F   7002         JNZ       ??zclParseInReadRspCmd_3
   \   000061   05..         INC       ?V1
   3655                }
   3656          
   3657                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   000063   E5..         MOV       A,?V6
   \   000065   25..         ADD       A,?V0
   \   000067   F5..         MOV       ?V6,A
   \   000069   E5..         MOV       A,?V7
   \   00006B   35..         ADDC      A,?V1
   \   00006D   F5..         MOV       ?V7,A
   3658              }
   3659            }
   \                     ??zclParseInReadRspCmd_0:
   \   00006F   85..82       MOV       DPL,?V8
   \   000072   85..83       MOV       DPH,?V9
   \   000075   A3           INC       DPTR
   \   000076   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000079   12....       LCALL     ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   00007C   EE           MOV       A,R6
   \   00007D   98           SUBB      A,R0
   \   00007E   EF           MOV       A,R7
   \   00007F   99           SUBB      A,R1
   \   000080   40A4         JC        ??zclParseInReadRspCmd_1
   3660          
   3661            // calculate the length of the response header
   3662            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000082   75F006       MOV       B,#0x6
   \   000085   E5..         MOV       A,?V2
   \   000087   A4           MUL       AB
   \   000088   04           INC       A
   \   000089   F5..         MOV       ?V0,A
   3663          
   3664            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   00008B                ; Setup parameters for call to function osal_mem_alloc
   \   00008B   25..         ADD       A,?V6
   \   00008D   FA           MOV       R2,A
   \   00008E   E4           CLR       A
   \   00008F   35..         ADDC      A,?V7
   \   000091   FB           MOV       R3,A
   \   000092   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000095   8A..         MOV       ?V10,R2
   \   000097   8B..         MOV       ?V11,R3
   3665            if ( readRspCmd != NULL )
   \   000099   EA           MOV       A,R2
   \   00009A   45..         ORL       A,?V11
   \   00009C   7003         JNZ       $+5
   \   00009E   02....       LJMP      ??zclParseInReadRspCmd_4 & 0xFFFF
   3666            {
   3667              uint8 i;
   3668              pBuf = pCmd->pData;
   \   0000A1   12....       LCALL     ?Subroutine66 & 0xFFFF
   3669              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_405:
   \   0000A4   A8..         MOV       R0,?V0
   \   0000A6   EA           MOV       A,R2
   \   0000A7   28           ADD       A,R0
   \   0000A8   F5..         MOV       ?V8,A
   \   0000AA   E4           CLR       A
   \   0000AB   3B           ADDC      A,R3
   \   0000AC   F5..         MOV       ?V9,A
   3670          
   3671              readRspCmd->numAttr = numAttr;
   \   0000AE   8A82         MOV       DPL,R2
   \   0000B0   8B83         MOV       DPH,R3
   \   0000B2   E5..         MOV       A,?V2
   \   0000B4   F0           MOVX      @DPTR,A
   3672              for ( i = 0; i < numAttr; i++ )
   \   0000B5   75..00       MOV       ?V3,#0x0
   \   0000B8   02....       LJMP      ??zclParseInReadRspCmd_5 & 0xFFFF
   3673              {
   3674                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   0000BB   E5..         MOV       A,?V3
   \   0000BD   75F006       MOV       B,#0x6
   \   0000C0   12....       LCALL     ?Subroutine122 & 0xFFFF
   3675          
   3676                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_217:
   \   0000C3   8E82         MOV       DPL,R6
   \   0000C5   8F83         MOV       DPH,R7
   \   0000C7   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   0000CA   12....       LCALL     ?Subroutine27 & 0xFFFF
   3677                pBuf += 2;
   3678          
   3679                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_31:
   \   0000CD   F8           MOV       R0,A
   \   0000CE   85..82       MOV       DPL,?V12
   \   0000D1   85..83       MOV       DPH,?V13
   \   0000D4   A3           INC       DPTR
   \   0000D5   A3           INC       DPTR
   \   0000D6   F0           MOVX      @DPTR,A
   \   0000D7   EE           MOV       A,R6
   \   0000D8   2403         ADD       A,#0x3
   \   0000DA   FE           MOV       R6,A
   \   0000DB   5001         JNC       ??zclParseInReadRspCmd_7
   \   0000DD   0F           INC       R7
   3680                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??zclParseInReadRspCmd_7:
   \   0000DE   E8           MOV       A,R0
   \   0000DF   706A         JNZ       ??zclParseInReadRspCmd_8
   3681                {
   3682                  statusRec->dataType = *pBuf++;
   \   0000E1   8E82         MOV       DPL,R6
   \   0000E3   8F83         MOV       DPH,R7
   \   0000E5   E0           MOVX      A,@DPTR
   \   0000E6   F9           MOV       R1,A
   \   0000E7   85..82       MOV       DPL,?V12
   \   0000EA   85..83       MOV       DPH,?V13
   \   0000ED   A3           INC       DPTR
   \   0000EE   A3           INC       DPTR
   \   0000EF   12....       LCALL     ?Subroutine16 & 0xFFFF
   3683          
   3684                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_384:
   \   0000F2                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000F2   EE           MOV       A,R6
   \   0000F3   FA           MOV       R2,A
   \   0000F4   EF           MOV       A,R7
   \   0000F5   FB           MOV       R3,A
   \   0000F6   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000F9   8A..         MOV       ?V0,R2
   \   0000FB   8B..         MOV       ?V1,R3
   3685                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000FD                ; Setup parameters for call to function osal_memcpy
   \   0000FD   8E..         MOV       ?V4,R6
   \   0000FF   8F..         MOV       ?V5,R7
   \   000101   75..00       MOV       ?V6,#0x0
   \   000104   78..         MOV       R0,#?V4
   \   000106   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000109   AC..         MOV       R4,?V0
   \   00010B   AD..         MOV       R5,?V1
   \   00010D   AA..         MOV       R2,?V8
   \   00010F   AB..         MOV       R3,?V9
   \   000111   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000114   7403         MOV       A,#0x3
   \   000116   12....       LCALL     ?DEALLOC_XSTACK8
   3686                  statusRec->data = dataPtr;
   \   000119   85..82       MOV       DPL,?V12
   \   00011C   85..83       MOV       DPH,?V13
   \   00011F   A3           INC       DPTR
   \   000120   A3           INC       DPTR
   \   000121   A3           INC       DPTR
   \   000122   A3           INC       DPTR
   \   000123   E5..         MOV       A,?V8
   \   000125   F0           MOVX      @DPTR,A
   \   000126   A3           INC       DPTR
   \   000127   E5..         MOV       A,?V9
   \   000129   F0           MOVX      @DPTR,A
   3687          
   3688                  pBuf += attrDataLen; // move pass attribute data
   \   00012A   EE           MOV       A,R6
   \   00012B   25..         ADD       A,?V0
   \   00012D   FE           MOV       R6,A
   \   00012E   EF           MOV       A,R7
   \   00012F   35..         ADDC      A,?V1
   \   000131   FF           MOV       R7,A
   3689          
   3690                  // advance attribute data pointer
   3691                  if ( PADDING_NEEDED( attrDataLen ) )
   \   000132   E5..         MOV       A,?V0
   \   000134   A2E0         MOV       C,0xE0 /* A   */.0
   \   000136   5007         JNC       ??zclParseInReadRspCmd_9
   3692                  {
   3693                    attrDataLen++;
   \   000138   05..         INC       ?V0
   \   00013A   04           INC       A
   \   00013B   7002         JNZ       ??zclParseInReadRspCmd_9
   \   00013D   05..         INC       ?V1
   3694                  }
   3695          
   3696                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_9:
   \   00013F   E5..         MOV       A,?V8
   \   000141   25..         ADD       A,?V0
   \   000143   F5..         MOV       ?V8,A
   \   000145   E5..         MOV       A,?V9
   \   000147   35..         ADDC      A,?V1
   \   000149   F5..         MOV       ?V9,A
   3697                }
   3698              }
   \                     ??zclParseInReadRspCmd_8:
   \   00014B   05..         INC       ?V3
   \                     ??zclParseInReadRspCmd_5:
   \   00014D   E5..         MOV       A,?V3
   \   00014F   C3           CLR       C
   \   000150   95..         SUBB      A,?V2
   \   000152   5003         JNC       $+5
   \   000154   02....       LJMP      ??zclParseInReadRspCmd_6 & 0xFFFF
   3699            }
   3700          
   3701            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   000157   02....       LJMP      ?Subroutine7 & 0xFFFF
   3702          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine185_0
   \   000001                ; // Fall through to label ??Subroutine185_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   A4           MUL       AB
   \   000001   F8           MOV       R0,A
   \   000002   A9F0         MOV       R1,B
   \   000004   E5..         MOV       A,?V10
   \   000006   28           ADD       A,R0
   \   000007   F582         MOV       DPL,A
   \   000009   E5..         MOV       A,?V11
   \   00000B   39           ADDC      A,R1
   \   00000C   F583         MOV       DPH,A
   \   00000E   A3           INC       DPTR
   \   00000F   8582..       MOV       ?V12,DPL
   \   000012   8583..       MOV       ?V13,DPH
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   EA           MOV       A,R2
   \   000006   85..82       MOV       DPL,?V12
   \   000009   85..83       MOV       DPH,?V13
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine158:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   28           ADD       A,R0
   \   000002   F8           MOV       R0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   39           ADDC      A,R1
   \   000006   F9           MOV       R1,A
   \   000007   C3           CLR       C
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   E9           MOV       A,R1
   \   000003   12....       LCALL     ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   E0           MOVX      A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   85..82       MOV       DPL,?V4
   \   000003   85..83       MOV       DPH,?V5
   \   000006                REQUIRE ??Subroutine188_0
   \   000006                ; // Fall through to label ??Subroutine188_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_366:
   \   000003   85..82       MOV       DPL,?V4
   \   000006   85..83       MOV       DPH,?V5
   \   000009   22           RET
   3703          #endif // ZCL_READ
   3704          
   3705          #ifdef ZCL_WRITE
   3706          /*********************************************************************
   3707           * @fn      zclParseInWriteCmd
   3708           *
   3709           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3710           *          Response Commands
   3711           *
   3712           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3713           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3714           *
   3715           * @param   pCmd - pointer to incoming data to parse
   3716           *
   3717           * @return  pointer to the parsed command structure
   3718           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3719          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3720          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV       A,#-0x16
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V8,R2
   \   000007   8B..         MOV       ?V9,R3
   3721            zclWriteCmd_t *writeCmd;
   3722            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV       A,R2
   \   00000A   2403         ADD       A,#0x3
   \   00000C   F5..         MOV       ?V2,A
   \   00000E   E4           CLR       A
   \   00000F   35..         ADDC      A,?V9
   \   000011   F5..         MOV       ?V3,A
   \   000013   85..82       MOV       DPL,?V2
   \   000016   12....       LCALL     ?Subroutine62 & 0xFFFF
   3723            uint16 attrDataLen;
   3724            uint8 *dataPtr;
   3725            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_390:
   \   000019   75..00       MOV       ?V7,#0x0
   3726            uint8 hdrLen;
   3727            uint16 dataLen = 0;
   \   00001C   75..00       MOV       ?V4,#0x0
   \   00001F   75..00       MOV       ?V5,#0x0
   \   000022   8042         SJMP      ??zclParseInWriteCmd_0
   3728          
   3729            // find out the number of attributes and the length of attribute data
   3730            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3731            {
   3732              uint8 dataType;
   3733          
   3734              numAttr++;
   \                     ??zclParseInWriteCmd_1:
   \   000024   05..         INC       ?V7
   3735              pBuf += 2; // move pass attribute id
   3736          
   3737              dataType = *pBuf++;
   \   000026   85..82       MOV       DPL,?V0
   \   000029   85..83       MOV       DPH,?V1
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   F9           MOV       R1,A
   \   000030   E5..         MOV       A,?V0
   \   000032   2403         ADD       A,#0x3
   \   000034   F5..         MOV       ?V0,A
   \   000036   5002         JNC       ??zclParseInWriteCmd_2
   \   000038   05..         INC       ?V1
   3738          
   3739              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??zclParseInWriteCmd_2:
   \   00003A                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003A   FA           MOV       R2,A
   \   00003B   AB..         MOV       R3,?V1
   \   00003D   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000040   8A..         MOV       ?V10,R2
   \   000042   8B..         MOV       ?V11,R3
   \   000044   AE..         MOV       R6,?V10
   \   000046   AF..         MOV       R7,?V11
   3740              pBuf += attrDataLen; // move pass attribute data
   \   000048   E5..         MOV       A,?V0
   \   00004A   2A           ADD       A,R2
   \   00004B   F5..         MOV       ?V0,A
   \   00004D   E5..         MOV       A,?V1
   \   00004F   3F           ADDC      A,R7
   \   000050   F5..         MOV       ?V1,A
   3741          
   3742              // add padding if needed
   3743              if ( PADDING_NEEDED( attrDataLen ) )
   \   000052   EE           MOV       A,R6
   \   000053   A2E0         MOV       C,0xE0 /* A   */.0
   \   000055   5005         JNC       ??zclParseInWriteCmd_3
   3744              {
   3745                attrDataLen++;
   \   000057   0E           INC       R6
   \   000058   04           INC       A
   \   000059   7001         JNZ       ??zclParseInWriteCmd_3
   \   00005B   0F           INC       R7
   3746              }
   3747          
   3748              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_3:
   \   00005C   E5..         MOV       A,?V4
   \   00005E   2E           ADD       A,R6
   \   00005F   F5..         MOV       ?V4,A
   \   000061   E5..         MOV       A,?V5
   \   000063   3F           ADDC      A,R7
   \   000064   F5..         MOV       ?V5,A
   3749            }
   \                     ??zclParseInWriteCmd_0:
   \   000066   85..82       MOV       DPL,?V8
   \   000069   85..83       MOV       DPH,?V9
   \   00006C   A3           INC       DPTR
   \   00006D   12....       LCALL     ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000070   E5..         MOV       A,?V0
   \   000072   98           SUBB      A,R0
   \   000073   E5..         MOV       A,?V1
   \   000075   99           SUBB      A,R1
   \   000076   40AC         JC        ??zclParseInWriteCmd_1
   3750          
   3751            // calculate the length of the response header
   3752            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   000078   75F005       MOV       B,#0x5
   \   00007B   E5..         MOV       A,?V7
   \   00007D   A4           MUL       AB
   \   00007E   04           INC       A
   \   00007F   FE           MOV       R6,A
   3753          
   3754            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000080                ; Setup parameters for call to function osal_mem_alloc
   \   000080   25..         ADD       A,?V4
   \   000082   FA           MOV       R2,A
   \   000083   E4           CLR       A
   \   000084   35..         ADDC      A,?V5
   \   000086   FB           MOV       R3,A
   \   000087   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00008A   8A..         MOV       ?V10,R2
   \   00008C   8B..         MOV       ?V11,R3
   3755            if ( writeCmd != NULL )
   \   00008E   EA           MOV       A,R2
   \   00008F   45..         ORL       A,?V11
   \   000091   7003         JNZ       $+5
   \   000093   02....       LJMP      ??zclParseInWriteCmd_4 & 0xFFFF
   3756            {
   3757              uint8 i;
   3758              pBuf = pCmd->pData;
   \   000096   85..82       MOV       DPL,?V2
   \   000099   85..83       MOV       DPH,?V3
   \   00009C   12....       LCALL     ??Subroutine186_0 & 0xFFFF
   3759              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   \                     ??CrossCallReturnLabel_389:
   \   00009F   EA           MOV       A,R2
   \   0000A0   2E           ADD       A,R6
   \   0000A1   F5..         MOV       ?V2,A
   \   0000A3   E4           CLR       A
   \   0000A4   3B           ADDC      A,R3
   \   0000A5   F5..         MOV       ?V3,A
   3760          
   3761              writeCmd->numAttr = numAttr;
   \   0000A7   8A82         MOV       DPL,R2
   \   0000A9   8B83         MOV       DPH,R3
   \   0000AB   E5..         MOV       A,?V7
   \   0000AD   F0           MOVX      @DPTR,A
   3762              for ( i = 0; i < numAttr; i++ )
   \   0000AE   75..00       MOV       ?V8,#0x0
   \   0000B1   02....       LJMP      ??zclParseInWriteCmd_5 & 0xFFFF
   3763              {
   3764                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_6:
   \   0000B4   E5..         MOV       A,?V8
   \   0000B6   75F005       MOV       B,#0x5
   \   0000B9   12....       LCALL     ?Subroutine122 & 0xFFFF
   3765          
   3766                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_218:
   \   0000BC   85..82       MOV       DPL,?V0
   \   0000BF   85..83       MOV       DPH,?V1
   \   0000C2   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   0000C5   F0           MOVX      @DPTR,A
   \   0000C6   A3           INC       DPTR
   \   0000C7   E9           MOV       A,R1
   \   0000C8   12....       LCALL     ?Subroutine28 & 0xFFFF
   3767                pBuf += 2;
   3768                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_33:
   \   0000CB   F9           MOV       R1,A
   \   0000CC   85..82       MOV       DPL,?V12
   \   0000CF   85..83       MOV       DPH,?V13
   \   0000D2   A3           INC       DPTR
   \   0000D3   A3           INC       DPTR
   \   0000D4   F0           MOVX      @DPTR,A
   \   0000D5   E5..         MOV       A,?V0
   \   0000D7   2403         ADD       A,#0x3
   \   0000D9   F5..         MOV       ?V0,A
   \   0000DB   5002         JNC       ??zclParseInWriteCmd_7
   \   0000DD   05..         INC       ?V1
   3769          
   3770                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??zclParseInWriteCmd_7:
   \   0000DF                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000DF   FA           MOV       R2,A
   \   0000E0   AB..         MOV       R3,?V1
   \   0000E2   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000E5   8A..         MOV       ?V4,R2
   \   0000E7   8B..         MOV       ?V5,R3
   \   0000E9   AE..         MOV       R6,?V4
   \   0000EB   AF..         MOV       R7,?V5
   3771                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000ED                ; Setup parameters for call to function osal_memcpy
   \   0000ED   85....       MOV       ?V4,?V0
   \   0000F0   85....       MOV       ?V5,?V1
   \   0000F3   75..00       MOV       ?V6,#0x0
   \   0000F6   78..         MOV       R0,#?V4
   \   0000F8   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000FB   EE           MOV       A,R6
   \   0000FC   FC           MOV       R4,A
   \   0000FD   EF           MOV       A,R7
   \   0000FE   FD           MOV       R5,A
   \   0000FF   AA..         MOV       R2,?V2
   \   000101   AB..         MOV       R3,?V3
   \   000103   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000106   7403         MOV       A,#0x3
   \   000108   12....       LCALL     ?DEALLOC_XSTACK8
   3772                statusRec->attrData = dataPtr;
   \   00010B   85..82       MOV       DPL,?V12
   \   00010E   85..83       MOV       DPH,?V13
   \   000111   A3           INC       DPTR
   \   000112   A3           INC       DPTR
   \   000113   A3           INC       DPTR
   \   000114   E5..         MOV       A,?V2
   \   000116   F0           MOVX      @DPTR,A
   \   000117   A3           INC       DPTR
   \   000118   E5..         MOV       A,?V3
   \   00011A   F0           MOVX      @DPTR,A
   3773          
   3774                pBuf += attrDataLen; // move pass attribute data
   \   00011B   E5..         MOV       A,?V0
   \   00011D   2E           ADD       A,R6
   \   00011E   F5..         MOV       ?V0,A
   \   000120   E5..         MOV       A,?V1
   \   000122   3F           ADDC      A,R7
   \   000123   F5..         MOV       ?V1,A
   3775          
   3776                // advance attribute data pointer
   3777                if ( PADDING_NEEDED( attrDataLen ) )
   \   000125   EE           MOV       A,R6
   \   000126   A2E0         MOV       C,0xE0 /* A   */.0
   \   000128   5005         JNC       ??zclParseInWriteCmd_8
   3778                {
   3779                  attrDataLen++;
   \   00012A   0E           INC       R6
   \   00012B   04           INC       A
   \   00012C   7001         JNZ       ??zclParseInWriteCmd_8
   \   00012E   0F           INC       R7
   3780                }
   3781          
   3782                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_8:
   \   00012F   E5..         MOV       A,?V2
   \   000131   2E           ADD       A,R6
   \   000132   F5..         MOV       ?V2,A
   \   000134   E5..         MOV       A,?V3
   \   000136   3F           ADDC      A,R7
   \   000137   F5..         MOV       ?V3,A
   3783              }
   \   000139   05..         INC       ?V8
   \                     ??zclParseInWriteCmd_5:
   \   00013B   E5..         MOV       A,?V8
   \   00013D   C3           CLR       C
   \   00013E   95..         SUBB      A,?V7
   \   000140   5003         JNC       $+5
   \   000142   02....       LJMP      ??zclParseInWriteCmd_6 & 0xFFFF
   3784            }
   3785          
   3786            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_4:
   \   000145   02....       LJMP      ?Subroutine7 & 0xFFFF
   3787          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine186_0
   \   000002                ; // Fall through to label ??Subroutine186_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL     ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_477:
   \   000003   12....       LCALL     ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?V0
   \   000004   85..83       MOV       DPH,?V1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL     ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   22           RET
   3788          
   3789          /*********************************************************************
   3790           * @fn      zclParseInWriteRspCmd
   3791           *
   3792           * @brief   Parse the "Profile" Write Response Commands
   3793           *
   3794           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3795           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3796           *
   3797           * @param   pCmd - pointer to incoming data to parse
   3798           *
   3799           * @return  pointer to the parsed command structure
   3800           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3801          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3802          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3803            zclWriteRspCmd_t *writeRspCmd;
   3804            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV       A,R2
   \   000006   2403         ADD       A,#0x3
   \   000008   F5..         MOV       ?V2,A
   \   00000A   E4           CLR       A
   \   00000B   3B           ADDC      A,R3
   \   00000C   F5..         MOV       ?V3,A
   \   00000E   85..82       MOV       DPL,?V2
   \   000011   F583         MOV       DPH,A
   \   000013   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   3805            uint8 i = 0;
   \                     ??CrossCallReturnLabel_400:
   \   000016   75..00       MOV       ?V4,#0x0
   3806          
   3807            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   000019   12....       LCALL     ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   00001C   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   3808            if ( writeRspCmd != NULL )
   \   00001F   EA           MOV       A,R2
   \   000020   4B           ORL       A,R3
   \   000021   6058         JZ        ??zclParseInWriteRspCmd_0
   3809            {
   3810              if ( pCmd->dataLen == 1 )
   \   000023   85..82       MOV       DPL,?V0
   \   000026   85..83       MOV       DPH,?V1
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   6401         XRL       A,#0x1
   \   00002C   7002         JNZ       ??zclParseInWriteRspCmd_1
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   000030   7033         JNZ       ??zclParseInWriteRspCmd_2
   3811              {
   3812                // special case when all writes were successfull
   3813                writeRspCmd->attrList[i++].status = *pBuf;
   \   000032   8E82         MOV       DPL,R6
   \   000034   8F83         MOV       DPH,R7
   \   000036   12....       LCALL     ?Subroutine95 & 0xFFFF
   3814              }
   \                     ??CrossCallReturnLabel_164:
   \   000039   F0           MOVX      @DPTR,A
   \   00003A   75..01       MOV       ?V4,#0x1
   \   00003D   8035         SJMP      ??zclParseInWriteRspCmd_3
   3815              else
   3816              {
   3817                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3818                {
   3819                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   00003F   E5..         MOV       A,?V4
   \   000041   12....       LCALL     ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000044   12....       LCALL     ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000047   12....       LCALL     ?Subroutine16 & 0xFFFF
   3820                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_385:
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   F5..         MOV       ?V6,A
   \   00004D   A3           INC       DPTR
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   FD           MOV       R5,A
   \   000050   E5..         MOV       A,?V6
   \   000052   8882         MOV       DPL,R0
   \   000054   8983         MOV       DPH,R1
   \   000056   A3           INC       DPTR
   \   000057   A3           INC       DPTR
   \   000058   F0           MOVX      @DPTR,A
   \   000059   A3           INC       DPTR
   \   00005A   ED           MOV       A,R5
   \   00005B   F0           MOVX      @DPTR,A
   \   00005C   05..         INC       ?V4
   3821                  pBuf += 2;
   \   00005E   EE           MOV       A,R6
   \   00005F   2402         ADD       A,#0x2
   \   000061   FE           MOV       R6,A
   \   000062   5001         JNC       ??zclParseInWriteRspCmd_2
   \   000064   0F           INC       R7
   3822                }
   \                     ??zclParseInWriteRspCmd_2:
   \   000065   85..82       MOV       DPL,?V0
   \   000068   85..83       MOV       DPH,?V1
   \   00006B   12....       LCALL     ?Subroutine56 & 0xFFFF
   3823              }
   \                     ??CrossCallReturnLabel_76:
   \   00006E   EE           MOV       A,R6
   \   00006F   98           SUBB      A,R0
   \   000070   EF           MOV       A,R7
   \   000071   99           SUBB      A,R1
   \   000072   40CB         JC        ??zclParseInWriteRspCmd_4
   3824          
   3825              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000074   8A82         MOV       DPL,R2
   \   000076   8B83         MOV       DPH,R3
   \   000078   E5..         MOV       A,?V4
   \   00007A   F0           MOVX      @DPTR,A
   3826            }
   3827          
   3828            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   00007B   02....       LJMP      ??Subroutine180_0 & 0xFFFF
   3829          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   75F003       MOV       B,#0x3
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007   EA           MOV       A,R2
   \   000008   28           ADD       A,R0
   \   000009   F8           MOV       R0,A
   \   00000A   EB           MOV       A,R3
   \   00000B   39           ADDC      A,R1
   \   00000C   F9           MOV       R1,A
   \   00000D   8E82         MOV       DPL,R6
   \   00000F   8F83         MOV       DPH,R7
   \   000011   22           RET
   3830          #endif // ZCL_WRITE
   3831          
   3832          #ifdef ZCL_REPORTING_DEVICE
   3833          /*********************************************************************
   3834           * @fn      zclParseInConfigReportCmd
   3835           *
   3836           * @brief   Parse the "Profile" Configure Reporting Command
   3837           *
   3838           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3839           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3840           *
   3841           * @param   pCmd - pointer to incoming data to parse
   3842           *
   3843           * @return  pointer to the parsed command structure
   3844           */
   3845          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   3846          {
   3847            zclCfgReportCmd_t *cfgReportCmd;
   3848            uint8 *pBuf = pCmd->pData;
   3849            uint8 *dataPtr;
   3850            uint8 numAttr = 0;
   3851            uint8 dataType;
   3852            uint8 hdrLen;
   3853            uint16 dataLen = 0;
   3854            uint8 reportChangeLen; // length of Reportable Change field
   3855          
   3856            // Calculate the length of the Request command
   3857            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3858            {
   3859              uint8 direction;
   3860          
   3861              numAttr++;
   3862              direction = *pBuf++;
   3863              pBuf += 2; // move pass the attribute ID
   3864          
   3865              // Is there a Reportable Change field?
   3866              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3867              {
   3868                dataType = *pBuf++;
   3869                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3870          
   3871                // For attributes of 'discrete' data types this field is omitted
   3872                if ( zclAnalogDataType( dataType ) )
   3873                {
   3874                  reportChangeLen = zclGetDataTypeLength( dataType );
   3875                  pBuf += reportChangeLen;
   3876          
   3877                  // add padding if needed
   3878                  if ( PADDING_NEEDED( reportChangeLen ) )
   3879                  {
   3880                    reportChangeLen++;
   3881                  }
   3882          
   3883                  dataLen += reportChangeLen;
   3884                }
   3885                else
   3886                {
   3887                  pBuf++; // move past reportable change field
   3888                }
   3889              }
   3890              else
   3891              {
   3892                pBuf += 2; // move pass the Timeout Period
   3893              }
   3894            } // while loop
   3895          
   3896            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   3897          
   3898            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   3899            if ( cfgReportCmd != NULL )
   3900            {
   3901              uint8 i;
   3902              pBuf = pCmd->pData;
   3903              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   3904          
   3905              cfgReportCmd->numAttr = numAttr;
   3906              for ( i = 0; i < numAttr; i++ )
   3907              {
   3908                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3909          
   3910                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3911          
   3912                reportRec->direction = *pBuf++;
   3913                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3914                pBuf += 2;
   3915                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3916                {
   3917                  // Attribute to be reported
   3918                  reportRec->dataType = *pBuf++;
   3919                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3920                  pBuf += 2;
   3921                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3922                  pBuf += 2;
   3923          
   3924                  // For attributes of 'discrete' data types this field is omitted
   3925                  if ( zclAnalogDataType( reportRec->dataType ) )
   3926                  {
   3927                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3928                    reportRec->reportableChange = dataPtr;
   3929          
   3930                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3931                    pBuf += reportChangeLen;
   3932          
   3933                    // advance attribute data pointer
   3934                    if ( PADDING_NEEDED( reportChangeLen ) )
   3935                    {
   3936                      reportChangeLen++;
   3937                    }
   3938          
   3939                    dataPtr += reportChangeLen;
   3940                  }
   3941                }
   3942                else
   3943                {
   3944                  // Attribute reports to be received
   3945                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3946                  pBuf += 2;
   3947                }
   3948              } // while loop
   3949            }
   3950          
   3951            return ( (void *)cfgReportCmd );
   3952          }
   3953          #endif
   3954          
   3955          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   3956          /*********************************************************************
   3957           * @fn      zclParseInConfigReportRspCmd
   3958           *
   3959           * @brief   Parse the "Profile" Configure Reporting Response Command
   3960           *
   3961           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3962           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3963           *
   3964           * @param   pCmd - pointer to incoming data to parse
   3965           *
   3966           * @return  pointer to the parsed command structure
   3967           */
   3968          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   3969          {
   3970            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3971            uint8 *pBuf = pCmd->pData;
   3972            uint8 numAttr;
   3973          
   3974            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   3975          
   3976            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3977                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   3978            if ( cfgReportRspCmd != NULL )
   3979            {
   3980              uint8 i;
   3981              cfgReportRspCmd->numAttr = numAttr;
   3982              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   3983              {
   3984                cfgReportRspCmd->attrList[i].status = *pBuf++;
   3985                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3986                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3987                pBuf += 2;
   3988              }
   3989            }
   3990          
   3991            return ( (void *)cfgReportRspCmd );
   3992          }
   3993          #endif
   3994          
   3995          #ifdef ZCL_REPORTING_DEVICE
   3996          /*********************************************************************
   3997           * @fn      zclParseInReadReportCfgCmd
   3998           *
   3999           * @brief   Parse the "Profile" Read Reporting Configuration Command
   4000           *
   4001           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4002           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4003           *
   4004           * @param   pCmd - pointer to incoming data to parse
   4005           *
   4006           * @return  pointer to the parsed command structure
   4007           */
   4008          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   4009          {
   4010            zclReadReportCfgCmd_t *readReportCfgCmd;
   4011            uint8 *pBuf = pCmd->pData;
   4012            uint8 numAttr;
   4013          
   4014            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   4015          
   4016            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   4017                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   4018            if ( readReportCfgCmd != NULL )
   4019            {
   4020              uint8 i;
   4021              readReportCfgCmd->numAttr = numAttr;
   4022              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   4023              {
   4024                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   4025                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4026                pBuf += 2;
   4027              }
   4028            }
   4029          
   4030            return ( (void *)readReportCfgCmd );
   4031          }
   4032          #endif
   4033          
   4034          #ifdef ZCL_REPORT_CONFIGURING_DEVICE
   4035          /*********************************************************************
   4036           * @fn      zclParseInReadReportCfgRspCmd
   4037           *
   4038           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   4039           *
   4040           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4041           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4042           *
   4043           * @param   pCmd - pointer to incoming data to parse
   4044           *
   4045           * @return  pointer to the parsed command structure
   4046           */
   4047          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   4048          {
   4049            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   4050            uint8 reportChangeLen;
   4051            uint8 *pBuf = pCmd->pData;
   4052            uint8 *dataPtr;
   4053            uint8 numAttr = 0;
   4054            uint8 hdrLen;
   4055            uint16 dataLen = 0;
   4056          
   4057            // Calculate the length of the response command
   4058            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4059            {
   4060              uint8 status;
   4061              uint8 direction;
   4062          
   4063              numAttr++;
   4064              status = *pBuf++;
   4065              direction = *pBuf++;
   4066              pBuf += 2; // move pass the attribute ID
   4067          
   4068              if ( status == ZCL_STATUS_SUCCESS )
   4069              {
   4070                if ( direction == ZCL_SEND_ATTR_REPORTS )
   4071                {
   4072                  uint8 dataType = *pBuf++;
   4073                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   4074          
   4075                  // For attributes of 'discrete' data types this field is omitted
   4076                  if ( zclAnalogDataType( dataType ) )
   4077                  {
   4078                    reportChangeLen = zclGetDataTypeLength( dataType );
   4079                    pBuf += reportChangeLen;
   4080          
   4081                    // add padding if needed
   4082                    if ( PADDING_NEEDED( reportChangeLen ) )
   4083                    {
   4084                      reportChangeLen++;
   4085                    }
   4086          
   4087                    dataLen += reportChangeLen;
   4088                  }
   4089                }
   4090                else
   4091                {
   4092                  pBuf += 2; // move pass the Timeout field
   4093                }
   4094              }
   4095            } // while loop
   4096          
   4097            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   4098          
   4099            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   4100            if ( readReportCfgRspCmd != NULL )
   4101            {
   4102              uint8 i;
   4103              pBuf = pCmd->pData;
   4104              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   4105          
   4106              readReportCfgRspCmd->numAttr = numAttr;
   4107              for ( i = 0; i < numAttr; i++ )
   4108              {
   4109                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   4110          
   4111                reportRspRec->status = *pBuf++;
   4112                reportRspRec->direction = *pBuf++;
   4113                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4114                pBuf += 2;
   4115          
   4116                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   4117                {
   4118                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   4119                  {
   4120                    reportRspRec->dataType = *pBuf++;
   4121                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   4122                    pBuf += 2;
   4123                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   4124                    pBuf += 2;
   4125          
   4126                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   4127                    {
   4128                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   4129                      reportRspRec->reportableChange = dataPtr;
   4130          
   4131                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   4132                      pBuf += reportChangeLen;
   4133          
   4134                      // advance attribute data pointer
   4135                      if ( PADDING_NEEDED( reportChangeLen ) )
   4136                      {
   4137                        reportChangeLen++;
   4138                      }
   4139          
   4140                      dataPtr += reportChangeLen;
   4141                    }
   4142                  }
   4143                  else
   4144                  {
   4145                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   4146                    pBuf += 2;
   4147                  }
   4148                }
   4149              }
   4150            }
   4151          
   4152            return ( (void *)readReportCfgRspCmd );
   4153          }
   4154          #endif
   4155          
   4156          #ifdef ZCL_REPORT_DESTINATION_DEVICE
   4157          /*********************************************************************
   4158           * @fn      zclParseInReportCmd
   4159           *
   4160           * @brief   Parse the "Profile" Report Command
   4161           *
   4162           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4163           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4164           *
   4165           * @param   pCmd - pointer to incoming data to parse
   4166           *
   4167           * @return  pointer to the parsed command structure
   4168           */
   4169          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   4170          {
   4171            zclReportCmd_t *reportCmd;
   4172            uint8 *pBuf = pCmd->pData;
   4173            uint16 attrDataLen;
   4174            uint8 *dataPtr;
   4175            uint8 numAttr = 0;
   4176            uint8 hdrLen;
   4177            uint16 dataLen = 0;
   4178          
   4179            // find out the number of attributes and the length of attribute data
   4180            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   4181            {
   4182              uint8 dataType;
   4183          
   4184              numAttr++;
   4185              pBuf += 2; // move pass attribute id
   4186          
   4187              dataType = *pBuf++;
   4188          
   4189              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   4190              pBuf += attrDataLen; // move pass attribute data
   4191          
   4192              // add padding if needed
   4193              if ( PADDING_NEEDED( attrDataLen ) )
   4194              {
   4195                attrDataLen++;
   4196              }
   4197          
   4198              dataLen += attrDataLen;
   4199            }
   4200          
   4201            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   4202          
   4203            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   4204            if (reportCmd != NULL )
   4205            {
   4206              uint8 i;
   4207              pBuf = pCmd->pData;
   4208              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   4209          
   4210              reportCmd->numAttr = numAttr;
   4211              for ( i = 0; i < numAttr; i++ )
   4212              {
   4213                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   4214          
   4215                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4216                pBuf += 2;
   4217                reportRec->dataType = *pBuf++;
   4218          
   4219                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   4220                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   4221                reportRec->attrData = dataPtr;
   4222          
   4223                pBuf += attrDataLen; // move pass attribute data
   4224          
   4225                // advance attribute data pointer
   4226                if ( PADDING_NEEDED( attrDataLen ) )
   4227                {
   4228                  attrDataLen++;
   4229                }
   4230          
   4231                dataPtr += attrDataLen;
   4232              }
   4233            }
   4234          
   4235            return ( (void *)reportCmd );
   4236          }
   4237          #endif
   4238          
   4239          /*********************************************************************
   4240           * @fn      zclParseInDefaultRspCmd
   4241           *
   4242           * @brief   Parse the "Profile" Default Response Command
   4243           *
   4244           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4245           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4246           *
   4247           * @param   pCmd - pointer to incoming data to parse
   4248           *
   4249           * @return  pointer to the parsed command structure
   4250           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine145:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine187_0
   \   000004                ; // Fall through to label ??Subroutine187_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4251          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   4252          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4253            zclDefaultRspCmd_t *defaultRspCmd;
   4254            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL     ?Subroutine68 & 0xFFFF
   4255          
   4256            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_108:
   \   000008   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4257            if ( defaultRspCmd != NULL )
   \   00000B   EA           MOV       A,R2
   \   00000C   4B           ORL       A,R3
   \   00000D   6003         JZ        ??CrossCallReturnLabel_15
   4258            {
   4259              defaultRspCmd->commandID = *pBuf++;
   \   00000F   12....       LCALL     ?Subroutine21 & 0xFFFF
   4260              defaultRspCmd->statusCode = *pBuf;
   4261            }
   4262          
   4263            return ( (void *)defaultRspCmd );
   \                     ??CrossCallReturnLabel_15:
   \   000012   02....       LJMP      ?Subroutine2 & 0xFFFF
   4264          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL     ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003                ; Setup parameters for call to function osal_mem_alloc
   \   000003                ; Setup parameters for call to function osal_mem_alloc
   \   000003   7A02         MOV       R2,#0x2
   \   000005   7B00         MOV       R3,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL     ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_397:
   \   000003   12....       LCALL     ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000006   A3           INC       DPTR
   \   000007   12....       LCALL     ??Subroutine187_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_392:
   \   00000A   A3           INC       DPTR
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   22           RET
   4265          
   4266          #ifdef ZCL_DISCOVER
   4267          /*********************************************************************
   4268           * @fn      zclParseInDiscAttrsCmd
   4269           *
   4270           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   4271           *
   4272           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4273           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4274           *
   4275           * @param   pCmd - pointer to incoming data to parse
   4276           *
   4277           * @return  pointer to the parsed command structure
   4278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4279          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscAttrsCmd:
   4280          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4281            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4282            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL     ?Subroutine85 & 0xFFFF
   4283          
   4284            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   \                     ??CrossCallReturnLabel_141:
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A03         MOV       R2,#0x3
   \   00000A   7B00         MOV       R3,#0x0
   \   00000C   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4285            if ( pDiscoverCmd != NULL )
   \   00000F   EA           MOV       A,R2
   \   000010   4B           ORL       A,R3
   \   000011   6017         JZ        ??zclParseInDiscAttrsCmd_0
   4286            {
   4287              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   000013   8E82         MOV       DPL,R6
   \   000015   8F83         MOV       DPH,R7
   \   000017   12....       LCALL     ?Subroutine155 & 0xFFFF
   4288              pBuf += 2;
   4289              pDiscoverCmd->maxAttrIDs = *pBuf;
   4290            }
   \                     ??CrossCallReturnLabel_274:
   \   00001A   F9           MOV       R1,A
   \   00001B   EC           MOV       A,R4
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   8B83         MOV       DPH,R3
   \   000020   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000023   8A82         MOV       DPL,R2
   \   000025   8B83         MOV       DPH,R3
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   F0           MOVX      @DPTR,A
   4291          
   4292            return ( (void *)pDiscoverCmd );
   \                     ??zclParseInDiscAttrsCmd_0:
   \   00002A   02....       LJMP      ?Subroutine2 & 0xFFFF
   4293          }
   4294          
   4295          /*********************************************************************
   4296           * @fn      zclParseInDiscAttrsRspCmd
   4297           *
   4298           * @brief   Parse the "Profile" Discovery Response Commands
   4299           *
   4300           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4301           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4302           *
   4303           * @param   pCmd - pointer to incoming data to parse
   4304           *
   4305           * @return  pointer to the parsed command structure
   4306           */
   4307          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4308          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscAttrsRspCmd:
   4309          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4310            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   4311            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL     ?Subroutine65 & 0xFFFF
   4312            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   \                     ??CrossCallReturnLabel_104:
   \   000008   F8           MOV       R0,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   34FF         ADDC      A,#-0x1
   \   00000D   F9           MOV       R1,A
   \   00000E   7A03         MOV       R2,#0x3
   \   000010   7B00         MOV       R3,#0x0
   \   000012   12....       LCALL     ?US_DIV_MOD
   \   000015   E8           MOV       A,R0
   \   000016   F5..         MOV       ?V1,A
   4313          
   4314            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   4315                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   \   000018                ; Setup parameters for call to function osal_mem_alloc
   \   000018   12....       LCALL     ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_412:
   \   00001B   39           ADDC      A,R1
   \   00001C   FB           MOV       R3,A
   \   00001D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4316          
   4317            if ( pDiscoverRspCmd != NULL )
   \   000020   EA           MOV       A,R2
   \   000021   4B           ORL       A,R3
   \   000022   6034         JZ        ??zclParseInDiscAttrsRspCmd_0
   4318            {
   4319              uint8 i;
   4320          
   4321              pDiscoverRspCmd->discComplete = *pBuf++;
   \   000024   12....       LCALL     ?Subroutine14 & 0xFFFF
   4322              pDiscoverRspCmd->numAttr = numAttr;
   \                     ??CrossCallReturnLabel_4:
   \   000027   E5..         MOV       A,?V1
   \   000029   F0           MOVX      @DPTR,A
   4323          
   4324              for ( i = 0; i < numAttr; i++ )
   \   00002A   75..00       MOV       ?V0,#0x0
   \   00002D   8022         SJMP      ??zclParseInDiscAttrsRspCmd_1
   4325              {
   4326                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInDiscAttrsRspCmd_2:
   \   00002F   E5..         MOV       A,?V0
   \   000031   12....       LCALL     ?Subroutine126 & 0xFFFF
   4327                pBuf += 2;
   4328                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   4329              }
   \                     ??CrossCallReturnLabel_226:
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F5..         MOV       ?V2,A
   \   000037   A3           INC       DPTR
   \   000038   E0           MOVX      A,@DPTR
   \   000039   FD           MOV       R5,A
   \   00003A   E5..         MOV       A,?V2
   \   00003C   8882         MOV       DPL,R0
   \   00003E   8983         MOV       DPH,R1
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   F0           MOVX      @DPTR,A
   \   000043   A3           INC       DPTR
   \   000044   ED           MOV       A,R5
   \   000045   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000048   EE           MOV       A,R6
   \   000049   2403         ADD       A,#0x3
   \   00004B   FE           MOV       R6,A
   \   00004C   5001         JNC       ??zclParseInDiscAttrsRspCmd_3
   \   00004E   0F           INC       R7
   \                     ??zclParseInDiscAttrsRspCmd_3:
   \   00004F   05..         INC       ?V0
   \                     ??zclParseInDiscAttrsRspCmd_1:
   \   000051   E5..         MOV       A,?V0
   \   000053   C3           CLR       C
   \   000054   95..         SUBB      A,?V1
   \   000056   40D7         JC        ??zclParseInDiscAttrsRspCmd_2
   4330            }
   4331          
   4332            return ( (void *)pDiscoverRspCmd );
   \                     ??zclParseInDiscAttrsRspCmd_0:
   \   000058   02....       LJMP      ??Subroutine172_0 & 0xFFFF
   4333          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL     ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_396:
   \   000003   12....       LCALL     ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   000006   8A82         MOV       DPL,R2
   \   000008   8B83         MOV       DPH,R3
   \   00000A   A3           INC       DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   75F003       MOV       B,#0x3
   \   000003   A4           MUL       AB
   \   000004   A9F0         MOV       R1,B
   \   000006                REQUIRE ??Subroutine189_0
   \   000006                ; // Fall through to label ??Subroutine189_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   E0           MOVX      A,@DPTR
   \   000008   FE           MOV       R6,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   FF           MOV       R7,A
   \   00000C   8A82         MOV       DPL,R2
   \   00000E   8B83         MOV       DPH,R3
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   24FF         ADD       A,#-0x1
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL     ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000003   8882         MOV       DPL,R0
   \   000005   8983         MOV       DPH,R1
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   22           RET
   4334          
   4335          /*********************************************************************
   4336           * @fn      zclParseInDiscCmdsCmd
   4337           *
   4338           * @brief   Parse the "Profile" Discovery Commands
   4339           *
   4340           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4341           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4342           *
   4343           * @param   pCmd - pointer to incoming data to parse
   4344           *
   4345           * @return  pointer to the parsed command structure
   4346           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4347          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscCmdsCmd:
   4348          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4349            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4350            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL     ?Subroutine68 & 0xFFFF
   4351          
   4352            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   \                     ??CrossCallReturnLabel_109:
   \   000008   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4353            if ( pDiscoverCmd != NULL )
   \   00000B   EA           MOV       A,R2
   \   00000C   4B           ORL       A,R3
   \   00000D   6003         JZ        ??CrossCallReturnLabel_16
   4354            {
   4355              pDiscoverCmd->startCmdID = *pBuf++;
   \   00000F   12....       LCALL     ?Subroutine21 & 0xFFFF
   4356              pDiscoverCmd->maxCmdID = *pBuf++;
   4357            }
   4358          
   4359            return ( (void *)pDiscoverCmd );
   \                     ??CrossCallReturnLabel_16:
   \   000012   02....       LJMP      ?Subroutine2 & 0xFFFF
   4360          }
   4361          
   4362          /*********************************************************************
   4363           * @fn      zclParseInDiscCmdsRspCmd
   4364           *
   4365           * @brief   Parse the Discover Commands Response Command
   4366           *
   4367           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4368           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4369           *
   4370           * @param   pCmd - pointer to incoming data to parse
   4371           *
   4372           * @return  pointer to the parsed command structure
   4373           */
   4374          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4375          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscCmdsRspCmd:
   4376          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4377            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4378            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   4379            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   \                     ??CrossCallReturnLabel_401:
   \   00000F   8A82         MOV       DPL,R2
   \   000011   8B83         MOV       DPH,R3
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   14           DEC       A
   \   000016   F5..         MOV       ?V0,A
   4380          
   4381              // allocate memory for size of structure plus variable array
   4382            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4383                              ( numCmds * sizeof(uint8) ) );
   \   000018                ; Setup parameters for call to function osal_mem_alloc
   \   000018   2405         ADD       A,#0x5
   \   00001A   FA           MOV       R2,A
   \   00001B   E4           CLR       A
   \   00001C   3400         ADDC      A,#0x0
   \   00001E   FB           MOV       R3,A
   \   00001F   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4384            if ( pDiscoverRspCmd != NULL )
   \   000022   EA           MOV       A,R2
   \   000023   4B           ORL       A,R3
   \   000024   6032         JZ        ??zclParseInDiscCmdsRspCmd_0
   4385            {
   4386              uint8 i;
   4387              pDiscoverRspCmd->discComplete = *pBuf++;
   \   000026   12....       LCALL     ?Subroutine14 & 0xFFFF
   4388              pDiscoverRspCmd->numCmd = numCmds;
   \                     ??CrossCallReturnLabel_5:
   \   000029   A3           INC       DPTR
   \   00002A   E5..         MOV       A,?V0
   \   00002C   F0           MOVX      @DPTR,A
   4389          
   4390              for ( i = 0; i < numCmds; i++ )
   \   00002D   7800         MOV       R0,#0x0
   \   00002F   8021         SJMP      ??zclParseInDiscCmdsRspCmd_1
   4391              {
   4392                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   \                     ??zclParseInDiscCmdsRspCmd_2:
   \   000031   8E82         MOV       DPL,R6
   \   000033   8F83         MOV       DPH,R7
   \   000035   E0           MOVX      A,@DPTR
   \   000036   C0E0         PUSH      A
   \   000038   E8           MOV       A,R0
   \   000039   FC           MOV       R4,A
   \   00003A   8A82         MOV       DPL,R2
   \   00003C   8B83         MOV       DPH,R3
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   2C           ADD       A,R4
   \   000043   F9           MOV       R1,A
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   3400         ADDC      A,#0x0
   \   000048   8982         MOV       DPL,R1
   \   00004A   F583         MOV       DPH,A
   \   00004C   D0E0         POP       A
   \   00004E   12....       LCALL     ??Subroutine185_0 & 0xFFFF
   4393              }
   \                     ??CrossCallReturnLabel_383:
   \   000051   08           INC       R0
   \                     ??zclParseInDiscCmdsRspCmd_1:
   \   000052   E8           MOV       A,R0
   \   000053   C3           CLR       C
   \   000054   95..         SUBB      A,?V0
   \   000056   40D9         JC        ??zclParseInDiscCmdsRspCmd_2
   4394            }
   4395          
   4396            return ( (void *)pDiscoverRspCmd );
   \                     ??zclParseInDiscCmdsRspCmd_0:
   \   000058   02....       LJMP      ??Subroutine172_0 & 0xFFFF
   4397          }
   4398          
   4399          /*********************************************************************
   4400           * @fn      zclParseInDiscAttrsExtRspCmd
   4401           *
   4402           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4403           *
   4404           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4405           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4406           *
   4407           * @param   pCmd - pointer to incoming data to parse
   4408           *
   4409           * @return  pointer to the parsed command structure
   4410           */
   4411          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4412          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDiscAttrsExtRspCmd:
   4413          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   4414            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4415            uint8 i;
   4416            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL     ?Subroutine65 & 0xFFFF
   4417            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   \                     ??CrossCallReturnLabel_105:
   \   000008   F5..         MOV       ?V0,A
   \   00000A   A3           INC       DPTR
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   34FF         ADDC      A,#-0x1
   \   00000E   F5..         MOV       ?V1,A
   \   000010   7402         MOV       A,#0x2
   \   000012   78..         MOV       R0,#?V0
   \   000014   12....       LCALL     ?US_SHR
   \   000017   E5..         MOV       A,?V0
   \   000019   F5..         MOV       ?V0,A
   4418          
   4419            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4420                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   \   00001B                ; Setup parameters for call to function osal_mem_alloc
   \   00001B   F5..         MOV       ?V2,A
   \   00001D   75..00       MOV       ?V3,#0x0
   \   000020   7402         MOV       A,#0x2
   \   000022   78..         MOV       R0,#?V2
   \   000024   12....       LCALL     ?S_SHL
   \   000027   E5..         MOV       A,?V2
   \   000029   12....       LCALL     ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   00002C   35..         ADDC      A,?V3
   \   00002E   FB           MOV       R3,A
   \   00002F   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   4421          
   4422            if ( pDiscoverRspCmd != NULL )
   \   000032   EA           MOV       A,R2
   \   000033   4B           ORL       A,R3
   \   000034   6053         JZ        ??zclParseInDiscAttrsExtRspCmd_0
   4423            {
   4424              pDiscoverRspCmd->discComplete = *pBuf++;
   \   000036   12....       LCALL     ?Subroutine14 & 0xFFFF
   4425              pDiscoverRspCmd->numAttr = numAttrs;
   \                     ??CrossCallReturnLabel_6:
   \   000039   E5..         MOV       A,?V0
   \   00003B   F0           MOVX      @DPTR,A
   4426          
   4427              for ( i = 0; i < numAttrs; i++ )
   \   00003C   7C00         MOV       R4,#0x0
   \   00003E   8043         SJMP      ??zclParseInDiscAttrsExtRspCmd_1
   4428              {
   4429                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInDiscAttrsExtRspCmd_2:
   \   000040   EC           MOV       A,R4
   \   000041   F5..         MOV       ?V2,A
   \   000043   75..00       MOV       ?V3,#0x0
   \   000046   7402         MOV       A,#0x2
   \   000048   78..         MOV       R0,#?V2
   \   00004A   12....       LCALL     ?S_SHL
   \   00004D   EA           MOV       A,R2
   \   00004E   25..         ADD       A,?V2
   \   000050   F8           MOV       R0,A
   \   000051   EB           MOV       A,R3
   \   000052   35..         ADDC      A,?V3
   \   000054   F9           MOV       R1,A
   \   000055   8E82         MOV       DPL,R6
   \   000057   8F83         MOV       DPH,R7
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   F5..         MOV       ?V4,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   F5..         MOV       ?V3,A
   \   000060   E5..         MOV       A,?V4
   \   000062   8882         MOV       DPL,R0
   \   000064   8983         MOV       DPH,R1
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   F0           MOVX      @DPTR,A
   \   000069   A3           INC       DPTR
   \   00006A   E5..         MOV       A,?V3
   \   00006C   12....       LCALL     ?Subroutine19 & 0xFFFF
   4430                pBuf += 2;
   4431                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4432                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   \                     ??CrossCallReturnLabel_12:
   \   00006F   8E82         MOV       DPL,R6
   \   000071   8F83         MOV       DPH,R7
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   12....       LCALL     ?Subroutine92 & 0xFFFF
   4433              }
   \                     ??CrossCallReturnLabel_152:
   \   000079   A3           INC       DPTR
   \   00007A   F0           MOVX      @DPTR,A
   \   00007B   EE           MOV       A,R6
   \   00007C   2404         ADD       A,#0x4
   \   00007E   FE           MOV       R6,A
   \   00007F   5001         JNC       ??zclParseInDiscAttrsExtRspCmd_3
   \   000081   0F           INC       R7
   \                     ??zclParseInDiscAttrsExtRspCmd_3:
   \   000082   0C           INC       R4
   \                     ??zclParseInDiscAttrsExtRspCmd_1:
   \   000083   EC           MOV       A,R4
   \   000084   C3           CLR       C
   \   000085   95..         SUBB      A,?V0
   \   000087   40B7         JC        ??zclParseInDiscAttrsExtRspCmd_2
   4434            }
   4435          
   4436            return ( (void *)pDiscoverRspCmd );
   \                     ??zclParseInDiscAttrsExtRspCmd_0:
   \   000089   02....       LJMP      ?Subroutine4 & 0xFFFF
   4437          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   12....       LCALL     ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   22           RET
   4438          #endif // ZCL_DISCOVER
   4439          
   4440          #ifdef ZCL_READ
   4441          /*********************************************************************
   4442           * @fn      zclProcessInReadCmd
   4443           *
   4444           * @brief   Process the "Profile" Read Command
   4445           *
   4446           * @param   pInMsg - incoming message to process
   4447           *
   4448           * @return  TRUE if command processed. FALSE, otherwise.
   4449           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4450          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4451          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine120 & 0xFFFF
   4452            zclReadCmd_t *readCmd;
   4453            zclReadRspCmd_t *readRspCmd;
   4454            zclAttrRec_t attrRec;
   4455            uint16 len;
   4456            uint8 i;
   4457            uint8 attrFound;
   4458          
   4459            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_213:
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   F5..         MOV       ?V10,A
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F5..         MOV       ?V11,A
   4460          
   4461            // calculate the length of the response status record
   4462            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4463          
   4464            readRspCmd = zcl_mem_alloc( len );
   \   000014                ; Setup parameters for call to function osal_mem_alloc
   \   000014   85..82       MOV       DPL,?V10
   \   000017   F583         MOV       DPH,A
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   75F006       MOV       B,#0x6
   \   00001D   A4           MUL       AB
   \   00001E   A9F0         MOV       R1,B
   \   000020   2401         ADD       A,#0x1
   \   000022   FA           MOV       R2,A
   \   000023   E4           CLR       A
   \   000024   39           ADDC      A,R1
   \   000025   FB           MOV       R3,A
   \   000026   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000029   8A..         MOV       ?V0,R2
   \   00002B   8B..         MOV       ?V1,R3
   4465            if ( readRspCmd == NULL )
   \   00002D   EA           MOV       A,R2
   \   00002E   45..         ORL       A,?V1
   \   000030   7005         JNZ       ??zclProcessInReadCmd_0
   4466            {
   4467              return FALSE; // EMBEDDED RETURN
   \   000032   7900         MOV       R1,#0x0
   \   000034   02....       LJMP      ??zclProcessInReadCmd_1 & 0xFFFF
   4468            }
   4469          
   4470            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   000037   85..82       MOV       DPL,?V10
   \   00003A   85..83       MOV       DPH,?V11
   \   00003D   12....       LCALL     ?Subroutine74 & 0xFFFF
   4471            for ( i = 0; i < readCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_121:
   \   000040   75..00       MOV       ?V2,#0x0
   \   000043   EE           MOV       A,R6
   \   000044   2402         ADD       A,#0x2
   \   000046   F5..         MOV       ?V14,A
   \   000048   E4           CLR       A
   \   000049   3F           ADDC      A,R7
   \   00004A   F5..         MOV       ?V15,A
   \   00004C   800B         SJMP      ??zclProcessInReadCmd_2
   4472            {
   4473              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4474          
   4475              statusRec->attrID = readCmd->attrID[i];
   4476              
   4477              attrFound = zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec );
   4478              
   4479              //Validate the attribute is found and the access control
   4480              if ( ( attrFound == TRUE ) && 
   4481                   (  (attrRec.attr.accessControl & ACCESS_GLOBAL) || 
   4482                      (GET_BIT( &attrRec.attr.accessControl, ACCESS_CONTROL_MASK ) == pInMsg->hdr.fc.direction ) ) )
   4483              {
   4484                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4485                {
   4486                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4487                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4488                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4489                  {
   4490                    statusRec->data = attrRec.attr.dataPtr;
   4491                    statusRec->dataType = attrRec.attr.dataType;
   4492                  }
   4493                }
   4494                else
   4495                {
   4496                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4497                }
   4498              }
   4499              else
   4500              {
   4501                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_3:
   \   00004E   85..82       MOV       DPL,?V6
   \   000051   85..83       MOV       DPH,?V7
   \   000054   7486         MOV       A,#-0x7a
   \                     ??zclProcessInReadCmd_4:
   \   000056   F0           MOVX      @DPTR,A
   4502              }
   \                     ??zclProcessInReadCmd_5:
   \   000057   05..         INC       ?V2
   \                     ??zclProcessInReadCmd_2:
   \   000059   85..82       MOV       DPL,?V10
   \   00005C   85..83       MOV       DPH,?V11
   \   00005F   12....       LCALL     ??Subroutine190_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_415:
   \   000062   4003         JC        $+5
   \   000064   02....       LJMP      ??zclProcessInReadCmd_6 & 0xFFFF
   \   000067   A8..         MOV       R0,?V2
   \   000069   E8           MOV       A,R0
   \   00006A   75F006       MOV       B,#0x6
   \   00006D   A4           MUL       AB
   \   00006E   FA           MOV       R2,A
   \   00006F   ABF0         MOV       R3,B
   \   000071   E5..         MOV       A,?V0
   \   000073   2A           ADD       A,R2
   \   000074   F582         MOV       DPL,A
   \   000076   E5..         MOV       A,?V1
   \   000078   3B           ADDC      A,R3
   \   000079   F583         MOV       DPH,A
   \   00007B   A3           INC       DPTR
   \   00007C   8582..       MOV       ?V4,DPL
   \   00007F   8583..       MOV       ?V5,DPH
   \   000082   E8           MOV       A,R0
   \   000083   28           ADD       A,R0
   \   000084   F8           MOV       R0,A
   \   000085   E4           CLR       A
   \   000086   33           RLC       A
   \   000087   F9           MOV       R1,A
   \   000088   E5..         MOV       A,?V10
   \   00008A   28           ADD       A,R0
   \   00008B   F582         MOV       DPL,A
   \   00008D   E5..         MOV       A,?V11
   \   00008F   12....       LCALL     ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000092   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000095   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_424:
   \   000098   E5..         MOV       A,?V4
   \   00009A   2402         ADD       A,#0x2
   \   00009C   F5..         MOV       ?V6,A
   \   00009E   E4           CLR       A
   \   00009F   35..         ADDC      A,?V5
   \   0000A1   F5..         MOV       ?V7,A
   \   0000A3   12....       LCALL     ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_435:
   \   0000A6                ; Setup parameters for call to function zclFindAttrRec
   \   0000A6   A8..         MOV       R0,?XSP + 0
   \   0000A8   A9..         MOV       R1,?XSP + 1
   \   0000AA   88..         MOV       ?V12,R0
   \   0000AC   89..         MOV       ?V13,R1
   \   0000AE   78..         MOV       R0,#?V12
   \   0000B0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B3   8A82         MOV       DPL,R2
   \   0000B5   8B83         MOV       DPH,R3
   \   0000B7   12....       LCALL     ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_465:
   \   0000BA   85..82       MOV       DPL,?V8
   \   0000BD   85..83       MOV       DPH,?V9
   \   0000C0   12....       LCALL     ??Subroutine194_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_452:
   \   0000C3   12....       LCALL     ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   0000C6   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000C9   7402         MOV       A,#0x2
   \   0000CB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000CE   E9           MOV       A,R1
   \   0000CF   6401         XRL       A,#0x1
   \   0000D1   6003         JZ        $+5
   \   0000D3   02....       LJMP      ??zclProcessInReadCmd_3 & 0xFFFF
   \   0000D6   7405         MOV       A,#0x5
   \   0000D8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DB   E0           MOVX      A,@DPTR
   \   0000DC   A2E6         MOV       C,0xE0 /* A   */.6
   \   0000DE   401A         JC        ??zclProcessInReadCmd_7
   \   0000E0   85..82       MOV       DPL,?V14
   \   0000E3   85..83       MOV       DPH,?V15
   \   0000E6   12....       LCALL     ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   0000E9   7405         MOV       A,#0x5
   \   0000EB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000EE   E0           MOVX      A,@DPTR
   \   0000EF   A2E7         MOV       C,0xE0 /* A   */.7
   \   0000F1   20F001       JB        B.0,??zclProcessInReadCmd_8
   \   0000F4   B3           CPL       C
   \                     ??zclProcessInReadCmd_8:
   \   0000F5   4003         JC        $+5
   \   0000F7   02....       LJMP      ??zclProcessInReadCmd_3 & 0xFFFF
   \                     ??zclProcessInReadCmd_7:
   \   0000FA   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000FC   5069         JNC       ??zclProcessInReadCmd_9
   \   0000FE   8E82         MOV       DPL,R6
   \   000100   8F83         MOV       DPH,R7
   \   000102   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   000105   E8           MOV       A,R0
   \   000106   2406         ADD       A,#0x6
   \   000108   F5..         MOV       ?V8,A
   \   00010A   E4           CLR       A
   \   00010B   39           ADDC      A,R1
   \   00010C   F5..         MOV       ?V9,A
   \   00010E   7405         MOV       A,#0x5
   \   000110   12....       LCALL     ?XSTACK_DISP0_8
   \   000113   E0           MOVX      A,@DPTR
   \   000114   A2E4         MOV       C,0xE0 /* A   */.4
   \   000116   5020         JNC       ??zclProcessInReadCmd_10
   \   000118                ; Setup parameters for call to function zclGetAuthorizeCB
   \   000118   12....       LCALL     ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   00011B   12....       LCALL     `??zclGetAuthorizeCB::?relay`; Banked call to: zclGetAuthorizeCB
   \   00011E   8A82         MOV       DPL,R2
   \   000120   8B83         MOV       DPH,R3
   \   000122   E582         MOV       A,DPL
   \   000124   4583         ORL       A,DPH
   \   000126   6010         JZ        ??zclProcessInReadCmd_10
   \   000128                ; Setup parameters for indirect call
   \   000128   7901         MOV       R1,#0x1
   \   00012A   AC..         MOV       R4,?XSP + 0
   \   00012C   AD..         MOV       R5,?XSP + 1
   \   00012E   AA..         MOV       R2,?V8
   \   000130   AB..         MOV       R3,?V9
   \   000132   12....       LCALL     ?CALL_IND
   \   000135   E9           MOV       A,R1
   \   000136   8002         SJMP      ??zclProcessInReadCmd_11
   \                     ??zclProcessInReadCmd_10:
   \   000138   7400         MOV       A,#0x0
   4503            }
   \                     ??zclProcessInReadCmd_11:
   \   00013A   85..82       MOV       DPL,?V6
   \   00013D   85..83       MOV       DPH,?V7
   \   000140   F0           MOVX      @DPTR,A
   \   000141   6003         JZ        $+5
   \   000143   02....       LJMP      ??zclProcessInReadCmd_5 & 0xFFFF
   \   000146   7406         MOV       A,#0x6
   \   000148   12....       LCALL     ?XSTACK_DISP0_8
   \   00014B   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   00014E   A3           INC       DPTR
   \   00014F   A3           INC       DPTR
   \   000150   A3           INC       DPTR
   \   000151   A3           INC       DPTR
   \   000152   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_425:
   \   000155   7404         MOV       A,#0x4
   \   000157   12....       LCALL     ?XSTACK_DISP0_8
   \   00015A   E0           MOVX      A,@DPTR
   \   00015B   85..82       MOV       DPL,?V4
   \   00015E   85..83       MOV       DPH,?V5
   \   000161   A3           INC       DPTR
   \   000162   A3           INC       DPTR
   \   000163   A3           INC       DPTR
   \   000164   02....       LJMP      ??zclProcessInReadCmd_4 & 0xFFFF
   \                     ??zclProcessInReadCmd_9:
   \   000167   85..82       MOV       DPL,?V6
   \   00016A   85..83       MOV       DPH,?V7
   \   00016D   748F         MOV       A,#-0x71
   \   00016F   02....       LJMP      ??zclProcessInReadCmd_4 & 0xFFFF
   4504          
   4505            // Build and send Read Response command
   4506            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4507                             readRspCmd, !pInMsg->hdr.fc.direction,
   4508                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   000172   12....       LCALL     ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_436:
   \   000175                ; Setup parameters for call to function zcl_SendReadRsp
   \   000175   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_490:
   \   000178   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00017B   75..01       MOV       ?V2,#0x1
   \   00017E   78..         MOV       R0,#?V2
   \   000180   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000183   85..82       MOV       DPL,?V14
   \   000186   85..83       MOV       DPH,?V15
   \   000189   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00018C   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00018F   78..         MOV       R0,#?V0
   \   000191   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000194   85..82       MOV       DPL,?V8
   \   000197   85..83       MOV       DPH,?V9
   \   00019A   12....       LCALL     ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_471:
   \   00019D   E5..         MOV       A,?V8
   \   00019F   12....       LCALL     ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_539:
   \   0001A2   35..         ADDC      A,?V9
   \   0001A4   FB           MOV       R3,A
   \   0001A5   12....       LCALL     ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   0001A8   12....       LCALL     `??zcl_SendReadRsp::?relay`; Banked call to: zcl_SendReadRsp
   \   0001AB   7405         MOV       A,#0x5
   \   0001AD   12....       LCALL     ?DEALLOC_XSTACK8
   4509            zcl_mem_free( readRspCmd );
   \   0001B0                ; Setup parameters for call to function osal_mem_free
   \   0001B0   AA..         MOV       R2,?V0
   \   0001B2   AB..         MOV       R3,?V1
   \   0001B4   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4510          
   4511            return TRUE;
   \   0001B7   7901         MOV       R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   0001B9   7408         MOV       A,#0x8
   \   0001BB   02....       LJMP      ?Subroutine5 & 0xFFFF
   4512          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   E5..         MOV       A,?V8
   \   000002   12....       LCALL     ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_524:
   \   000005   35..         ADDC      A,?V9
   \   000007   F583         MOV       DPH,A
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   F9           MOV       R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   12....       LCALL     ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_527:
   \   000003   A2E0         MOV       C,0xE0 /* A   */.0
   \   000005   92F0         MOV       B.0,C
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine193_0
   \   000004                ; // Fall through to label ??Subroutine193_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL     ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_512:
   \   000003   F5..         MOV       ?V2,A
   \   000005   78..         MOV       R0,#?V2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine206_0
   \   000004                ; // Fall through to label ??Subroutine206_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine206_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006                REQUIRE ??Subroutine207_0
   \   000006                ; // Fall through to label ??Subroutine207_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine159:
   \   000000   EA           MOV       A,R2
   \   000001   FE           MOV       R6,A
   \   000002   EB           MOV       A,R3
   \   000003   FF           MOV       R7,A
   \   000004   EE           MOV       A,R6
   \   000005                REQUIRE ??Subroutine210_0
   \   000005                ; // Fall through to label ??Subroutine210_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine210_0:
   \   000000   240C         ADD       A,#0xc
   \   000002   F582         MOV       DPL,A
   \   000004   E4           CLR       A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine214_0:
   \   000000   2406         ADD       A,#0x6
   \   000002   FA           MOV       R2,A
   \   000003   E4           CLR       A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   12....       LCALL     ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_506:
   \   000003   3F           ADDC      A,R7
   \   000004   F583         MOV       DPH,A
   \   000006   22           RET
   4513          #endif // ZCL_READ
   4514          
   4515          #ifdef ZCL_WRITE
   4516          /*********************************************************************
   4517           * @fn      processInWriteCmd
   4518           *
   4519           * @brief   Process the "Profile" Write and Write No Response Commands
   4520           *
   4521           * @param   pInMsg - incoming message to process
   4522           *
   4523           * @return  TRUE if command processed. FALSE, otherwise.
   4524           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4525          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4526          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   4527            zclWriteCmd_t *writeCmd;
   4528            zclWriteRspCmd_t *writeRspCmd;
   4529            uint8 sendRsp = FALSE;
   \   00000E   C2..         CLR       ?VB.0
   4530            uint8 j = 0;
   \   000010   7E00         MOV       R6,#0x0
   4531            uint8 i;
   4532          
   4533            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000012   EA           MOV       A,R2
   \   000013   12....       LCALL     ??Subroutine210_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_507:
   \   000016   35..         ADDC      A,?V3
   \   000018   F583         MOV       DPH,A
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F5..         MOV       ?V14,A
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F5..         MOV       ?V15,A
   4534            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \   000021   8A82         MOV       DPL,R2
   \   000023   8B83         MOV       DPH,R3
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   6402         XRL       A,#0x2
   \   00002F   701C         JNZ       ??zclProcessInWriteCmd_0
   4535            {
   4536              // We need to send a response back - allocate space for it
   4537              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4538                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000031                ; Setup parameters for call to function osal_mem_alloc
   \   000031   85..82       MOV       DPL,?V14
   \   000034   85..83       MOV       DPH,?V15
   \   000037   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   00003A   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003D   8A..         MOV       ?V4,R2
   \   00003F   8B..         MOV       ?V5,R3
   4539              if ( writeRspCmd == NULL )
   \   000041   EA           MOV       A,R2
   \   000042   45..         ORL       A,?V5
   \   000044   7005         JNZ       ??zclProcessInWriteCmd_1
   4540              {
   4541                return FALSE; // EMBEDDED RETURN
   \   000046   7900         MOV       R1,#0x0
   \   000048   02....       LJMP      ??zclProcessInWriteCmd_2 & 0xFFFF
   4542              }
   4543          
   4544              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   00004B   D2..         SETB      ?VB.0
   4545            }
   4546          
   4547            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   00004D   7F00         MOV       R7,#0x0
   \   00004F   8010         SJMP      ??zclProcessInWriteCmd_3
   4548            {
   4549              zclAttrRec_t attrRec;
   4550              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4551          
   4552              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4553                                   statusRec->attrID, &attrRec ) )
   4554              {
   4555                if ( GET_BIT( &attrRec.attr.accessControl, ACCESS_CONTROLEXT_MASK ) != pInMsg->hdr.fc.direction )
   4556                {
   4557                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4558                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4559                  break;
   4560                }
   4561                if ( statusRec->dataType == attrRec.attr.dataType )
   4562                {
   4563                  uint8 status;
   4564          
   4565                  // Write the new attribute value
   4566                  if ( attrRec.attr.dataPtr != NULL )
   4567                  {
   4568                    //Handle special case for Identify
   4569                    if((pInMsg->msg->clusterId == ZCL_CLUSTER_ID_GEN_IDENTIFY) && (statusRec->attrID == ATTRID_IDENTIFY_TIME))
   4570                    {
   4571                      uint16 identifyTime; 
   4572                            
   4573                      osal_memcpy((uint8*)&identifyTime,statusRec->attrData,sizeof(uint16));
   4574                                  
   4575                      bdb_ZclIdentifyCmdInd(identifyTime, pInMsg->msg->endPoint);
   4576                      
   4577                      status = ZCL_STATUS_SUCCESS;
   4578                    }          
   4579                    else
   4580                    {                
   4581                      status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4582                                                 &attrRec, statusRec );
   4583                    }
   4584                  }
   4585                  else // Use CB
   4586                  {
   4587                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4588                                                      &attrRec, statusRec->attrData );
   4589                  }
   4590          
   4591                  // If successful, a write attribute status record shall NOT be generated
   4592                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4593                  {
   4594                    // Attribute is read only - move on to the next write attribute record
   4595                    writeRspCmd->attrList[j].status = status;
   4596                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4597                  }
   4598                }
   4599                else
   4600                {
   4601                  // Attribute data type is incorrect - move on to the next write attribute record
   4602                  if ( sendRsp )
   4603                  {
   4604                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4605                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4606                  }
   4607                }
   4608              }
   4609              else
   4610              {
   4611                // Attribute is not supported - move on to the next write attribute record
   4612                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   000051   A2..         MOV       C,?VB.0
   \   000053   500B         JNC       ??CrossCallReturnLabel_7
   4613                {
   4614                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000055   85..82       MOV       DPL,?V12
   \   000058   85..83       MOV       DPH,?V13
   \   00005B   7486         MOV       A,#-0x7a
   4615                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4616                }
   4617              }
   \                     ??zclProcessInWriteCmd_5:
   \   00005D   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000060   0F           INC       R7
   \                     ??zclProcessInWriteCmd_3:
   \   000061   85..82       MOV       DPL,?V14
   \   000064   85..83       MOV       DPH,?V15
   \   000067   E0           MOVX      A,@DPTR
   \   000068   F8           MOV       R0,A
   \   000069   EF           MOV       A,R7
   \   00006A   C3           CLR       C
   \   00006B   98           SUBB      A,R0
   \   00006C   4003         JC        $+5
   \   00006E   02....       LJMP      ??CrossCallReturnLabel_8 & 0xFFFF
   \   000071   EF           MOV       A,R7
   \   000072   75F005       MOV       B,#0x5
   \   000075   A4           MUL       AB
   \   000076   F8           MOV       R0,A
   \   000077   A9F0         MOV       R1,B
   \   000079   E5..         MOV       A,?V14
   \   00007B   28           ADD       A,R0
   \   00007C   F582         MOV       DPL,A
   \   00007E   E5..         MOV       A,?V15
   \   000080   39           ADDC      A,R1
   \   000081   F583         MOV       DPH,A
   \   000083   A3           INC       DPTR
   \   000084   8582..       MOV       ?V0,DPL
   \   000087   8583..       MOV       ?V1,DPH
   \   00008A   EE           MOV       A,R6
   \   00008B   75F003       MOV       B,#0x3
   \   00008E   A4           MUL       AB
   \   00008F   F8           MOV       R0,A
   \   000090   A9F0         MOV       R1,B
   \   000092   E5..         MOV       A,?V4
   \   000094   28           ADD       A,R0
   \   000095   F582         MOV       DPL,A
   \   000097   E5..         MOV       A,?V5
   \   000099   39           ADDC      A,R1
   \   00009A   F583         MOV       DPH,A
   \   00009C   E582         MOV       A,DPL
   \   00009E   2402         ADD       A,#0x2
   \   0000A0   F5..         MOV       ?V8,A
   \   0000A2   E4           CLR       A
   \   0000A3   3583         ADDC      A,DPH
   \   0000A5   F5..         MOV       ?V9,A
   \   0000A7   A3           INC       DPTR
   \   0000A8   8582..       MOV       ?V12,DPL
   \   0000AB   8583..       MOV       ?V13,DPH
   \   0000AE   12....       LCALL     ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_461:
   \   0000B1                ; Setup parameters for call to function zclFindAttrRec
   \   0000B1   7402         MOV       A,#0x2
   \   0000B3   12....       LCALL     ?XSTACK_DISP100_8
   \   0000B6   88..         MOV       ?V10,R0
   \   0000B8   89..         MOV       ?V11,R1
   \   0000BA   78..         MOV       R0,#?V10
   \   0000BC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BF   85..82       MOV       DPL,?V0
   \   0000C2   85..83       MOV       DPH,?V1
   \   0000C5   12....       LCALL     ??Subroutine208_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_492:
   \   0000C8   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000CB   7402         MOV       A,#0x2
   \   0000CD   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000D0   E9           MOV       A,R1
   \   0000D1   7003         JNZ       $+5
   \   0000D3   02....       LJMP      ??zclProcessInWriteCmd_4 & 0xFFFF
   \   0000D6   85..82       MOV       DPL,?V2
   \   0000D9   85..83       MOV       DPH,?V3
   \   0000DC   A3           INC       DPTR
   \   0000DD   A3           INC       DPTR
   \   0000DE   12....       LCALL     ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   0000E1   7407         MOV       A,#0x7
   \   0000E3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E6   E0           MOVX      A,@DPTR
   \   0000E7   A2E7         MOV       C,0xE0 /* A   */.7
   \   0000E9   20F001       JB        B.0,??zclProcessInWriteCmd_6
   \   0000EC   B3           CPL       C
   \                     ??zclProcessInWriteCmd_6:
   \   0000ED   4074         JC        ??zclProcessInWriteCmd_7
   \   0000EF   85..82       MOV       DPL,?V12
   \   0000F2   85..83       MOV       DPH,?V13
   \   0000F5   7486         MOV       A,#-0x7a
   \   0000F7   12....       LCALL     ?Subroutine15 & 0xFFFF
   4618            } // for loop
   4619          
   4620            if ( sendRsp )
   \                     ??CrossCallReturnLabel_8:
   \   0000FA   A2..         MOV       C,?VB.0
   \   0000FC   505E         JNC       ??zclProcessInWriteCmd_8
   4621            {
   4622              writeRspCmd->numAttr = j;
   \   0000FE   EE           MOV       A,R6
   \   0000FF   85..82       MOV       DPL,?V4
   \   000102   85..83       MOV       DPH,?V5
   \   000105   F0           MOVX      @DPTR,A
   4623              if ( writeRspCmd->numAttr == 0 )
   \   000106   700B         JNZ       ??zclProcessInWriteCmd_9
   4624              {
   4625                // Since all records were written successful, include a single status record
   4626                // in the resonse command with the status field set to SUCCESS and the
   4627                // attribute ID field omitted.
   4628                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000108   A3           INC       DPTR
   \   000109   E4           CLR       A
   \   00010A   F0           MOVX      @DPTR,A
   4629                writeRspCmd->numAttr = 1;
   \   00010B   85..82       MOV       DPL,?V4
   \   00010E   85..83       MOV       DPH,?V5
   \   000111   04           INC       A
   \   000112   F0           MOVX      @DPTR,A
   4630              }
   4631          
   4632              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4633                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4634                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_9:
   \   000113   85..82       MOV       DPL,?V2
   \   000116   85..83       MOV       DPH,?V3
   \   000119   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_402:
   \   00011C                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00011C   85..82       MOV       DPL,?V2
   \   00011F   85..83       MOV       DPH,?V3
   \   000122   A3           INC       DPTR
   \   000123   A3           INC       DPTR
   \   000124   A3           INC       DPTR
   \   000125   A3           INC       DPTR
   \   000126   A3           INC       DPTR
   \   000127   A3           INC       DPTR
   \   000128   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   00012B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00012E   75..01       MOV       ?V0,#0x1
   \   000131   78..         MOV       R0,#?V0
   \   000133   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000136   85..82       MOV       DPL,?V2
   \   000139   85..83       MOV       DPH,?V3
   \   00013C   A3           INC       DPTR
   \   00013D   A3           INC       DPTR
   \   00013E   E0           MOVX      A,@DPTR
   \   00013F   12....       LCALL     ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000142   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000145   78..         MOV       R0,#?V4
   \   000147   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00014A   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00014D   12....       LCALL     `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   000150   7405         MOV       A,#0x5
   \   000152   12....       LCALL     ?DEALLOC_XSTACK8
   4635              zcl_mem_free( writeRspCmd );
   \   000155                ; Setup parameters for call to function osal_mem_free
   \   000155   AA..         MOV       R2,?V4
   \   000157   AB..         MOV       R3,?V5
   \   000159   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4636            }
   4637          
   4638            return TRUE;
   \                     ??zclProcessInWriteCmd_8:
   \   00015C   7901         MOV       R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   00015E   740A         MOV       A,#0xa
   \   000160   02....       LJMP      ?Subroutine5 & 0xFFFF
   \                     ??zclProcessInWriteCmd_7:
   \   000163   85..82       MOV       DPL,?V0
   \   000166   85..83       MOV       DPH,?V1
   \   000169   A3           INC       DPTR
   \   00016A   A3           INC       DPTR
   \   00016B   E0           MOVX      A,@DPTR
   \   00016C   F8           MOV       R0,A
   \   00016D   7406         MOV       A,#0x6
   \   00016F   12....       LCALL     ?XSTACK_DISP0_8
   \   000172   E0           MOVX      A,@DPTR
   \   000173   68           XRL       A,R0
   \   000174   6003         JZ        $+5
   \   000176   02....       LJMP      ??zclProcessInWriteCmd_10 & 0xFFFF
   \   000179   12....       LCALL     ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_462:
   \   00017C   7408         MOV       A,#0x8
   \   00017E   12....       LCALL     ?XSTACK_DISP0_8
   \   000181   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   000184   606F         JZ        ??zclProcessInWriteCmd_11
   \   000186   85..82       MOV       DPL,?V6
   \   000189   85..83       MOV       DPH,?V7
   \   00018C   A3           INC       DPTR
   \   00018D   A3           INC       DPTR
   \   00018E   A3           INC       DPTR
   \   00018F   A3           INC       DPTR
   \   000190   E0           MOVX      A,@DPTR
   \   000191   6403         XRL       A,#0x3
   \   000193   7002         JNZ       ??zclProcessInWriteCmd_12
   \   000195   A3           INC       DPTR
   \   000196   E0           MOVX      A,@DPTR
   \                     ??zclProcessInWriteCmd_12:
   \   000197   704A         JNZ       ??zclProcessInWriteCmd_13
   \   000199   85..82       MOV       DPL,?V0
   \   00019C   85..83       MOV       DPH,?V1
   \   00019F   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_348:
   \   0001A2   703F         JNZ       ??zclProcessInWriteCmd_13
   \   0001A4                ; Setup parameters for call to function osal_memcpy
   \   0001A4   85..82       MOV       DPL,?V0
   \   0001A7   85..83       MOV       DPH,?V1
   \   0001AA   A3           INC       DPTR
   \   0001AB   A3           INC       DPTR
   \   0001AC   A3           INC       DPTR
   \   0001AD   12....       LCALL     ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_433:
   \   0001B0   75..00       MOV       ?V10,#0x0
   \   0001B3   78..         MOV       R0,#?V8
   \   0001B5   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0001B8   7C02         MOV       R4,#0x2
   \   0001BA   7D00         MOV       R5,#0x0
   \   0001BC   7403         MOV       A,#0x3
   \   0001BE   12....       LCALL     ?XSTACK_DISP101_8
   \   0001C1   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0001C4   7403         MOV       A,#0x3
   \   0001C6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001C9                ; Setup parameters for call to function bdb_ZclIdentifyCmdInd
   \   0001C9   85..82       MOV       DPL,?V2
   \   0001CC   85..83       MOV       DPH,?V3
   \   0001CF   E0           MOVX      A,@DPTR
   \   0001D0   F8           MOV       R0,A
   \   0001D1   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   0001D4   85..82       MOV       DPL,?XSP + 0
   \   0001D7   85..83       MOV       DPH,?XSP + 1
   \   0001DA   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_447:
   \   0001DD   12....       LCALL     `??bdb_ZclIdentifyCmdInd::?relay`; Banked call to: bdb_ZclIdentifyCmdInd
   \   0001E0   02....       LJMP      ??CrossCallReturnLabel_7 & 0xFFFF
   \                     ??zclProcessInWriteCmd_13:
   \   0001E3                ; Setup parameters for call to function zclWriteAttrData
   \   0001E3   78..         MOV       R0,#?V0
   \   0001E5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001E8   7404         MOV       A,#0x4
   \   0001EA   12....       LCALL     ?XSTACK_DISP102_8
   \   0001ED   12....       LCALL     ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   0001F0   12....       LCALL     `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   0001F3   8017         SJMP      ??zclProcessInWriteCmd_14
   \                     ??zclProcessInWriteCmd_11:
   \   0001F5                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   0001F5   85..82       MOV       DPL,?V0
   \   0001F8   85..83       MOV       DPH,?V1
   \   0001FB   A3           INC       DPTR
   \   0001FC   A3           INC       DPTR
   \   0001FD   A3           INC       DPTR
   \   0001FE   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000201   7404         MOV       A,#0x4
   \   000203   12....       LCALL     ?XSTACK_DISP102_8
   \   000206   12....       LCALL     ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000209   12....       LCALL     `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteCmd_14:
   \   00020C   7402         MOV       A,#0x2
   \   00020E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000211   E9           MOV       A,R1
   \   000212   A2..         MOV       C,?VB.0
   \   000214   4003         JC        $+5
   \   000216   02....       LJMP      ??CrossCallReturnLabel_7 & 0xFFFF
   \   000219   7003         JNZ       $+5
   \   00021B   02....       LJMP      ??CrossCallReturnLabel_7 & 0xFFFF
   \   00021E   85..82       MOV       DPL,?V12
   \   000221   85..83       MOV       DPH,?V13
   \   000224   02....       LJMP      ??zclProcessInWriteCmd_5 & 0xFFFF
   \                     ??zclProcessInWriteCmd_10:
   \   000227   A2..         MOV       C,?VB.0
   \   000229   4003         JC        $+5
   \   00022B   02....       LJMP      ??CrossCallReturnLabel_7 & 0xFFFF
   \   00022E   85..82       MOV       DPL,?V12
   \   000231   85..83       MOV       DPH,?V13
   \   000234   748D         MOV       A,#-0x73
   \   000236   02....       LJMP      ??zclProcessInWriteCmd_5 & 0xFFFF
   4639          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL     ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   000003   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_364:
   \   000006   85..82       MOV       DPL,?V8
   \   000009   85..83       MOV       DPH,?V9
   \   00000C   E8           MOV       A,R0
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   A3           INC       DPTR
   \   00000F   E9           MOV       A,R1
   \   000010   F0           MOVX      @DPTR,A
   \   000011   0E           INC       R6
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine154:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004                REQUIRE ??Subroutine197_0
   \   000004                ; // Fall through to label ??Subroutine197_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   E5..         MOV       A,?V6
   \   000002   12....       LCALL     ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_543:
   \   000005   35..         ADDC      A,?V7
   \   000007   FB           MOV       R3,A
   \   000008   12....       LCALL     ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_496:
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006                REQUIRE ??Subroutine201_0
   \   000006                ; // Fall through to label ??Subroutine201_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   75F003       MOV       B,#0x3
   \   000004   A4           MUL       AB
   \   000005   A9F0         MOV       R1,B
   \   000007   2401         ADD       A,#0x1
   \   000009   FA           MOV       R2,A
   \   00000A   E4           CLR       A
   \   00000B   39           ADDC      A,R1
   \   00000C   FB           MOV       R3,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004   12....       LCALL     ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_501:
   \   000007   12....       LCALL     ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_545:
   \   00000A   3F           ADDC      A,R7
   \   00000B   FB           MOV       R3,A
   \   00000C   EE           MOV       A,R6
   \   00000D   12....       LCALL     ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_521:
   \   000010   3F           ADDC      A,R7
   \   000011   F583         MOV       DPH,A
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F9           MOV       R1,A
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine208_0:
   \   000000   12....       LCALL     ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_504:
   \   000003   85..82       MOV       DPL,?V6
   \   000006   85..83       MOV       DPH,?V7
   \   000009   12....       LCALL     ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_533:
   \   00000C   12....       LCALL     ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_497:
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine160:
   \   000000   E5..         MOV       A,?V6
   \   000002   2414         ADD       A,#0x14
   \   000004   F582         MOV       DPL,A
   \   000006   E4           CLR       A
   \   000007   35..         ADDC      A,?V7
   \   000009   F583         MOV       DPH,A
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   F9           MOV       R1,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine163:
   \   000000   EE           MOV       A,R6
   \   000001                REQUIRE ??Subroutine214_0
   \   000001                ; // Fall through to label ??Subroutine214_0
   4640          
   4641          /*********************************************************************
   4642           * @fn      zclRevertWriteUndividedCmd
   4643           *
   4644           * @brief   Revert the "Profile" Write Undevided Command
   4645           *
   4646           * @param   pInMsg - incoming message to process
   4647           * @param   curWriteRec - old data
   4648           * @param   numAttr - number of attributes to be reverted
   4649           *
   4650           * @return  none
   4651           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4652          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4653                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4654          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   8C..         MOV       ?V10,R4
   \   000010   8D..         MOV       ?V11,R5
   4655            uint8 i;
   4656          
   4657            for ( i = 0; i < numAttr; i++ )
   \   000012   75..00       MOV       ?V0,#0x0
   \   000015   741C         MOV       A,#0x1c
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_434:
   \   00001D   802F         SJMP      ??zclRevertWriteUndividedCmd_0
   4658            {
   4659              zclAttrRec_t attrRec;
   4660              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4661          
   4662              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4663                                    statusRec->attrID, &attrRec ) )
   4664              {
   4665                break; // should never happen
   4666              }
   4667          
   4668              if ( attrRec.attr.dataPtr != NULL )
   4669              {
   4670                // Just copy the old data back - no need to validate the data
   4671                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4672                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4673              }
   4674              else // Use CB
   4675              {
   4676                // Write the old data back
   4677                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4678                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_1:
   \   00001F   85..82       MOV       DPL,?V2
   \   000022   85..83       MOV       DPH,?V3
   \   000025   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   4679              }
   \                     ??CrossCallReturnLabel_403:
   \   000028                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000028   8A..         MOV       ?V4,R2
   \   00002A   8B..         MOV       ?V5,R3
   \   00002C   78..         MOV       R0,#?V4
   \   00002E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000031   7402         MOV       A,#0x2
   \   000033   12....       LCALL     ?XSTACK_DISP102_8
   \   000036   12....       LCALL     ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_544:
   \   000039   3F           ADDC      A,R7
   \   00003A   FB           MOV       R3,A
   \   00003B   EE           MOV       A,R6
   \   00003C   12....       LCALL     ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   00003F   3F           ADDC      A,R7
   \   000040   F583         MOV       DPH,A
   \   000042   E0           MOVX      A,@DPTR
   \   000043   F9           MOV       R1,A
   \   000044   12....       LCALL     `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \   000047   7402         MOV       A,#0x2
   \   000049   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??zclRevertWriteUndividedCmd_2:
   \   00004C   05..         INC       ?V0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00004E   C3           CLR       C
   \   00004F   E5..         MOV       A,?V0
   \   000051   95..         SUBB      A,?V8
   \   000053   E4           CLR       A
   \   000054   95..         SUBB      A,?V9
   \   000056   4003         JC        $+5
   \   000058   02....       LJMP      ??zclRevertWriteUndividedCmd_3 & 0xFFFF
   \   00005B   E5..         MOV       A,?V0
   \   00005D   75F005       MOV       B,#0x5
   \   000060   A4           MUL       AB
   \   000061   F8           MOV       R0,A
   \   000062   A9F0         MOV       R1,B
   \   000064   E5..         MOV       A,?V10
   \   000066   28           ADD       A,R0
   \   000067   FE           MOV       R6,A
   \   000068   E5..         MOV       A,?V11
   \   00006A   39           ADDC      A,R1
   \   00006B   FF           MOV       R7,A
   \   00006C   85..82       MOV       DPL,?V2
   \   00006F   85..83       MOV       DPH,?V3
   \   000072   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000075                ; Setup parameters for call to function zclFindAttrRec
   \   000075   A8..         MOV       R0,?XSP + 0
   \   000077   A9..         MOV       R1,?XSP + 1
   \   000079   88..         MOV       ?V6,R0
   \   00007B   89..         MOV       ?V7,R1
   \   00007D   78..         MOV       R0,#?V6
   \   00007F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000082   8E82         MOV       DPL,R6
   \   000084   8F83         MOV       DPH,R7
   \   000086   12....       LCALL     ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_466:
   \   000089   85..82       MOV       DPL,?V4
   \   00008C   85..83       MOV       DPH,?V5
   \   00008F   12....       LCALL     ??Subroutine194_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_453:
   \   000092   E5..         MOV       A,?V4
   \   000094   12....       LCALL     ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000097   35..         ADDC      A,?V5
   \   000099   F583         MOV       DPH,A
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   F9           MOV       R1,A
   \   00009D   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000A0   7402         MOV       A,#0x2
   \   0000A2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000A5   E9           MOV       A,R1
   \   0000A6   604D         JZ        ??zclRevertWriteUndividedCmd_3
   \   0000A8   EE           MOV       A,R6
   \   0000A9   2403         ADD       A,#0x3
   \   0000AB   F5..         MOV       ?V4,A
   \   0000AD   E4           CLR       A
   \   0000AE   3F           ADDC      A,R7
   \   0000AF   F5..         MOV       ?V5,A
   \   0000B1   85..82       MOV       DPL,?V4
   \   0000B4   F583         MOV       DPH,A
   \   0000B6   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_448:
   \   0000B9   7406         MOV       A,#0x6
   \   0000BB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BE   12....       LCALL     ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_404:
   \   0000C1   EE           MOV       A,R6
   \   0000C2   4F           ORL       A,R7
   \   0000C3   7003         JNZ       $+5
   \   0000C5   02....       LJMP      ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   \   0000C8                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000C8   7404         MOV       A,#0x4
   \   0000CA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CD   E0           MOVX      A,@DPTR
   \   0000CE   F9           MOV       R1,A
   \   0000CF   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   0000D2   8A..         MOV       ?V6,R2
   \   0000D4   8B..         MOV       ?V7,R3
   \   0000D6   AC..         MOV       R4,?V6
   \   0000D8   AD..         MOV       R5,?V7
   \   0000DA                ; Setup parameters for call to function osal_memcpy
   \   0000DA   85..82       MOV       DPL,?V4
   \   0000DD   85..83       MOV       DPH,?V5
   \   0000E0   12....       LCALL     ?Subroutine52 & 0xFFFF
   4680            } // for loop
   \                     ??CrossCallReturnLabel_67:
   \   0000E3   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000E6   EE           MOV       A,R6
   \   0000E7   FA           MOV       R2,A
   \   0000E8   EF           MOV       A,R7
   \   0000E9   FB           MOV       R3,A
   \   0000EA   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000ED   7403         MOV       A,#0x3
   \   0000EF   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000F2   02....       LJMP      ??zclRevertWriteUndividedCmd_2 & 0xFFFF
   4681          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   0000F5   7408         MOV       A,#0x8
   \   0000F7   80..         SJMP      ??Subroutine198_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine198_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine199_0
   \   000003                ; // Fall through to label ??Subroutine199_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   000003   88..         MOV       ?V4,R0
   \   000005   89..         MOV       ?V5,R1
   \   000007   22           RET
   4682          
   4683          /*********************************************************************
   4684           * @fn      zclProcessInWriteUndividedCmd
   4685           *
   4686           * @brief   Process the "Profile" Write Undivided Command
   4687           *
   4688           * @param   pInMsg - incoming message to process
   4689           *
   4690           * @return  TRUE if command processed. FALSE, otherwise.
   4691           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL     ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000003                REQUIRE ??Subroutine170_0
   \   000003                ; // Fall through to label ??Subroutine170_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4692          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4693          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV       A,#-0xc
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V4,R2
   \   00000C   8B..         MOV       ?V5,R3
   4694            zclWriteCmd_t *writeCmd;
   4695            zclWriteRspCmd_t *writeRspCmd;
   4696            zclAttrRec_t attrRec;
   4697            uint16 dataLen;
   4698            uint16 curLen = 0;
   \   00000E   75..00       MOV       ?V8,#0x0
   \   000011   75..00       MOV       ?V9,#0x0
   4699            uint8 j = 0;
   \   000014   7E00         MOV       R6,#0x0
   4700            uint8 i;
   4701          
   4702            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000016   EA           MOV       A,R2
   \   000017   12....       LCALL     ??Subroutine210_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_508:
   \   00001A   35..         ADDC      A,?V5
   \   00001C   F583         MOV       DPH,A
   \   00001E   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_358:
   \   000021   7402         MOV       A,#0x2
   \   000023   12....       LCALL     ?XSTACK_DISP0_8
   \   000026   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   4703          
   4704            // Allocate space for Write Response Command
   4705            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4706                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_426:
   \   000029                ; Setup parameters for call to function osal_mem_alloc
   \   000029   7402         MOV       A,#0x2
   \   00002B   12....       LCALL     ?XSTACK_DISP0_8
   \   00002E   12....       LCALL     ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000031   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000034   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000037   8A..         MOV       ?V0,R2
   \   000039   8B..         MOV       ?V1,R3
   4707            if ( writeRspCmd == NULL )
   \   00003B   EA           MOV       A,R2
   \   00003C   45..         ORL       A,?V1
   \   00003E   7003         JNZ       $+5
   \   000040   02....       LJMP      ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   4708            {
   4709              return FALSE; // EMBEDDED RETURN
   4710            }
   4711          
   4712            // If any attribute cannot be written, no attribute values are changed. Hence,
   4713            // make sure all the attributes are supported and writable
   4714            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000043   7F00         MOV       R7,#0x0
   \   000045   803C         SJMP      ??zclProcessInWriteUndividedCmd_1
   4715            {
   4716              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4717          
   4718              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4719                                    statusRec->attrID, &attrRec ) )
   4720              {
   4721                // Attribute is not supported - stop here
   4722                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4723                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4724                break;
   4725              }
   4726          
   4727              if ( statusRec->dataType != attrRec.attr.dataType )
   4728              {
   4729                // Attribute data type is incorrect - stope here
   4730                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4731                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4732                break;
   4733              }
   4734          
   4735              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4736              {
   4737                // Attribute is not writable - stop here
   4738                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4739                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4740                break;
   4741              }
   4742          
   4743              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4744              {
   4745                // Not authorized to write - stop here
   4746                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4747                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4748                break;
   4749              }
   4750          
   4751              // Attribute Data length
   4752              if ( attrRec.attr.dataPtr != NULL )
   4753              {
   4754                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4755              }
   4756              else // Use CB
   4757              {
   4758                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4759                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000047   12....       LCALL     ?Subroutine57 & 0xFFFF
   4760              }
   \                     ??CrossCallReturnLabel_474:
   \   00004A   12....       LCALL     ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_467:
   \   00004D   8882         MOV       DPL,R0
   \   00004F   8983         MOV       DPH,R1
   \   000051   12....       LCALL     ??Subroutine194_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_454:
   \   000054   12....       LCALL     ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000057   12....       LCALL     `??zclGetAttrDataLengthUsingCB::?relay`; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   00005A   85..82       MOV       DPL,?XSP + 0
   \   00005D   85..83       MOV       DPH,?XSP + 1
   \   000060   12....       LCALL     ??Subroutine171_0 & 0xFFFF
   4761          
   4762              // add padding if needed
   4763              if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_294:
   \   000063   85..82       MOV       DPL,?XSP + 0
   \   000066   85..83       MOV       DPH,?XSP + 1
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   A2E0         MOV       C,0xE0 /* A   */.0
   \   00006C   5003         JNC       ??CrossCallReturnLabel_227
   4764              {
   4765                dataLen++;
   \   00006E   12....       LCALL     ?Subroutine127 & 0xFFFF
   4766              }
   4767          
   4768              curLen += dataLen;
   \                     ??CrossCallReturnLabel_227:
   \   000071   85..82       MOV       DPL,?XSP + 0
   \   000074   85..83       MOV       DPH,?XSP + 1
   \   000077   E0           MOVX      A,@DPTR
   \   000078   25..         ADD       A,?V8
   \   00007A   F5..         MOV       ?V8,A
   \   00007C   A3           INC       DPTR
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   35..         ADDC      A,?V9
   \   000080   F5..         MOV       ?V9,A
   \   000082   0F           INC       R7
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000083   7402         MOV       A,#0x2
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   00008B   5047         JNC       ??zclProcessInWriteUndividedCmd_4
   \   00008D   EF           MOV       A,R7
   \   00008E   75F005       MOV       B,#0x5
   \   000091   A4           MUL       AB
   \   000092   F8           MOV       R0,A
   \   000093   A9F0         MOV       R1,B
   \   000095   7402         MOV       A,#0x2
   \   000097   12....       LCALL     ?XSTACK_DISP0_8
   \   00009A   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   00009D   12....       LCALL     ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   0000A0   12....       LCALL     ?XSTACK_DISP100_8
   \   0000A3   88..         MOV       ?V10,R0
   \   0000A5   89..         MOV       ?V11,R1
   \   0000A7   78..         MOV       R0,#?V10
   \   0000A9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AC   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_493:
   \   0000AF   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000B2   7402         MOV       A,#0x2
   \   0000B4   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B7   E9           MOV       A,R1
   \   0000B8   704B         JNZ       ??zclProcessInWriteUndividedCmd_5
   \   0000BA   85..82       MOV       DPL,?V0
   \   0000BD   85..83       MOV       DPH,?V1
   \   0000C0   A3           INC       DPTR
   \   0000C1   7486         MOV       A,#-0x7a
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000C3   F0           MOVX      @DPTR,A
   \   0000C4   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_362:
   \   0000C7   85..82       MOV       DPL,?V0
   \   0000CA   85..83       MOV       DPH,?V1
   \   0000CD   A3           INC       DPTR
   \   0000CE   A3           INC       DPTR
   \   0000CF   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_427:
   \   0000D2   7E01         MOV       R6,#0x1
   4769            } // for loop
   4770          
   4771            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   0000D4   EE           MOV       A,R6
   \   0000D5   85..82       MOV       DPL,?V0
   \   0000D8   85..83       MOV       DPH,?V1
   \   0000DB   F0           MOVX      @DPTR,A
   4772            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000DC   6003         JZ        $+5
   \   0000DE   02....       LJMP      ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   4773            {
   4774              uint8 *curDataPtr;
   4775              zclWriteRec_t *curWriteRec;
   4776          
   4777              // calculate the length of the current data header
   4778              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   0000E1   75F005       MOV       B,#0x5
   \   0000E4   A4           MUL       AB
   \   0000E5   FF           MOV       R7,A
   4779          
   4780              // Allocate space to keep a copy of the current data
   4781              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   0000E6                ; Setup parameters for call to function osal_mem_alloc
   \   0000E6   25..         ADD       A,?V8
   \   0000E8   FA           MOV       R2,A
   \   0000E9   E4           CLR       A
   \   0000EA   35..         ADDC      A,?V9
   \   0000EC   FB           MOV       R3,A
   \   0000ED   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000F0   8A..         MOV       ?V14,R2
   \   0000F2   8B..         MOV       ?V15,R3
   4782              if ( curWriteRec == NULL )
   \   0000F4   EA           MOV       A,R2
   \   0000F5   45..         ORL       A,?V15
   \   0000F7   705C         JNZ       ??zclProcessInWriteUndividedCmd_8
   4783              {
   4784                zcl_mem_free(writeRspCmd );
   \   0000F9                ; Setup parameters for call to function osal_mem_free
   \   0000F9   AA..         MOV       R2,?V0
   \   0000FB   AB..         MOV       R3,?V1
   \   0000FD   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4785                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   000100   7900         MOV       R1,#0x0
   \   000102   02....       LJMP      ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   4786              }
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   000105   7408         MOV       A,#0x8
   \   000107   12....       LCALL     ?XSTACK_DISP0_8
   \   00010A   12....       LCALL     ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_476:
   \   00010D   A3           INC       DPTR
   \   00010E   A3           INC       DPTR
   \   00010F   E0           MOVX      A,@DPTR
   \   000110   69           XRL       A,R1
   \   000111   600B         JZ        ??zclProcessInWriteUndividedCmd_10
   \   000113   85..82       MOV       DPL,?V0
   \   000116   85..83       MOV       DPH,?V1
   \   000119   A3           INC       DPTR
   \   00011A   748D         MOV       A,#-0x73
   \   00011C   80A5         SJMP      ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00011E   7409         MOV       A,#0x9
   \   000120   12....       LCALL     ?XSTACK_DISP0_8
   \   000123   E0           MOVX      A,@DPTR
   \   000124   A2E1         MOV       C,0xE0 /* A   */.1
   \   000126   400B         JC        ??zclProcessInWriteUndividedCmd_11
   \   000128   85..82       MOV       DPL,?V0
   \   00012B   85..83       MOV       DPH,?V1
   \   00012E   A3           INC       DPTR
   \   00012F   7488         MOV       A,#-0x78
   \   000131   8090         SJMP      ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000133   A2E5         MOV       C,0xE0 /* A   */.5
   \   000135   500B         JNC       ??zclProcessInWriteUndividedCmd_12
   \   000137   85..82       MOV       DPL,?V0
   \   00013A   85..83       MOV       DPH,?V1
   \   00013D   A3           INC       DPTR
   \   00013E   747E         MOV       A,#0x7e
   \   000140   8081         SJMP      ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   000142   740A         MOV       A,#0xa
   \   000144   12....       LCALL     ?XSTACK_DISP0_8
   \   000147   12....       LCALL     ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   00014A   7003         JNZ       $+5
   \   00014C   02....       LJMP      ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   00014F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00014F   12....       LCALL     `??zclGetAttrDataLength::?relay`; Banked call to: zclGetAttrDataLength
   \   000152   02....       LJMP      ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4787          
   4788              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   000155   EA           MOV       A,R2
   \   000156   2F           ADD       A,R7
   \   000157   F5..         MOV       ?V8,A
   \   000159   E4           CLR       A
   \   00015A   3B           ADDC      A,R3
   \   00015B   F5..         MOV       ?V9,A
   4789          
   4790              // Write the new data over
   4791              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   00015D   7F00         MOV       R7,#0x0
   \   00015F   8022         SJMP      ??zclProcessInWriteUndividedCmd_13
   4792              {
   4793                uint8 status;
   4794                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4795                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4796          
   4797                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4798                                      statusRec->attrID, &attrRec ) )
   4799                {
   4800                  break; // should never happen
   4801                }
   4802          
   4803                // Keep a copy of the current data before before writing the new data over
   4804                curStatusRec->attrID = statusRec->attrID;
   4805                curStatusRec->attrData = curDataPtr;
   4806          
   4807                if ( attrRec.attr.dataPtr != NULL )
   4808                {
   4809                  // Read the current value
   4810                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4811          
   4812                  // Write the new attribute value
   4813                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4814                                             &attrRec, statusRec );
   4815                }
   4816                else // Use CBs
   4817                {
   4818                  // Read the current value
   4819                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4820                                          statusRec->attrID, curDataPtr, &dataLen );
   4821                  // Write the new attribute value
   4822                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4823                                                    &attrRec, statusRec->attrData );
   4824                }
   4825          
   4826                // If successful, a write attribute status record shall NOT be generated
   4827                if ( status != ZCL_STATUS_SUCCESS )
   4828                {
   4829                  writeRspCmd->attrList[j].status = status;
   4830                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4831          
   4832                  // Since this write failed, we need to revert all the pervious writes
   4833                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4834                  break;
   4835                }
   4836          
   4837                // add padding if needed
   4838                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000161   85..82       MOV       DPL,?XSP + 0
   \   000164   85..83       MOV       DPH,?XSP + 1
   \   000167   E0           MOVX      A,@DPTR
   \   000168   A2E0         MOV       C,0xE0 /* A   */.0
   \   00016A   5003         JNC       ??CrossCallReturnLabel_228
   4839                {
   4840                  dataLen++;
   \   00016C   12....       LCALL     ?Subroutine127 & 0xFFFF
   4841                }
   4842          
   4843                curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_228:
   \   00016F   85..82       MOV       DPL,?XSP + 0
   \   000172   85..83       MOV       DPH,?XSP + 1
   \   000175   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_359:
   \   000178   E5..         MOV       A,?V8
   \   00017A   28           ADD       A,R0
   \   00017B   F5..         MOV       ?V8,A
   \   00017D   E5..         MOV       A,?V9
   \   00017F   39           ADDC      A,R1
   \   000180   F5..         MOV       ?V9,A
   \   000182   0F           INC       R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   000183   7402         MOV       A,#0x2
   \   000185   12....       LCALL     ?XSTACK_DISP0_8
   \   000188   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   00018B   4003         JC        $+5
   \   00018D   02....       LJMP      ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   000190   EF           MOV       A,R7
   \   000191   75F005       MOV       B,#0x5
   \   000194   A4           MUL       AB
   \   000195   F8           MOV       R0,A
   \   000196   A9F0         MOV       R1,B
   \   000198   7402         MOV       A,#0x2
   \   00019A   12....       LCALL     ?XSTACK_DISP0_8
   \   00019D   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   0001A0   E5..         MOV       A,?V14
   \   0001A2   28           ADD       A,R0
   \   0001A3   F5..         MOV       ?V12,A
   \   0001A5   E5..         MOV       A,?V15
   \   0001A7   39           ADDC      A,R1
   \   0001A8   F5..         MOV       ?V13,A
   \   0001AA   12....       LCALL     ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   0001AD   12....       LCALL     ?XSTACK_DISP100_8
   \   0001B0   88..         MOV       ?V10,R0
   \   0001B2   89..         MOV       ?V11,R1
   \   0001B4   78..         MOV       R0,#?V10
   \   0001B6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001B9   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_494:
   \   0001BC   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0001BF   7402         MOV       A,#0x2
   \   0001C1   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001C4   E9           MOV       A,R1
   \   0001C5   7003         JNZ       $+5
   \   0001C7   02....       LJMP      ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001CA   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_363:
   \   0001CD   85..82       MOV       DPL,?V12
   \   0001D0   85..83       MOV       DPH,?V13
   \   0001D3   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_428:
   \   0001D6   85..82       MOV       DPL,?V12
   \   0001D9   85..83       MOV       DPH,?V13
   \   0001DC   A3           INC       DPTR
   \   0001DD   A3           INC       DPTR
   \   0001DE   A3           INC       DPTR
   \   0001DF   E5..         MOV       A,?V8
   \   0001E1   F0           MOVX      @DPTR,A
   \   0001E2   A3           INC       DPTR
   \   0001E3   E5..         MOV       A,?V9
   \   0001E5   F0           MOVX      @DPTR,A
   \   0001E6   740A         MOV       A,#0xa
   \   0001E8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001EB   12....       LCALL     ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   0001EE   6039         JZ        ??zclProcessInWriteUndividedCmd_16
   \   0001F0                ; Setup parameters for call to function zclReadAttrData
   \   0001F0   A8..         MOV       R0,?XSP + 0
   \   0001F2   A9..         MOV       R1,?XSP + 1
   \   0001F4   88..         MOV       ?V6,R0
   \   0001F6   89..         MOV       ?V7,R1
   \   0001F8   78..         MOV       R0,#?V6
   \   0001FA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001FD   7406         MOV       A,#0x6
   \   0001FF   12....       LCALL     ?XSTACK_DISP102_8
   \   000202   AA..         MOV       R2,?V8
   \   000204   AB..         MOV       R3,?V9
   \   000206   12....       LCALL     `??zclReadAttrData::?relay`; Banked call to: zclReadAttrData
   \   000209   7402         MOV       A,#0x2
   \   00020B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00020E   85..82       MOV       DPL,?V4
   \   000211   85..83       MOV       DPH,?V5
   \   000214   12....       LCALL     ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_459:
   \   000217                ; Setup parameters for call to function zclWriteAttrData
   \   000217   78..         MOV       R0,#?V2
   \   000219   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00021C   7406         MOV       A,#0x6
   \   00021E   12....       LCALL     ?XSTACK_DISP102_8
   \   000221   12....       LCALL     ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000224   12....       LCALL     `??zclWriteAttrData::?relay`; Banked call to: zclWriteAttrData
   \   000227   8040         SJMP      ??zclProcessInWriteUndividedCmd_17
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   000229   85..82       MOV       DPL,?V4
   \   00022C   85..83       MOV       DPH,?V5
   \   00022F   12....       LCALL     ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_460:
   \   000232                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000232   A8..         MOV       R0,?XSP + 0
   \   000234   A9..         MOV       R1,?XSP + 1
   \   000236   88..         MOV       ?V10,R0
   \   000238   89..         MOV       ?V11,R1
   \   00023A   78..         MOV       R0,#?V10
   \   00023C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00023F   78..         MOV       R0,#?V8
   \   000241   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000244   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_495:
   \   000247   12....       LCALL     `??zclReadAttrDataUsingCB::?relay`; Banked call to: zclReadAttrDataUsingCB
   \   00024A   7404         MOV       A,#0x4
   \   00024C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00024F   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_475:
   \   000252   A3           INC       DPTR
   \   000253   A3           INC       DPTR
   \   000254   A3           INC       DPTR
   \   000255   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000258   7406         MOV       A,#0x6
   \   00025A   12....       LCALL     ?XSTACK_DISP102_8
   \   00025D   E8           MOV       A,R0
   \   00025E   12....       LCALL     ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_540:
   \   000261   39           ADDC      A,R1
   \   000262   FB           MOV       R3,A
   \   000263   12....       LCALL     ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000266   12....       LCALL     `??zclWriteAttrDataUsingCB::?relay`; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000269   7402         MOV       A,#0x2
   \   00026B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00026E   E9           MOV       A,R1
   \   00026F   FA           MOV       R2,A
   \   000270   EA           MOV       A,R2
   \   000271   7003         JNZ       $+5
   \   000273   02....       LJMP      ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   000276   EE           MOV       A,R6
   \   000277   75F003       MOV       B,#0x3
   \   00027A   A4           MUL       AB
   \   00027B   F8           MOV       R0,A
   \   00027C   A9F0         MOV       R1,B
   \   00027E   E5..         MOV       A,?V0
   \   000280   28           ADD       A,R0
   \   000281   F8           MOV       R0,A
   \   000282   E5..         MOV       A,?V1
   \   000284   39           ADDC      A,R1
   \   000285   F9           MOV       R1,A
   \   000286   EA           MOV       A,R2
   \   000287   8882         MOV       DPL,R0
   \   000289   8983         MOV       DPH,R1
   \   00028B   A3           INC       DPTR
   \   00028C   F0           MOVX      @DPTR,A
   \   00028D   85..82       MOV       DPL,?V2
   \   000290   85..83       MOV       DPH,?V3
   \   000293   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000296   0E           INC       R6
   \   000297                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   000297   EF           MOV       A,R7
   \   000298   F5..         MOV       ?V2,A
   \   00029A   75..00       MOV       ?V3,#0x0
   \   00029D   78..         MOV       R0,#?V2
   \   00029F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0002A2   AC..         MOV       R4,?V14
   \   0002A4   AD..         MOV       R5,?V15
   \   0002A6   AA..         MOV       R2,?V4
   \   0002A8   AB..         MOV       R3,?V5
   \   0002AA   12....       LCALL     `??zclRevertWriteUndividedCmd::?relay`; Banked call to: zclRevertWriteUndividedCmd
   \   0002AD   7402         MOV       A,#0x2
   \   0002AF   12....       LCALL     ?DEALLOC_XSTACK8
   4844              } // for loop
   4845          
   4846              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0002B2   EE           MOV       A,R6
   \   0002B3   85..82       MOV       DPL,?V0
   \   0002B6   85..83       MOV       DPH,?V1
   \   0002B9   F0           MOVX      @DPTR,A
   4847              if ( writeRspCmd->numAttr  == 0 )
   \   0002BA   7007         JNZ       ??zclProcessInWriteUndividedCmd_18
   4848              {
   4849                // Since all records were written successful, include a single status record
   4850                // in the resonse command with the status field set to SUCCESS and the
   4851                // attribute ID field omitted.
   4852                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002BC   A3           INC       DPTR
   \   0002BD   E4           CLR       A
   \   0002BE   12....       LCALL     ?Subroutine133 & 0xFFFF
   4853                writeRspCmd->numAttr = 1;
   4854              }
   \                     ??CrossCallReturnLabel_238:
   \   0002C1   04           INC       A
   \   0002C2   F0           MOVX      @DPTR,A
   4855          
   4856              zcl_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0002C3                ; Setup parameters for call to function osal_mem_free
   \   0002C3   AA..         MOV       R2,?V14
   \   0002C5   AB..         MOV       R3,?V15
   \   0002C7   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4857            }
   4858          
   4859            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4860                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4861                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002CA   12....       LCALL     ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_406:
   \   0002CD                ; Setup parameters for call to function zcl_SendWriteRsp
   \   0002CD   85..82       MOV       DPL,?V4
   \   0002D0   85..83       MOV       DPH,?V5
   \   0002D3   12....       LCALL     ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_489:
   \   0002D6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002D9   75..01       MOV       ?V2,#0x1
   \   0002DC   78..         MOV       R0,#?V2
   \   0002DE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002E1   85..82       MOV       DPL,?V4
   \   0002E4   85..83       MOV       DPH,?V5
   \   0002E7   A3           INC       DPTR
   \   0002E8   A3           INC       DPTR
   \   0002E9   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0002EC   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0002EF   78..         MOV       R0,#?V0
   \   0002F1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0002F4   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   0002F7   12....       LCALL     `??zcl_SendWriteRsp::?relay`; Banked call to: zcl_SendWriteRsp
   \   0002FA   7405         MOV       A,#0x5
   \   0002FC   12....       LCALL     ?DEALLOC_XSTACK8
   4862            zcl_mem_free( writeRspCmd );
   \   0002FF                ; Setup parameters for call to function osal_mem_free
   \   0002FF   AA..         MOV       R2,?V0
   \   000301   AB..         MOV       R3,?V1
   \   000303   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4863          
   4864            return TRUE;
   \   000306   7901         MOV       R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   000308   740C         MOV       A,#0xc
   \   00030A                REQUIRE ?Subroutine5
   \   00030A                ; // Fall through to label ?Subroutine5
   4865          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   2401         ADD       A,#0x1
   \   000002   F0           MOVX      @DPTR,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   3400         ADDC      A,#0x0
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   E8           MOV       A,R0
   \   000001   12....       LCALL     ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_523:
   \   000004   39           ADDC      A,R1
   \   000005   F583         MOV       DPH,A
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   85..82       MOV       DPL,?V4
   \   000003   85..83       MOV       DPH,?V5
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F5..         MOV       ?V6,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   F5..         MOV       ?V7,A
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D   7404         MOV       A,#0x4
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL     ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   EF           MOV       A,R7
   \   000006   C3           CLR       C
   \   000007   98           SUBB      A,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   28           ADD       A,R0
   \   000002   FA           MOV       R2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   39           ADDC      A,R1
   \   000006   8A82         MOV       DPL,R2
   \   000008   F583         MOV       DPH,A
   \   00000A   A3           INC       DPTR
   \   00000B   8582..       MOV       ?V2,DPL
   \   00000E   8583..       MOV       ?V3,DPH
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   85..82       MOV       DPL,?V4
   \   000003   85..83       MOV       DPH,?V5
   \   000006                REQUIRE ??Subroutine204_0
   \   000006                ; // Fall through to label ??Subroutine204_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006                REQUIRE ??Subroutine208_0
   \   000006                ; // Fall through to label ??Subroutine208_0
   4866          #endif // ZCL_WRITE
   4867          
   4868          #ifdef ZCL_DISCOVER
   4869          /*********************************************************************
   4870           * @fn      zclProcessInDiscAttrs
   4871           *
   4872           * @brief   Process the "Profile" Discover Attributes Commands
   4873           *
   4874           * @param   pInMsg - incoming message to process
   4875           *
   4876           * @return  TRUE if command processed. FALSE, otherwise.
   4877           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4878          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   \                     zclProcessInDiscAttrs:
   4879          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine159 & 0xFFFF
   4880            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4881            zclAttrRec_t attrRec;
   4882            uint16 attrID;
   4883            uint8 numAttrs;
   4884            uint8 i;
   4885          
   4886            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_505:
   \   00000D   3F           ADDC      A,R7
   \   00000E   12....       LCALL     ?Subroutine62 & 0xFFFF
   4887          
   4888            // Find out the number of attributes supported within the specified range
   4889            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   \                     ??CrossCallReturnLabel_391:
   \   000011   75..00       MOV       ?V2,#0x0
   \   000014   85..82       MOV       DPL,?V0
   \   000017   F583         MOV       DPH,A
   \   000019   12....       LCALL     ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_360:
   \   00001C   85..82       MOV       DPL,?XSP + 0
   \   00001F   85..83       MOV       DPH,?XSP + 1
   \   000022   E8           MOV       A,R0
   \   000023   F0           MOVX      @DPTR,A
   \   000024   A3           INC       DPTR
   \   000025   E9           MOV       A,R1
   \   000026   8010         SJMP      ??zclProcessInDiscAttrs_0
   \                     ??zclProcessInDiscAttrs_1:
   \   000028   05..         INC       ?V2
   \   00002A   85..82       MOV       DPL,?XSP + 0
   \   00002D   85..83       MOV       DPH,?XSP + 1
   \   000030   E0           MOVX      A,@DPTR
   \   000031   2401         ADD       A,#0x1
   \   000033   F0           MOVX      @DPTR,A
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   3400         ADDC      A,#0x0
   \                     ??zclProcessInDiscAttrs_0:
   \   000038   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00003B   F8           MOV       R0,A
   \   00003C   E5..         MOV       A,?V2
   \   00003E   C3           CLR       C
   \   00003F   98           SUBB      A,R0
   \   000040   5037         JNC       ??zclProcessInDiscAttrs_2
   4890            {
   4891              // finds the next attribute on this endpoint/cluster after the range.
   4892              // attributes must be in numerical order in the list.
   4893              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \   000042   8E82         MOV       DPL,R6
   \   000044   8F83         MOV       DPH,R7
   \   000046   12....       LCALL     ?Subroutine86 & 0xFFFF
   4894              {
   4895                break;
   4896              }
   4897            }
   \                     ??CrossCallReturnLabel_143:
   \   000049                ; Setup parameters for call to function zclFindNextAttrRec
   \   000049   7402         MOV       A,#0x2
   \   00004B   12....       LCALL     ?XSTACK_DISP100_8
   \   00004E   88..         MOV       ?V6,R0
   \   000050   89..         MOV       ?V7,R1
   \   000052   78..         MOV       R0,#?V6
   \   000054   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000057   7402         MOV       A,#0x2
   \   000059   12....       LCALL     ?XSTACK_DISP100_8
   \   00005C   88..         MOV       ?V6,R0
   \   00005E   89..         MOV       ?V7,R1
   \   000060   78..         MOV       R0,#?V6
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000065   8E82         MOV       DPL,R6
   \   000067   8F83         MOV       DPH,R7
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   12....       LCALL     ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_514:
   \   00006E   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   000071   7404         MOV       A,#0x4
   \   000073   12....       LCALL     ?DEALLOC_XSTACK8
   \   000076   E9           MOV       A,R1
   \   000077   70AF         JNZ       ??zclProcessInDiscAttrs_1
   4898          
   4899            numAttrs = i;  // store range of attributes in buffer
   4900          
   4901              // Process message for either attributes or extended attributes
   4902            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   \                     ??zclProcessInDiscAttrs_2:
   \   000079   8E82         MOV       DPL,R6
   \   00007B   8F83         MOV       DPH,R7
   \   00007D   A3           INC       DPTR
   \   00007E   A3           INC       DPTR
   \   00007F   A3           INC       DPTR
   \   000080   A3           INC       DPTR
   \   000081   A3           INC       DPTR
   \   000082   A3           INC       DPTR
   \   000083   A3           INC       DPTR
   \   000084   E0           MOVX      A,@DPTR
   \   000085   F8           MOV       R0,A
   \   000086   740C         MOV       A,#0xc
   \   000088   68           XRL       A,R0
   \   000089   700F         JNZ       ??zclProcessInDiscAttrs_3
   4903            {
   4904              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   \   00008B                ; Setup parameters for call to function zclProcessInDiscAttrsCmd
   \   00008B   A9..         MOV       R1,?V2
   \   00008D   AC..         MOV       R4,?V0
   \   00008F   AD..         MOV       R5,?V1
   \   000091   EE           MOV       A,R6
   \   000092   FA           MOV       R2,A
   \   000093   EF           MOV       A,R7
   \   000094   FB           MOV       R3,A
   \   000095   12....       LCALL     `??zclProcessInDiscAttrsCmd::?relay`; Banked call to: zclProcessInDiscAttrsCmd
   \   000098   8012         SJMP      ??zclProcessInDiscAttrs_4
   4905            }
   4906            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   \                     ??zclProcessInDiscAttrs_3:
   \   00009A   7415         MOV       A,#0x15
   \   00009C   68           XRL       A,R0
   \   00009D   700D         JNZ       ??zclProcessInDiscAttrs_4
   4907            {
   4908              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   \   00009F                ; Setup parameters for call to function zclProcessInDiscAttrsExtCmd
   \   00009F   A9..         MOV       R1,?V2
   \   0000A1   AC..         MOV       R4,?V0
   \   0000A3   AD..         MOV       R5,?V1
   \   0000A5   EE           MOV       A,R6
   \   0000A6   FA           MOV       R2,A
   \   0000A7   EF           MOV       A,R7
   \   0000A8   FB           MOV       R3,A
   \   0000A9   12....       LCALL     `??zclProcessInDiscAttrsExtCmd::?relay`; Banked call to: zclProcessInDiscAttrsExtCmd
   4909            }
   4910          
   4911            return TRUE;
   \                     ??zclProcessInDiscAttrs_4:
   \   0000AC   7901         MOV       R1,#0x1
   \   0000AE   740A         MOV       A,#0xa
   \   0000B0   02....       LJMP      ?Subroutine8 & 0xFFFF
   4912          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine212_0:
   \   000000   12....       LCALL     ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_519:
   \   000003   FC           MOV       R4,A
   \   000004   85..82       MOV       DPL,?V4
   \   000007   85..83       MOV       DPH,?V5
   \   00000A   12....       LCALL     ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_534:
   \   00000D   E5..         MOV       A,?V4
   \   00000F   12....       LCALL     ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_526:
   \   000012   35..         ADDC      A,?V5
   \   000014   F583         MOV       DPH,A
   \   000016   E0           MOVX      A,@DPTR
   \   000017   F9           MOV       R1,A
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine146:
   \   000000   12....       LCALL     ?Subroutine169 & 0xFFFF
   \                     ??CrossCallReturnLabel_529:
   \   000003   5401         ANL       A,#0x1
   \   000005   22           RET
   4913          
   4914          /*********************************************************************
   4915           * @fn      zclProcessInDiscAttrsCmd
   4916           *
   4917           * @brief   Process the Discover Attributes Command
   4918           *
   4919           * @param   pInMsg - incoming message to process
   4920           *
   4921           * @param   pDiscoverCmd - structure from requesting command
   4922           *
   4923           * @param   attrLenBuf - describes the amount of attributes to be processed
   4924           *
   4925           * @return  none
   4926           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   75..00       MOV       ?V2,#0x0
   \   000003   85..82       MOV       DPL,?V4
   \   000006   85..83       MOV       DPH,?V5
   \   000009   12....       LCALL     ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_365:
   \   00000C   85..82       MOV       DPL,?XSP + 0
   \   00000F   85..83       MOV       DPH,?XSP + 1
   \   000012                REQUIRE ??Subroutine191_0
   \   000012                ; // Fall through to label ??Subroutine191_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   740A         MOV       A,#0xa
   \   000002                REQUIRE ??Subroutine198_0
   \   000002                ; // Fall through to label ??Subroutine198_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4927          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   \                     zclProcessInDiscAttrsCmd:
   4928          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
   \   00000E   8C..         MOV       ?V4,R4
   \   000010   8D..         MOV       ?V5,R5
   \   000012   E9           MOV       A,R1
   \   000013   FE           MOV       R6,A
   4929            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4930            uint8 discComplete = TRUE;
   \   000014   7F01         MOV       R7,#0x1
   4931            zclAttrRec_t attrRec;
   4932            uint16 attrID;
   4933            uint8 i;
   4934          
   4935            // Allocate space for the response command
   4936            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4937                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   12....       LCALL     ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000019   39           ADDC      A,R1
   \   00001A   FB           MOV       R3,A
   \   00001B   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00001E   8A..         MOV       ?V0,R2
   \   000020   8B..         MOV       ?V1,R3
   4938            if ( pDiscoverRsp == NULL )
   \   000022   EA           MOV       A,R2
   \   000023   45..         ORL       A,?V1
   \   000025   7003         JNZ       $+5
   \   000027   02....       LJMP      ??zclProcessInDiscAttrsCmd_0 & 0xFFFF
   4939            {
   4940              return; // EMBEDDED RETURN
   4941            }
   4942          
   4943            if ( numAttrs != 0 )
   \   00002A   12....       LCALL     ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   00002D   7003         JNZ       $+5
   \   00002F   02....       LJMP      ??zclProcessInDiscAttrsCmd_1 & 0xFFFF
   4944            {
   4945              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   \   000032   12....       LCALL     ?Subroutine29 & 0xFFFF
   4946              {
   4947                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \                     ??CrossCallReturnLabel_430:
   \   000035   12....       LCALL     ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000038   12....       LCALL     ?XSTACK_DISP100_8
   \   00003B   88..         MOV       ?V10,R0
   \   00003D   89..         MOV       ?V11,R1
   \   00003F   78..         MOV       R0,#?V10
   \   000041   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000044   7402         MOV       A,#0x2
   \   000046   12....       LCALL     ?XSTACK_DISP100_8
   \   000049   88..         MOV       ?V10,R0
   \   00004B   89..         MOV       ?V11,R1
   \   00004D   78..         MOV       R0,#?V10
   \   00004F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000052   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_515:
   \   000055   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   000058   7404         MOV       A,#0x4
   \   00005A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005D   E9           MOV       A,R1
   \   00005E   6026         JZ        ??zclProcessInDiscAttrsCmd_2
   4948                {
   4949                  break; // should not happen, as numAttrs already calculated
   4950                }
   4951          
   4952                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   \   000060   E5..         MOV       A,?V2
   \   000062   75F003       MOV       B,#0x3
   \   000065   A4           MUL       AB
   \   000066   F8           MOV       R0,A
   \   000067   A9F0         MOV       R1,B
   \   000069   E5..         MOV       A,?V0
   \   00006B   28           ADD       A,R0
   \   00006C   F8           MOV       R0,A
   \   00006D   E5..         MOV       A,?V1
   \   00006F   39           ADDC      A,R1
   \   000070   F9           MOV       R1,A
   \   000071   7404         MOV       A,#0x4
   \   000073   12....       LCALL     ?XSTACK_DISP0_8
   \   000076   12....       LCALL     ?Subroutine35 & 0xFFFF
   4953                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   \                     ??CrossCallReturnLabel_297:
   \   000079   7406         MOV       A,#0x6
   \   00007B   12....       LCALL     ?XSTACK_DISP0_8
   \   00007E   12....       LCALL     ?Subroutine93 & 0xFFFF
   4954              }
   \                     ??CrossCallReturnLabel_159:
   \   000081   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000084   40AF         JC        ??CrossCallReturnLabel_430
   4955          
   4956              // Are there more attributes to be discovered?
   4957              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \                     ??zclProcessInDiscAttrsCmd_2:
   \   000086   12....       LCALL     ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000089   12....       LCALL     ?XSTACK_DISP100_8
   \   00008C   88..         MOV       ?V4,R0
   \   00008E   89..         MOV       ?V5,R1
   \   000090   78..         MOV       R0,#?V4
   \   000092   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000095   7402         MOV       A,#0x2
   \   000097   12....       LCALL     ?XSTACK_DISP100_8
   \   00009A   88..         MOV       ?V4,R0
   \   00009C   89..         MOV       ?V5,R1
   \   00009E   78..         MOV       R0,#?V4
   \   0000A0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A3   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0000A6   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   0000A9   7404         MOV       A,#0x4
   \   0000AB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000AE   E9           MOV       A,R1
   \   0000AF   6002         JZ        ??zclProcessInDiscAttrsCmd_1
   4958              {
   4959                discComplete = FALSE;
   \   0000B1   7F00         MOV       R7,#0x0
   4960              }
   4961            }
   4962          
   4963            pDiscoverRsp->discComplete = discComplete;
   \                     ??zclProcessInDiscAttrsCmd_1:
   \   0000B3   12....       LCALL     ?Subroutine13 & 0xFFFF
   4964            pDiscoverRsp->numAttr = numAttrs;
   4965          
   4966            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4967                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4968                                         true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_2:
   \   0000B6   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000B9   75..01       MOV       ?V4,#0x1
   \   0000BC   78..         MOV       R0,#?V4
   \   0000BE   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C1   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_510:
   \   0000C4   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000C7   78..         MOV       R0,#?V0
   \   0000C9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000CC   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0000CF   12....       LCALL     `??zcl_SendDiscoverAttrsRspCmd::?relay`; Banked call to: zcl_SendDiscoverAttrsRspCmd
   \   0000D2   7405         MOV       A,#0x5
   \   0000D4   12....       LCALL     ?DEALLOC_XSTACK8
   4969            zcl_mem_free( pDiscoverRsp );
   \   0000D7                ; Setup parameters for call to function osal_mem_free
   \   0000D7   AA..         MOV       R2,?V0
   \   0000D9   AB..         MOV       R3,?V1
   \   0000DB   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4970          
   4971            return;
   \                     ??zclProcessInDiscAttrsCmd_0:
   \   0000DE   02....       LJMP      ?Subroutine6 & 0xFFFF
   4972          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   85..82       MOV       DPL,?V8
   \   000003   85..83       MOV       DPH,?V9
   \   000006                REQUIRE ??Subroutine211_0
   \   000006                ; // Fall through to label ??Subroutine211_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   85..82       MOV       DPL,?V8
   \   000003   85..83       MOV       DPH,?V9
   \   000006                REQUIRE ??Subroutine212_0
   \   000006                ; // Fall through to label ??Subroutine212_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   E5..         MOV       A,?V6
   \   000002   2402         ADD       A,#0x2
   \   000004   F5..         MOV       ?V8,A
   \   000006   E4           CLR       A
   \   000007   35..         ADDC      A,?V7
   \   000009   F5..         MOV       ?V9,A
   \   00000B   EE           MOV       A,R6
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   12....       LCALL     ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_538:
   \   000003                ; Setup parameters for call to function zclFindNextAttrRec
   \   000003                ; Setup parameters for call to function zclFindNextAttrRec
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   85..82       MOV       DPL,?V6
   \   000003   85..83       MOV       DPH,?V7
   \   000006                REQUIRE ??Subroutine213_0
   \   000006                ; // Fall through to label ??Subroutine213_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   85..82       MOV       DPL,?V6
   \   000003   85..83       MOV       DPH,?V7
   \   000006   12....       LCALL     ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000009                ; Setup parameters for call to function zclFindNextAttrRec
   \   000009                ; Setup parameters for call to function zclFindNextAttrRec
   \   000009   7402         MOV       A,#0x2
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006   12....       LCALL     ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_500:
   \   000009   E5..         MOV       A,?V2
   \   00000B   12....       LCALL     ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_542:
   \   00000E   35..         ADDC      A,?V3
   \   000010   FB           MOV       R3,A
   \   000011   E5..         MOV       A,?V2
   \   000013   12....       LCALL     ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_520:
   \   000016   35..         ADDC      A,?V3
   \   000018   F583         MOV       DPH,A
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F9           MOV       R1,A
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   85..82       MOV       DPL,?V8
   \   000003   85..83       MOV       DPH,?V9
   \   000006   12....       LCALL     ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_518:
   \   000009   12....       LCALL     ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004   F0           MOVX      @DPTR,A
   \   000005   05..         INC       ?V2
   \   000007   85..82       MOV       DPL,?XSP + 0
   \   00000A   85..83       MOV       DPH,?XSP + 1
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   2F           ADD       A,R7
   \   00000F   F0           MOVX      @DPTR,A
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   3400         ADDC      A,#0x0
   \   000014   F0           MOVX      @DPTR,A
   \   000015   E5..         MOV       A,?V2
   \   000017   C3           CLR       C
   \   000018   9E           SUBB      A,R6
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   EF           MOV       A,R7
   \   000001   85..82       MOV       DPL,?V0
   \   000004   85..83       MOV       DPH,?V1
   \   000007   F0           MOVX      @DPTR,A
   \   000008   EE           MOV       A,R6
   \   000009   A3           INC       DPTR
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   12....       LCALL     ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_537:
   \   00000E                ; Setup parameters for call to function zcl_SendDiscoverAttrsRspCmd
   \   00000E                ; Setup parameters for call to function zcl_SendDiscoverAttrsExtRsp
   \   00000E   85..82       MOV       DPL,?V6
   \   000011   85..83       MOV       DPH,?V7
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   F5..         MOV       ?V4,A
   \   00001D   78..         MOV       R0,#?V4
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   FC           MOV       R4,A
   \   000001   85..82       MOV       DPL,?V2
   \   000004   85..83       MOV       DPH,?V3
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   FA           MOV       R2,A
   \   00000D   A3           INC       DPTR
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   FB           MOV       R3,A
   \   000010   E5..         MOV       A,?V2
   \   000012   2414         ADD       A,#0x14
   \   000014   F582         MOV       DPL,A
   \   000016   E4           CLR       A
   \   000017   35..         ADDC      A,?V3
   \   000019   F583         MOV       DPH,A
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F9           MOV       R1,A
   \   00001D   22           RET
   4973          
   4974          /*********************************************************************
   4975           * @fn      zclProcessInDiscAttrsExtCmd
   4976           *
   4977           * @brief   Process the Discover Attributes Extended Command
   4978           *
   4979           * @param   pInMsg - incoming message to process
   4980           *
   4981           * @param   pDiscoverCmd - structure from requesting command
   4982           *
   4983           * @param   attrLenBuf - describes the amount of attributes to be processed
   4984           *
   4985           * @return  none
   4986           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4987          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   \                     zclProcessInDiscAttrsExtCmd:
   4988          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
   \   00000E   8C..         MOV       ?V4,R4
   \   000010   8D..         MOV       ?V5,R5
   \   000012   E9           MOV       A,R1
   \   000013   FE           MOV       R6,A
   4989            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4990            uint8 discComplete = TRUE;
   \   000014   7F01         MOV       R7,#0x1
   4991            zclAttrRec_t attrRec;
   4992            uint16 attrID;
   4993            uint8 i;
   4994          
   4995              // Allocate space for the response command
   4996            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4997                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   F5..         MOV       ?V0,A
   \   000018   75..00       MOV       ?V1,#0x0
   \   00001B   7402         MOV       A,#0x2
   \   00001D   78..         MOV       R0,#?V0
   \   00001F   12....       LCALL     ?S_SHL
   \   000022   E5..         MOV       A,?V0
   \   000024   12....       LCALL     ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000027   35..         ADDC      A,?V1
   \   000029   FB           MOV       R3,A
   \   00002A   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002D   8A..         MOV       ?V0,R2
   \   00002F   8B..         MOV       ?V1,R3
   4998            if ( pDiscoverExtRsp == NULL )
   \   000031   EA           MOV       A,R2
   \   000032   45..         ORL       A,?V1
   \   000034   7003         JNZ       $+5
   \   000036   02....       LJMP      ??zclProcessInDiscAttrsExtCmd_0 & 0xFFFF
   4999            {
   5000              return; // EMBEDDED RETURN
   5001            }
   5002          
   5003          
   5004            if ( numAttrs != 0 )
   \   000039   12....       LCALL     ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   00003C   7003         JNZ       $+5
   \   00003E   02....       LJMP      ??zclProcessInDiscAttrsExtCmd_1 & 0xFFFF
   5005            {
   5006              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   \   000041   12....       LCALL     ?Subroutine29 & 0xFFFF
   5007              {
   5008                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \                     ??CrossCallReturnLabel_431:
   \   000044   12....       LCALL     ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000047   12....       LCALL     ?XSTACK_DISP100_8
   \   00004A   88..         MOV       ?V10,R0
   \   00004C   89..         MOV       ?V11,R1
   \   00004E   78..         MOV       R0,#?V10
   \   000050   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000053   7402         MOV       A,#0x2
   \   000055   12....       LCALL     ?XSTACK_DISP100_8
   \   000058   88..         MOV       ?V10,R0
   \   00005A   89..         MOV       ?V11,R1
   \   00005C   78..         MOV       R0,#?V10
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000061   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_516:
   \   000064   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   000067   7404         MOV       A,#0x4
   \   000069   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006C   E9           MOV       A,R1
   \   00006D   603B         JZ        ??zclProcessInDiscAttrsExtCmd_2
   5009                {
   5010                  break; // Should not happen, as numAttrs already calculated
   5011                }
   5012          
   5013                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   \   00006F   E5..         MOV       A,?V2
   \   000071   F5..         MOV       ?V4,A
   \   000073   75..00       MOV       ?V5,#0x0
   \   000076   7402         MOV       A,#0x2
   \   000078   78..         MOV       R0,#?V4
   \   00007A   12....       LCALL     ?S_SHL
   \   00007D   E5..         MOV       A,?V0
   \   00007F   25..         ADD       A,?V4
   \   000081   F8           MOV       R0,A
   \   000082   E5..         MOV       A,?V1
   \   000084   35..         ADDC      A,?V5
   \   000086   F9           MOV       R1,A
   \   000087   7404         MOV       A,#0x4
   \   000089   12....       LCALL     ?XSTACK_DISP0_8
   \   00008C   12....       LCALL     ?Subroutine35 & 0xFFFF
   5014                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   \                     ??CrossCallReturnLabel_298:
   \   00008F   7406         MOV       A,#0x6
   \   000091   12....       LCALL     ?XSTACK_DISP0_8
   \   000094   12....       LCALL     ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000097   F0           MOVX      @DPTR,A
   5015                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   \   000098   7407         MOV       A,#0x7
   \   00009A   12....       LCALL     ?XSTACK_DISP0_8
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   5407         ANL       A,#0x7
   \   0000A0   8882         MOV       DPL,R0
   \   0000A2   8983         MOV       DPH,R1
   \   0000A4   A3           INC       DPTR
   \   0000A5   12....       LCALL     ?Subroutine17 & 0xFFFF
   5016              }
   \                     ??CrossCallReturnLabel_10:
   \   0000A8   409A         JC        ??CrossCallReturnLabel_431
   5017          
   5018              // Are there more attributes to be discovered?
   5019              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   \                     ??zclProcessInDiscAttrsExtCmd_2:
   \   0000AA   12....       LCALL     ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   0000AD   12....       LCALL     ?XSTACK_DISP100_8
   \   0000B0   88..         MOV       ?V4,R0
   \   0000B2   89..         MOV       ?V5,R1
   \   0000B4   78..         MOV       R0,#?V4
   \   0000B6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B9   7402         MOV       A,#0x2
   \   0000BB   12....       LCALL     ?XSTACK_DISP100_8
   \   0000BE   88..         MOV       ?V4,R0
   \   0000C0   89..         MOV       ?V5,R1
   \   0000C2   78..         MOV       R0,#?V4
   \   0000C4   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C7   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000CA   12....       LCALL     `??zclFindNextAttrRec::?relay`; Banked call to: zclFindNextAttrRec
   \   0000CD   7404         MOV       A,#0x4
   \   0000CF   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000D2   E9           MOV       A,R1
   \   0000D3   6002         JZ        ??zclProcessInDiscAttrsExtCmd_1
   5020              {
   5021                discComplete = FALSE;
   \   0000D5   7F00         MOV       R7,#0x0
   5022              }
   5023            }
   5024          
   5025            pDiscoverExtRsp->discComplete = discComplete;
   \                     ??zclProcessInDiscAttrsExtCmd_1:
   \   0000D7   12....       LCALL     ?Subroutine13 & 0xFFFF
   5026            pDiscoverExtRsp->numAttr = numAttrs;
   5027          
   5028            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   5029                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   5030                                         true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_3:
   \   0000DA   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000DD   75..01       MOV       ?V4,#0x1
   \   0000E0   78..         MOV       R0,#?V4
   \   0000E2   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E5   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_511:
   \   0000E8   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000EB   78..         MOV       R0,#?V0
   \   0000ED   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000F0   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0000F3   12....       LCALL     `??zcl_SendDiscoverAttrsExtRsp::?relay`; Banked call to: zcl_SendDiscoverAttrsExtRsp
   \   0000F6   7405         MOV       A,#0x5
   \   0000F8   12....       LCALL     ?DEALLOC_XSTACK8
   5031          
   5032            zcl_mem_free( pDiscoverExtRsp );
   \   0000FB                ; Setup parameters for call to function osal_mem_free
   \   0000FB   AA..         MOV       R2,?V0
   \   0000FD   AB..         MOV       R3,?V1
   \   0000FF   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   5033          
   5034            return;
   \                     ??zclProcessInDiscAttrsExtCmd_0:
   \   000102   02....       LJMP      ?Subroutine6 & 0xFFFF
   5035          }
   5036          
   5037          /*********************************************************************
   5038           * @fn      zclProcessInDiscCmd
   5039           *
   5040           * @brief   Process the "Profile" Discover Command
   5041           *
   5042           * @param   pInMsg - incoming message to process
   5043           *
   5044           * @return  TRUE if command processed. FALSE, otherwise.
   5045           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   5046          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInDiscCmd:
   5047          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine120 & 0xFFFF
   5048            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   5049            zclDiscoverCmdsCmdRsp_t cmdRsp;
   5050            ZStatus_t status;
   5051            zclCommandRec_t cmdRec;
   5052            uint8 cmdID;
   5053            uint8 i;
   5054            uint8 j;
   5055          
   5056            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_214:
   \   00000D   12....       LCALL     ?Subroutine89 & 0xFFFF
   5057          
   5058            // Find out the number of commands supported within the specified range
   5059            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   \                     ??CrossCallReturnLabel_149:
   \   000010   75..00       MOV       ?V0,#0x0
   \   000013   85..82       MOV       DPL,?V4
   \   000016   F583         MOV       DPH,A
   \   000018   12....       LCALL     ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   00001B   EE           MOV       A,R6
   \   00001C   2407         ADD       A,#0x7
   \   00001E   F5..         MOV       ?V8,A
   \   000020   E4           CLR       A
   \   000021   3F           ADDC      A,R7
   \   000022   F5..         MOV       ?V9,A
   \   000024   EE           MOV       A,R6
   \   000025   2402         ADD       A,#0x2
   \   000027   F5..         MOV       ?V6,A
   \   000029   E4           CLR       A
   \   00002A   3F           ADDC      A,R7
   \   00002B   F5..         MOV       ?V7,A
   \   00002D   800B         SJMP      ??zclProcessInDiscCmd_0
   \                     ??zclProcessInDiscCmd_1:
   \   00002F   05..         INC       ?V0
   \   000031   85..82       MOV       DPL,?XSP + 0
   \   000034   85..83       MOV       DPH,?XSP + 1
   \   000037   E0           MOVX      A,@DPTR
   \   000038   04           INC       A
   \   000039   F0           MOVX      @DPTR,A
   \                     ??zclProcessInDiscCmd_0:
   \   00003A   85..82       MOV       DPL,?V4
   \   00003D   85..83       MOV       DPH,?V5
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   F8           MOV       R0,A
   \   000043   E5..         MOV       A,?V0
   \   000045   C3           CLR       C
   \   000046   98           SUBB      A,R0
   \   000047   502B         JNC       ??zclProcessInDiscCmd_2
   5060            {
   5061              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   \   000049   12....       LCALL     ?Subroutine63 & 0xFFFF
   5062              {
   5063                break;  // Command not supported
   5064              }
   5065            }
   \                     ??CrossCallReturnLabel_99:
   \   00004C   12....       LCALL     ?XSTACK_DISP100_8
   \   00004F   88..         MOV       ?V10,R0
   \   000051   89..         MOV       ?V11,R1
   \   000053   78..         MOV       R0,#?V10
   \   000055   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000058   7402         MOV       A,#0x2
   \   00005A   12....       LCALL     ?XSTACK_DISP100_8
   \   00005D   88..         MOV       ?V10,R0
   \   00005F   89..         MOV       ?V11,R1
   \   000061   78..         MOV       R0,#?V10
   \   000063   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000066   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000069   12....       LCALL     `??zclFindNextCmdRec::?relay`; Banked call to: zclFindNextCmdRec
   \   00006C   7404         MOV       A,#0x4
   \   00006E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000071   E9           MOV       A,R1
   \   000072   70BB         JNZ       ??zclProcessInDiscCmd_1
   5066          
   5067            // Allocate space for the response command
   5068            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   \                     ??zclProcessInDiscCmd_2:
   \   000074                ; Setup parameters for call to function osal_mem_alloc
   \   000074   AA..         MOV       R2,?V0
   \   000076   7B00         MOV       R3,#0x0
   \   000078   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00007B   8A..         MOV       ?V2,R2
   \   00007D   8B..         MOV       ?V3,R3
   \   00007F   A8..         MOV       R0,?V2
   \   000081   A9..         MOV       R1,?V3
   \   000083   7404         MOV       A,#0x4
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   12....       LCALL     ??Subroutine191_0 & 0xFFFF
   5069          
   5070            if ( cmdRsp.pCmdID == NULL )
   \                     ??CrossCallReturnLabel_429:
   \   00008B   E8           MOV       A,R0
   \   00008C   49           ORL       A,R1
   \   00008D   7003         JNZ       $+5
   \   00008F   02....       LJMP      ??zclProcessInDiscCmd_3 & 0xFFFF
   5071            {
   5072              return FALSE; // EMBEDDED RETURN
   5073            }
   5074          
   5075            if ( i != 0 )
   \   000092   E5..         MOV       A,?V0
   \   000094   6066         JZ        ??zclProcessInDiscCmd_4
   5076            {
   5077              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   \   000096   75..00       MOV       ?V1,#0x0
   \   000099   85..82       MOV       DPL,?V4
   \   00009C   85..83       MOV       DPH,?V5
   \   00009F   12....       LCALL     ?Subroutine107 & 0xFFFF
   5078              {
   5079                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   \                     ??CrossCallReturnLabel_184:
   \   0000A2   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   0000A5   12....       LCALL     ?XSTACK_DISP100_8
   \   0000A8   88..         MOV       ?V4,R0
   \   0000AA   89..         MOV       ?V5,R1
   \   0000AC   78..         MOV       R0,#?V4
   \   0000AE   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B1   7402         MOV       A,#0x2
   \   0000B3   12....       LCALL     ?XSTACK_DISP100_8
   \   0000B6   88..         MOV       ?V4,R0
   \   0000B8   89..         MOV       ?V5,R1
   \   0000BA   78..         MOV       R0,#?V4
   \   0000BC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BF   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0000C2   12....       LCALL     `??zclFindNextCmdRec::?relay`; Banked call to: zclFindNextCmdRec
   \   0000C5   7404         MOV       A,#0x4
   \   0000C7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000CA   E9           MOV       A,R1
   \   0000CB   602F         JZ        ??zclProcessInDiscCmd_4
   5080                {
   5081                  break; // Attribute not supported
   5082                }
   5083          
   5084                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   \   0000CD   7408         MOV       A,#0x8
   \   0000CF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D2   E0           MOVX      A,@DPTR
   \   0000D3   C0E0         PUSH      A
   \   0000D5   A8..         MOV       R0,?V1
   \   0000D7   7404         MOV       A,#0x4
   \   0000D9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DC   E0           MOVX      A,@DPTR
   \   0000DD   28           ADD       A,R0
   \   0000DE   FA           MOV       R2,A
   \   0000DF   A3           INC       DPTR
   \   0000E0   E0           MOVX      A,@DPTR
   \   0000E1   3400         ADDC      A,#0x0
   \   0000E3   8A82         MOV       DPL,R2
   \   0000E5   F583         MOV       DPH,A
   \   0000E7   D0E0         POP       A
   \   0000E9   F0           MOVX      @DPTR,A
   5085              }
   \   0000EA   05..         INC       ?V1
   \   0000EC   85..82       MOV       DPL,?XSP + 0
   \   0000EF   85..83       MOV       DPH,?XSP + 1
   \   0000F2   E0           MOVX      A,@DPTR
   \   0000F3   04           INC       A
   \   0000F4   F0           MOVX      @DPTR,A
   \   0000F5   E5..         MOV       A,?V1
   \   0000F7   C3           CLR       C
   \   0000F8   95..         SUBB      A,?V0
   \   0000FA   40A6         JC        ??CrossCallReturnLabel_184
   5086            }
   5087          
   5088            // Are there more commands to be discovered?
   5089            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   \                     ??zclProcessInDiscCmd_4:
   \   0000FC   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   0000FF   12....       LCALL     ?XSTACK_DISP100_8
   \   000102   88..         MOV       ?V4,R0
   \   000104   89..         MOV       ?V5,R1
   \   000106   78..         MOV       R0,#?V4
   \   000108   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00010B   7402         MOV       A,#0x2
   \   00010D   12....       LCALL     ?XSTACK_DISP100_8
   \   000110   88..         MOV       ?V4,R0
   \   000112   89..         MOV       ?V5,R1
   \   000114   78..         MOV       R0,#?V4
   \   000116   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000119   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   00011C   12....       LCALL     `??zclFindNextCmdRec::?relay`; Banked call to: zclFindNextCmdRec
   \   00011F   7404         MOV       A,#0x4
   \   000121   12....       LCALL     ?DEALLOC_XSTACK8
   \   000124   E9           MOV       A,R1
   \   000125   6008         JZ        ??zclProcessInDiscCmd_5
   5090            {
   5091              cmdRsp.discComplete = FALSE;
   \   000127   7401         MOV       A,#0x1
   \   000129   12....       LCALL     ?XSTACK_DISP0_8
   \   00012C   E4           CLR       A
   \   00012D   8007         SJMP      ??zclProcessInDiscCmd_6
   5092            }
   5093            else
   5094            {
   5095              cmdRsp.discComplete = TRUE;
   \                     ??zclProcessInDiscCmd_5:
   \   00012F   7401         MOV       A,#0x1
   \   000131   12....       LCALL     ?XSTACK_DISP0_8
   \   000134   7401         MOV       A,#0x1
   \                     ??zclProcessInDiscCmd_6:
   \   000136   F0           MOVX      @DPTR,A
   5096            }
   5097          
   5098            // pass the command requested
   5099            cmdRsp.cmdType = pInMsg->hdr.commandID;
   \   000137   85..82       MOV       DPL,?V8
   \   00013A   85..83       MOV       DPH,?V9
   \   00013D   E0           MOVX      A,@DPTR
   \   00013E   C0E0         PUSH      A
   \   000140   7402         MOV       A,#0x2
   \   000142   12....       LCALL     ?XSTACK_DISP0_8
   \   000145   D0E0         POP       A
   \   000147   F0           MOVX      @DPTR,A
   5100          
   5101            // store number of commands returned
   5102            cmdRsp.numCmd = j;
   \   000148   7403         MOV       A,#0x3
   \   00014A   12....       LCALL     ?XSTACK_DISP0_8
   \   00014D   E5..         MOV       A,?V1
   \   00014F   12....       LCALL     ?Subroutine25 & 0xFFFF
   5103          
   5104            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   5105                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   5106                                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_28:
   \   000152   F5..         MOV       ?V0,A
   \   000154   A3           INC       DPTR
   \   000155   E0           MOVX      A,@DPTR
   \   000156   F5..         MOV       ?V1,A
   \   000158                ; Setup parameters for call to function zcl_SendDiscoverCmdsRspCmd
   \   000158   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_491:
   \   00015B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00015E   75..01       MOV       ?V2,#0x1
   \   000161   78..         MOV       R0,#?V2
   \   000163   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000166   85..82       MOV       DPL,?V6
   \   000169   85..83       MOV       DPH,?V7
   \   00016C   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   00016F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000172   7404         MOV       A,#0x4
   \   000174   12....       LCALL     ?XSTACK_DISP100_8
   \   000177   88..         MOV       ?V2,R0
   \   000179   89..         MOV       ?V3,R1
   \   00017B   78..         MOV       R0,#?V2
   \   00017D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000180   85..82       MOV       DPL,?V0
   \   000183   85..83       MOV       DPH,?V1
   \   000186   12....       LCALL     ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_472:
   \   000189   E5..         MOV       A,?V0
   \   00018B   12....       LCALL     ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_541:
   \   00018E   35..         ADDC      A,?V1
   \   000190   FB           MOV       R3,A
   \   000191   E5..         MOV       A,?V0
   \   000193   12....       LCALL     ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000196   35..         ADDC      A,?V1
   \   000198   F583         MOV       DPH,A
   \   00019A   E0           MOVX      A,@DPTR
   \   00019B   F9           MOV       R1,A
   \   00019C   12....       LCALL     `??zcl_SendDiscoverCmdsRspCmd::?relay`; Banked call to: zcl_SendDiscoverCmdsRspCmd
   \   00019F   7405         MOV       A,#0x5
   \   0001A1   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001A4   E9           MOV       A,R1
   \   0001A5   FE           MOV       R6,A
   5107          
   5108            zcl_mem_free( cmdRsp.pCmdID );
   \   0001A6                ; Setup parameters for call to function osal_mem_free
   \   0001A6   7404         MOV       A,#0x4
   \   0001A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001AB   12....       LCALL     ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_449:
   \   0001AE   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   5109          
   5110            if ( status == ZSuccess )
   \   0001B1   EE           MOV       A,R6
   \   0001B2   7004         JNZ       ??zclProcessInDiscCmd_3
   5111            {
   5112              return TRUE;
   \   0001B4   7901         MOV       R1,#0x1
   \   0001B6   8002         SJMP      ??zclProcessInDiscCmd_7
   5113            }
   5114            else
   5115            {
   5116              return FALSE;
   \                     ??zclProcessInDiscCmd_3:
   \   0001B8   7900         MOV       R1,#0x0
   5117            }
   \                     ??zclProcessInDiscCmd_7:
   \   0001BA   02....       LJMP      ?Subroutine6 & 0xFFFF
   5118          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   12....       LCALL     ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004   12....       LCALL     ??Subroutine213_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_536:
   \   000007                ; Setup parameters for call to function zclFindNextCmdRec
   \   000007                ; Setup parameters for call to function zclFindNextCmdRec
   \   000007                ; Setup parameters for call to function zclFindNextCmdRec
   \   000007   7406         MOV       A,#0x6
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   85..82       MOV       DPL,?V6
   \   000003   85..83       MOV       DPH,?V7
   \   000006   12....       LCALL     ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_517:
   \   000009   FD           MOV       R5,A
   \   00000A   85..82       MOV       DPL,?V8
   \   00000D   85..83       MOV       DPH,?V9
   \   000010   E0           MOVX      A,@DPTR
   \   000011   12....       LCALL     ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   000014   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_radius>`:
   \   000000   1E           DB 30

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_32:
   \   000000   32000000     DD 50

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_event_loop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerForMsgExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsgExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_addExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_addExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getExternalFoundationHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getExternalFoundationHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_HandleExternal::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getRawAFMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_getParsedTransSeqNum::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerPlugin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerCmdList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerCmdList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerAttrList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerClusterOptionList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerValidateAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_registerReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_DeviceOperational::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendCommand::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendReadRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRequest::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendWriteRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDiscoverCmdsCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDiscoverCmdsCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDiscoverCmdsRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDiscoverCmdsRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDiscoverAttrsCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDiscoverAttrsCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDiscoverAttrsRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDiscoverAttrsRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDiscoverAttrsExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDiscoverAttrsExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_SendDiscoverAttrsExtRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDiscoverAttrsExtRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ProcessMessageMSG::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclBuildHdr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindCmdRecsList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindCmdRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindCmdRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindCmdRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRecsList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindAttrRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetReadWriteCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAuthorizeCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetClusterOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSetSecurityOption::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindNextCmdRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindNextCmdRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclFindNextAttrRec::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindNextAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclSerializeData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetDataTypeLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLength::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zcl_ReadAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGetAttrDataLengthUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclReadAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclWriteAttrDataUsingCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclAuthorizeWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInReadRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInWriteRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDefaultRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDiscAttrsCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDiscAttrsCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDiscAttrsRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDiscAttrsRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDiscCmdsCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDiscCmdsCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDiscCmdsRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDiscCmdsRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclParseInDiscAttrsExtRspCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDiscAttrsExtRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInReadCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclRevertWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInWriteUndividedCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInDiscAttrs::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInDiscAttrs

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInDiscAttrsCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInDiscAttrsCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInDiscAttrsExtCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInDiscAttrsExtCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclProcessInDiscCmd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInDiscCmd
   5119          
   5120          #endif // ZCL_DISCOVER
   5121          
   5122          
   5123          /*********************************************************************
   5124          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     29   zclAuthorizeWrite
        0     14   -> zclGetAuthorizeCB
      1     39   zclBuildHdr
      2     54   zclFindAttrRec
        0     16   -> zclFindAttrRecsList
      2     16   zclFindAttrRecsList
      0     19   zclFindClusterOption
      2     16   zclFindCmdRec
        0     14   -> zclFindCmdRecsList
      2     16   zclFindCmdRecsList
      0     50   zclFindNextAttrRec
        0     16   -> zclFindAttrRecsList
      1     50   zclFindNextCmdRec
        0     16   -> zclFindCmdRecsList
      0     45   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     58   zclGetAttrDataLengthUsingCB
        0     18   -> zclGetReadWriteCB
      0     42   zclGetAuthorizeCB
        0     10   -> zclFindAttrRecsList
      0     46   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0      9   zclGetDataTypeLength
      0     28   zclGetReadWriteCB
        0     10   -> zclFindAttrRecsList
      1     48   zclParseHdr
        0     12   -> osal_memset
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     10   zclParseInDiscAttrsCmd
        0     10   -> osal_mem_alloc
      1     14   zclParseInDiscAttrsExtRspCmd
        0     14   -> osal_mem_alloc
      1     12   zclParseInDiscAttrsRspCmd
        0     12   -> osal_mem_alloc
      1     10   zclParseInDiscCmdsCmd
        0     10   -> osal_mem_alloc
      1     12   zclParseInDiscCmdsRspCmd
        0     12   -> osal_mem_alloc
      1     12   zclParseInReadCmd
        0     12   -> osal_mem_alloc
      1     25   zclParseInReadRspCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInWriteCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      0     30   zclProcessInDiscAttrs
        0     30   -> zclFindNextAttrRec
        0     26   -> zclProcessInDiscAttrsCmd
        0     26   -> zclProcessInDiscAttrsExtCmd
      1     61   zclProcessInDiscAttrsCmd
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     34   -> zclFindNextAttrRec
        0     35   -> zcl_SendDiscoverAttrsRspCmd
      1     61   zclProcessInDiscAttrsExtCmd
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     34   -> zclFindNextAttrRec
        0     35   -> zcl_SendDiscoverAttrsExtRsp
      1     35   zclProcessInDiscCmd
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     34   -> zclFindNextCmdRec
        0     35   -> zcl_SendDiscoverCmdsRspCmd
      1     37   zclProcessInReadCmd
        0     32   -> osal_mem_alloc
        0     32   -> osal_mem_free
        0     34   -> zclFindAttrRec
        0     32   -> zclGetAuthorizeCB
        0     37   -> zcl_SendReadRsp
      1     39   zclProcessInWriteCmd
        0     34   -> bdb_ZclIdentifyCmdInd
        0     34   -> osal_mem_alloc
        0     34   -> osal_mem_free
        0     37   -> osal_memcpy
        0     36   -> zclFindAttrRec
        0     36   -> zclWriteAttrData
        0     36   -> zclWriteAttrDataUsingCB
        0     39   -> zcl_SendWriteRsp
      1     41   zclProcessInWriteUndividedCmd
        0     36   -> osal_mem_alloc
        0     36   -> osal_mem_free
        0     38   -> zclFindAttrRec
        0     36   -> zclGetAttrDataLength
        0     36   -> zclGetAttrDataLengthUsingCB
        0     38   -> zclReadAttrData
        0     40   -> zclReadAttrDataUsingCB
        0     38   -> zclRevertWriteUndividedCmd
        0     38   -> zclWriteAttrData
        0     38   -> zclWriteAttrDataUsingCB
        0     41   -> zcl_SendWriteRsp
      0     56   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      0     60   zclReadAttrDataUsingCB
        0     16   -> zclGetReadWriteCB
      0     69   zclRevertWriteUndividedCmd
        0     31   -> osal_memcpy
        0     30   -> zclFindAttrRec
        0     28   -> zclGetAttrDataLength
        0     30   -> zclWriteAttrDataUsingCB
      1     43   zclSerializeData
        0     19   -> osal_buffer_uint32
        0     18   -> osal_memcpy
      0     46   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      0     56   zclWriteAttrData
        0     18   -> osal_memcpy
        0     15   -> zclAuthorizeWrite
        0     15   -> zclGetAttrDataLength
      0     56   zclWriteAttrDataUsingCB
        0     14   -> zclAuthorizeWrite
        0     14   -> zclGetReadWriteCB
      0     61   zcl_DeviceOperational
        0     23   -> zclFindAttrRec
        0     23   -> zclReadAttrData
      1     12   zcl_HandleExternal
        0     12   -> osal_msg_allocate
        0     12   -> osal_msg_send
        0     12   -> zcl_getExternalFoundationHandler
      2      0   zcl_Init
      1    135   zcl_ProcessMessageMSG
        0     36   -> afFindEndPointDesc
        0     36   -> osal_mem_free
        0     36   -> zclGetClusterOption
        0     36   -> zclParseHdr
        0     36   -> zclSetSecurityOption
        0     38   -> zcl_DeviceOperational
        0     43   -> zcl_SendDefaultRspCmd
      0     32   zcl_ReadAttrData
        0     26   -> zclFindAttrRec
        0     26   -> zclReadAttrData
        0     28   -> zclReadAttrDataUsingCB
      1    142   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     30   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     66   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      1     32   zcl_SendDiscoverAttrsCmd
        0     16   -> osal_mem_alloc
        0     16   -> osal_mem_free
        0     27   -> zcl_SendCommand
      1     31   zcl_SendDiscoverAttrsExt
        0     26   -> zcl_SendCommand
      1     70   zcl_SendDiscoverAttrsExtRsp
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     35   -> zcl_SendCommand
      1     70   zcl_SendDiscoverAttrsRspCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     35   -> zcl_SendCommand
      1     31   zcl_SendDiscoverCmdsCmd
        0     25   -> zcl_SendCommand
      1     68   zcl_SendDiscoverCmdsRspCmd
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     33   -> zcl_SendCommand
      1     36   zcl_SendRead
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     72   zcl_SendReadRsp
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetAttrDataLengthUsingCB
        0     28   -> zclReadAttrDataUsingCB
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     39   zcl_SendWriteRequest
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> zclGetAttrDataLength
        0     22   -> zclSerializeData
        0     33   -> zcl_SendCommand
      1     72   zcl_SendWriteRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     19   zcl_addExternalFoundationHandler
        0     10   -> osal_mem_alloc
        0     10   -> osal_mem_free
      0    103   zcl_event_loop
        0     92   -> bdb_getZCLFrameCounter
        0     92   -> gp_GetHeadNotificationMsg
        0     92   -> gp_GetPHeadNotification
        0     92   -> gp_NotificationMsgClean
        0     94   -> gp_getProxyTableByGpId
        0     95   -> osal_memcpy
        0     92   -> osal_msg_deallocate
        0     92   -> osal_msg_receive
        0     92   -> osal_msg_send
        0     95   -> osal_revmemcpy
        0     96   -> osal_start_timerEx
        0     92   -> zcl_ProcessMessageMSG
        0    103   -> zcl_SendCommand
        0     92   -> zcl_getExternalFoundationHandler
      2     92   zcl_getExternalFoundationHandler
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerAttrList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerCmdList
        0     12   -> osal_mem_alloc
      0      9   zcl_registerForMsg
        0      9   -> zcl_addExternalFoundationHandler
      0      9   zcl_registerForMsgExt
        0      9   -> zcl_addExternalFoundationHandler
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_radius>
       2  ??Subroutine170_0
       6  ??Subroutine171_0
       5  ??Subroutine172_0
       6  ??Subroutine173_0
       5  ??Subroutine174_0
       5  ??Subroutine175_0
       8  ??Subroutine176_0
       8  ??Subroutine177_0
       5  ??Subroutine178_0
       5  ??Subroutine179_0
       5  ??Subroutine180_0
       2  ??Subroutine181_0
       6  ??Subroutine182_0
       4  ??Subroutine183_0
       6  ??Subroutine184_0
       4  ??Subroutine185_0
       8  ??Subroutine186_0
       6  ??Subroutine187_0
       6  ??Subroutine188_0
       5  ??Subroutine189_0
       7  ??Subroutine190_0
       1  ??Subroutine191_0
       5  ??Subroutine192_0
       8  ??Subroutine193_0
       1  ??Subroutine194_0
       3  ??Subroutine195_0
       4  ??Subroutine196_0
       6  ??Subroutine197_0
       3  ??Subroutine198_0
       5  ??Subroutine199_0
       5  ??Subroutine200_0
       8  ??Subroutine201_0
       2  ??Subroutine202_0
       4  ??Subroutine203_0
       4  ??Subroutine204_0
       9  ??Subroutine205_0
       6  ??Subroutine206_0
       6  ??Subroutine207_0
      16  ??Subroutine208_0
       6  ??Subroutine209_0
       6  ??Subroutine210_0
       8  ??Subroutine211_0
      25  ??Subroutine212_0
       8  ??Subroutine213_0
       5  ??Subroutine214_0
       7  ?Subroutine0
       3  ?Subroutine1
       5  ?Subroutine10
      21  ?Subroutine100
      16  ?Subroutine101
       6  ?Subroutine102
       4  ?Subroutine103
       9  ?Subroutine104
       4  ?Subroutine105
       8  ?Subroutine106
       4  ?Subroutine107
       4  ?Subroutine108
       9  ?Subroutine109
       5  ?Subroutine11
       4  ?Subroutine110
      16  ?Subroutine111
      12  ?Subroutine112
      13  ?Subroutine113
       6  ?Subroutine114
      12  ?Subroutine115
      12  ?Subroutine116
      10  ?Subroutine117
      12  ?Subroutine118
       4  ?Subroutine119
      13  ?Subroutine12
       7  ?Subroutine120
      14  ?Subroutine121
      22  ?Subroutine122
      12  ?Subroutine123
       9  ?Subroutine124
       9  ?Subroutine125
      18  ?Subroutine126
       9  ?Subroutine127
      14  ?Subroutine128
      10  ?Subroutine129
      32  ?Subroutine13
      12  ?Subroutine130
      15  ?Subroutine131
       6  ?Subroutine132
       8  ?Subroutine133
       5  ?Subroutine134
      11  ?Subroutine135
       9  ?Subroutine136
       9  ?Subroutine137
       6  ?Subroutine138
       8  ?Subroutine139
      12  ?Subroutine14
      30  ?Subroutine140
       9  ?Subroutine141
       4  ?Subroutine142
       6  ?Subroutine143
       3  ?Subroutine144
       4  ?Subroutine145
       6  ?Subroutine146
      13  ?Subroutine147
       5  ?Subroutine148
       8  ?Subroutine149
      19  ?Subroutine15
       8  ?Subroutine150
      16  ?Subroutine151
       5  ?Subroutine152
      10  ?Subroutine153
       4  ?Subroutine154
       5  ?Subroutine155
       5  ?Subroutine156
       9  ?Subroutine157
       9  ?Subroutine158
       5  ?Subroutine159
       1  ?Subroutine16
      14  ?Subroutine160
       6  ?Subroutine161
       2  ?Subroutine162
       1  ?Subroutine163
      10  ?Subroutine164
       7  ?Subroutine165
       8  ?Subroutine166
       5  ?Subroutine167
       6  ?Subroutine168
       7  ?Subroutine169
      26  ?Subroutine17
       6  ?Subroutine18
      13  ?Subroutine19
       5  ?Subroutine2
      11  ?Subroutine20
      13  ?Subroutine21
       4  ?Subroutine22
       8  ?Subroutine23
       8  ?Subroutine24
       5  ?Subroutine25
       6  ?Subroutine26
       7  ?Subroutine27
       7  ?Subroutine28
      18  ?Subroutine29
       3  ?Subroutine3
       4  ?Subroutine30
       7  ?Subroutine31
       5  ?Subroutine32
      11  ?Subroutine33
       8  ?Subroutine34
       3  ?Subroutine35
      12  ?Subroutine36
       6  ?Subroutine37
       4  ?Subroutine38
       6  ?Subroutine39
       5  ?Subroutine4
      21  ?Subroutine40
       6  ?Subroutine41
       3  ?Subroutine42
       5  ?Subroutine43
      13  ?Subroutine44
      29  ?Subroutine45
       4  ?Subroutine46
       6  ?Subroutine47
       8  ?Subroutine48
       4  ?Subroutine49
       3  ?Subroutine5
      18  ?Subroutine50
      22  ?Subroutine51
       9  ?Subroutine52
      12  ?Subroutine53
      12  ?Subroutine54
       9  ?Subroutine55
       7  ?Subroutine56
       6  ?Subroutine57
      10  ?Subroutine58
       6  ?Subroutine59
       2  ?Subroutine6
       6  ?Subroutine60
      18  ?Subroutine61
       2  ?Subroutine62
      10  ?Subroutine63
      14  ?Subroutine64
      21  ?Subroutine65
       6  ?Subroutine66
       9  ?Subroutine67
       8  ?Subroutine68
      12  ?Subroutine69
       4  ?Subroutine7
       5  ?Subroutine70
      14  ?Subroutine71
       6  ?Subroutine72
      13  ?Subroutine73
       5  ?Subroutine74
      18  ?Subroutine75
       6  ?Subroutine76
       1  ?Subroutine77
      10  ?Subroutine78
       9  ?Subroutine79
       3  ?Subroutine8
       7  ?Subroutine80
      12  ?Subroutine81
       6  ?Subroutine82
       8  ?Subroutine83
       4  ?Subroutine84
       4  ?Subroutine85
       8  ?Subroutine86
       6  ?Subroutine87
      12  ?Subroutine88
       4  ?Subroutine89
       5  ?Subroutine9
       8  ?Subroutine90
       2  ?Subroutine91
       7  ?Subroutine92
       4  ?Subroutine93
       6  ?Subroutine94
       5  ?Subroutine95
       4  ?Subroutine96
       4  ?Subroutine97
      14  ?Subroutine98
      14  ?Subroutine99
       4  __Constant_32
       2  attrList
       2  clusterOptionList
       2  externalEndPointHandlerList
       2  gpCmdList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      59  zclAuthorizeWrite
       6  zclAuthorizeWrite::?relay
      99  zclBuildHdr
       6  zclBuildHdr::?relay
      92  zclCmdTable
     129  zclFindAttrRec
       6  zclFindAttrRec::?relay
      37  zclFindAttrRecsList
       6  zclFindAttrRecsList::?relay
     102  zclFindClusterOption
       6  zclFindClusterOption::?relay
     109  zclFindCmdRec
       6  zclFindCmdRec::?relay
      37  zclFindCmdRecsList
       6  zclFindCmdRecsList::?relay
     187  zclFindNextAttrRec
       6  zclFindNextAttrRec::?relay
     243  zclFindNextCmdRec
       6  zclFindNextCmdRec::?relay
      63  zclGetAttrDataLength
       6  zclGetAttrDataLength::?relay
     101  zclGetAttrDataLengthUsingCB
       6  zclGetAttrDataLengthUsingCB::?relay
      30  zclGetAuthorizeCB
       6  zclGetAuthorizeCB::?relay
      26  zclGetClusterOption
       6  zclGetClusterOption::?relay
     166  zclGetDataTypeLength
       6  zclGetDataTypeLength::?relay
      30  zclGetReadWriteCB
       6  zclGetReadWriteCB::?relay
     221  zclParseHdr
       6  zclParseHdr::?relay
      21  zclParseInDefaultRspCmd
       6  zclParseInDefaultRspCmd::?relay
      45  zclParseInDiscAttrsCmd
       6  zclParseInDiscAttrsCmd::?relay
     140  zclParseInDiscAttrsExtRspCmd
       6  zclParseInDiscAttrsExtRspCmd::?relay
      91  zclParseInDiscAttrsRspCmd
       6  zclParseInDiscAttrsRspCmd::?relay
      21  zclParseInDiscCmdsCmd
       6  zclParseInDiscCmdsCmd::?relay
      91  zclParseInDiscCmdsRspCmd
       6  zclParseInDiscCmdsRspCmd::?relay
     105  zclParseInReadCmd
       6  zclParseInReadCmd::?relay
     346  zclParseInReadRspCmd
       6  zclParseInReadRspCmd::?relay
     328  zclParseInWriteCmd
       6  zclParseInWriteCmd::?relay
     126  zclParseInWriteRspCmd
       6  zclParseInWriteRspCmd::?relay
     179  zclProcessInDiscAttrs
       6  zclProcessInDiscAttrs::?relay
     225  zclProcessInDiscAttrsCmd
       6  zclProcessInDiscAttrsCmd::?relay
     261  zclProcessInDiscAttrsExtCmd
       6  zclProcessInDiscAttrsExtCmd::?relay
     445  zclProcessInDiscCmd
       6  zclProcessInDiscCmd::?relay
     446  zclProcessInReadCmd
       6  zclProcessInReadCmd::?relay
     569  zclProcessInWriteCmd
       6  zclProcessInWriteCmd::?relay
     778  zclProcessInWriteUndividedCmd
       6  zclProcessInWriteUndividedCmd::?relay
     109  zclReadAttrData
       6  zclReadAttrData::?relay
      93  zclReadAttrDataUsingCB
       6  zclReadAttrDataUsingCB::?relay
     249  zclRevertWriteUndividedCmd
       6  zclRevertWriteUndividedCmd::?relay
     386  zclSerializeData
       6  zclSerializeData::?relay
      45  zclSetSecurityOption
       6  zclSetSecurityOption::?relay
     150  zclWriteAttrData
       6  zclWriteAttrData::?relay
     104  zclWriteAttrDataUsingCB
       6  zclWriteAttrDataUsingCB::?relay
     123  zcl_DeviceOperational
       6  zcl_DeviceOperational::?relay
     184  zcl_HandleExternal
       6  zcl_HandleExternal::?relay
       1  zcl_InSeqNum
      12  zcl_Init
       6  zcl_Init::?relay
    1075  zcl_ProcessMessageMSG
       6  zcl_ProcessMessageMSG::?relay
     131  zcl_ReadAttrData
       6  zcl_ReadAttrData::?relay
     421  zcl_SendCommand
       6  zcl_SendCommand::?relay
     129  zcl_SendDefaultRspCmd
       6  zcl_SendDefaultRspCmd::?relay
     172  zcl_SendDiscoverAttrsCmd
       6  zcl_SendDiscoverAttrsCmd::?relay
     144  zcl_SendDiscoverAttrsExt
       6  zcl_SendDiscoverAttrsExt::?relay
     256  zcl_SendDiscoverAttrsExtRsp
       6  zcl_SendDiscoverAttrsExtRsp::?relay
     220  zcl_SendDiscoverAttrsRspCmd
       6  zcl_SendDiscoverAttrsRspCmd::?relay
     199  zcl_SendDiscoverCmdsCmd
       6  zcl_SendDiscoverCmdsCmd::?relay
     322  zcl_SendDiscoverCmdsRspCmd
       6  zcl_SendDiscoverCmdsRspCmd::?relay
     196  zcl_SendRead
       6  zcl_SendRead::?relay
     442  zcl_SendReadRsp
       6  zcl_SendReadRsp::?relay
     319  zcl_SendWriteRequest
       6  zcl_SendWriteRequest::?relay
     243  zcl_SendWriteRsp
       6  zcl_SendWriteRsp::?relay
       1  zcl_TaskID
       2  zcl_ValidateAttrDataCB
     132  zcl_addExternalFoundationHandler
       6  zcl_addExternalFoundationHandler::?relay
     591  zcl_event_loop
       6  zcl_event_loop::?relay
      60  zcl_getExternalFoundationHandler
       6  zcl_getExternalFoundationHandler::?relay
       9  zcl_getParsedTransSeqNum
       6  zcl_getParsedTransSeqNum::?relay
      12  zcl_getRawAFMsg
       6  zcl_getRawAFMsg::?relay
       1  zcl_radius
      96  zcl_registerAttrList
       6  zcl_registerAttrList::?relay
      72  zcl_registerClusterOptionList
       6  zcl_registerClusterOptionList::?relay
      73  zcl_registerCmdList
       6  zcl_registerCmdList::?relay
      10  zcl_registerForMsg
       6  zcl_registerForMsg::?relay
       8  zcl_registerForMsgExt
       6  zcl_registerForMsgExt::?relay
      89  zcl_registerPlugin
       6  zcl_registerPlugin::?relay
      58  zcl_registerReadWriteCB
       6  zcl_registerReadWriteCB::?relay
      15  zcl_registerValidateAttrData
       6  zcl_registerValidateAttrData::?relay

 
 14 569 bytes in segment BANKED_CODE
    420 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
      4 bytes in segment XDATA_ROM_C
     17 bytes in segment XDATA_Z
 
    513 bytes of CODE     memory
      0 bytes of CONST    memory (+ 4 bytes shared)
 14 569 bytes of HUGECODE memory
     18 bytes of XDATA    memory

Errors: none
Warnings: none
